{"version":3,"sources":["webpack:///l.autolabelSA.js","webpack:///webpack/bootstrap 7cd8de0c16c34ab5b6ad","webpack:///./src/MapPart.js","webpack:///./src/autoLabeler.js","webpack:///./src/DOMEssentials.js","webpack:///./src/geomEssentials.js","webpack:///./src/third_party/GreinerHormann/src/greiner-hormann.js","webpack:///./src/third_party/GreinerHormann/src/clip.js","webpack:///./src/third_party/GreinerHormann/src/polygon.js","webpack:///./src/third_party/GreinerHormann/src/vertex.js","webpack:///./src/third_party/GreinerHormann/src/intersection.js","webpack:///./src/simulatedAnnealing.js","webpack:///./src/CandidateGenerator.js","webpack:///./src/LabelItem.js","webpack:///./src/DataReader.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","__onRemove","L","LayerGroup","prototype","onRemove","AutoLabelingSupport","map","this","disableAutoLabel","enableAutoLabel","options","_map","autoLabeler","_al_options","labelStyle","propertyName","priority","zoomToStartLabel","addLayer","autoLabelEnabled","hasLayer","remLayer","include","Map","addInitHook","whenReady","autolabel","autolabelOptions","simulatedAnnealing","dataReader","AutoLabeler","Evented","extend","_nodes","_layers2label","showBBoxes","debug","labelsDelay","checkLabelsInside","minimizeTotalOverlappingArea","deleteIfNoSolution","doNotShowIfSegIsTooSmall","annealingOptions","_autoLabel","initialize","setOptions","layer","indexOf","push","ind","splice","toggleAutoLabelling","renderer","on","_apply_doAutoLabel","_zoomstarttrig","_dodebug","_ctimerID","off","clearTimeout","al","lDelay","setTimeout","_doAutoLabel","_clearNodes","message","console","log","getZoom","all_items","readDataToLabel","prepareCurSegments","maxlabelcount","length","curset","getInitialRandomState","_renderNodes","_createPolygonNode","poly","highlited","node","SVG","create","points","i","x","y","setAttribute","trim","svg","_container","removeChild","labelset","polynode","overlaps","appendChild","geomEssentials","convertClientRectToArrayOfArrays","rect","res","height_correction","height","width","movePolyByAdding","getBoundingBox","getBoundingClientRect","point","createSVGTextNode","text","textstyle","replace","textContent","greinerHormann","computeSegmentsLengths","polyline","result","k","distanceTo","translateSegment","a","b","add","computeSlope","s","o","lineIntersection","d","slope1","slope2","getNormalOnSegment","slope","normalizePt","get2dVectorLength","pt","Math","sqrt","divideBy","translateByNormals","out_polyline","normal","multiplyBy","current_segment","pt_intersect","interpolateOnPointSegment","ratio","getSegmentIdxAndDistByOffset","offset","computed_lengths","cdist","getIndexBasedOnTotalLengthRandom","totalLength","random_pos","random","clen","extractSubPolylineByOffsetValues","offset_start","offset_end","start","end","start_point","end_point","computeLineBoundaryPolygon","lower_boundary","slice","upper_boundary","Array","apply","reverse","clipPoly","poly1","poly2","intersection","addPoly","union","subtractPoly","diff","polyArea","area","xDiff","yDiff","checkOverLappingArea","calculateAreaNotOnlyFactOfOverlapping","clipped","rotatePoly","basepoint","angle","angleRad","PI","pPoint","x_rotated","cos","sin","y_rotated","pt2add","movePolyByMovingTo","moveto","createPoly","clip","polygonA","polygonB","Polygon","eA","eB","source","Vertex","Intersection","arrayVertices","first","vertices","_lastUnprocessed","_arrayVertices","isArray","len","addVertex","vertex","next","prev","insertVertex","curr","equals","_distance","getNext","v","_isIntersection","getFirstIntersect","_firstIntersect","_visited","hasUnprocessed","getPoints","sourceForwards","clipForwards","sourceInClip","clipInSource","sourceVertex","clipVertex","valid","sourceIntersection","createIntersection","toSource","clipIntersection","toClip","_corresponding","isInside","_isEntry","list","current","visit","arguments","distance","oddNodes","s1","s2","c1","c2","candidateGenerator","candidate","computeLabelCandidate","assignCostFunctionValuesToLastEl","overlapping_values","evaluateCurSet","overlap_values","j","curlabel_value","markOveralppedLabels","overlappedvalues","counter","getOverlappingLabelsIndexes","curvalues","swapCandidateInLabelSetToNew","idx","label_index","all_items_index","new_candidate","applyNewPositionsForLabelsInArray","idx_array","evaluateAfterSeveralChanged","changedLabels","changedLabelIndex","pop","dodebug","processOptions","t0","decrease_value","tmin","constant_temp_repositionings","max_improvments_count","max_noimprove_count","maxsteps","maxtotaliterations","allowBothSidesOfLine","lineDiscreteStepPx","perform","callback","context","performance","now","t","stepcount","iterations","This","doReturn","improvements_count","no_improve_count","oldvalues","oldset","overlapped_indexes","delta","P","exp","itemFactory","obtainCandidateForPoint","obtainCandidateForPoly","polygon","obtainCandidateForPolyLineByRandomStartOffset","item","random_offset","candidatePosition","layer_type","labelItem","txNode","txSize","hostArray","basic_item","data","host","index","lastIndexOf","readData","_layer_type","_parts","partIndex","nextPart","segCount","offset_or_origin","_item","_poly","_computePolyForLine","start_offset","final_offset","end_offset","subPolyline","_computePoly","DOMEssentials","lg","map_to_add","eachLayer","feature","properties","size","firstItem","nextPartIndex","_applyLineFeatureData"],"mappings":"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","file":"l.autolabelSA.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"./\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t(function () {\r\n\t  \"use strict\";\r\n\t\r\n\t  var autoLabeler = __webpack_require__(1);\r\n\t\r\n\t  var __onRemove = L.LayerGroup.prototype.onRemove;\r\n\t  //to include in LabelGroup\r\n\t  var AutoLabelingSupport = {\r\n\t      /**\r\n\t      handle removing layer from the map\r\n\t      */\r\n\t      onRemove: function (map) {\r\n\t      this.disableAutoLabel();\r\n\t        __onRemove.call(this, map);\r\n\t    },\r\n\t\r\n\t\r\n\t    /**\r\n\t     enable autolabeling for this layerGroup, additionally set the current_map variable if it is undefined and hooks label painting on moveend /zoomend events\r\n\t     it adds this layerGroup to the _layers2label array, so _doAutoLabel function will know about this layerGroup\r\n\t     @param {Object} options: labelStyle - css string to describe labels look, for now one for all layers in group, propertyName - a property from layer.feature.properties which we label on map\r\n\t    */\r\n\t    enableAutoLabel:function(options){\r\n\t      if(!this._map)return;\r\n\t      if(!this._map.autoLabeler)return;\r\n\t      this._al_options = options || {};\r\n\t      this._al_options.labelStyle = options.labelStyle || \"fill: lime; stroke: #000000;  font-size: 20px;\"; //TODO [enableAutoLabel] add ability to set unique style for each feature\r\n\t      this._al_options.propertyName = options.propertyName || \"name\";\r\n\t      this._al_options.priority = options.priority || 0; //highest\r\n\t      this._al_options.zoomToStartLabel = options.zoomToStartLabel || this._map.autoLabeler.options.zoomToStartLabel;\r\n\t      this._map.autoLabeler.addLayer(this);\r\n\t    },\r\n\t\r\n\t    /**\r\n\t    Obtain autlabelling state for this layerGroup\r\n\t    @returns {Boolean}\r\n\t    */\r\n\t    autoLabelEnabled:function(){\r\n\t      if(!this._map.autoLabeler)return false;\r\n\t      return this._map.autoLabeler.hasLayer(this);\r\n\t    },\r\n\t\r\n\t    /**\r\n\t    disable autolabelling\r\n\t    */\r\n\t    disableAutoLabel:function(){\r\n\t      if(!this._map.autoLabeler){\r\n\t        delete this._al_options;\r\n\t        return;\r\n\t      }\r\n\t      if(this._map.autoLabeler.remLayer(this)){\r\n\t        delete this._al_options;\r\n\t      }\r\n\t    }\r\n\t  }\r\n\t\r\n\t  L.LayerGroup.include(AutoLabelingSupport);\r\n\t\r\n\t  L.Map.addInitHook(function () {\r\n\t          this.whenReady(function () {\r\n\t              if (this.options.autolabel) {\r\n\t                this.autoLabeler = L.autoLabeler(this,this.options.autolabelOptions)\r\n\t              }\r\n\t          });\r\n\t      });\r\n\t\r\n\t})();\r\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar DOMEssentials = __webpack_require__(2);\r\n\tvar geomEssentials = __webpack_require__(3);\r\n\tvar simulatedAnnealing = __webpack_require__(9);\r\n\tvar dataReader = __webpack_require__(12);\r\n\t\r\n\tL.AutoLabeler = L.Evented.extend(\r\n\t {\r\n\t    _nodes:[], //an array for storing SVG node to draw while autolabelling\r\n\t    _layers2label:[], //an array to know which layergroups are to label\r\n\t    options:{\r\n\t      showBBoxes:false, //display bounding boxes around texts\r\n\t      debug:true,//show debug info in hte cons\r\n\t      labelsDelay:1000,//a time after update event of renderer when labelling should start, if zero - errors while zooming\r\n\t      checkLabelsInside:true,//re-clip all segments to entirely fit map window without padding, disabling increases performance, but some labels maybe invisible due to padding of renderer\r\n\t      zoomToStartLabel:13,//if map zoom lev is below this, do not show labels\r\n\t      minimizeTotalOverlappingArea:false, //if true, minimize not the count of overlapping labels, but instead their total overlapping area\r\n\t      deleteIfNoSolution:false,//TODO [setAutoLabelOptions] if no solution can be achieivd, delete some of the labels, which are overlapping, based on their layer al_options.priority or random if equal\r\n\t      doNotShowIfSegIsTooSmall:false, //TODO [setAutoLabelOptions] if segment length is less then textlength of text, do not show this text\r\n\t      annealingOptions:{}\r\n\t    }, //autolabel options\r\n\t\r\n\t    _autoLabel:false, //to determine if autolabelling is set for this map\r\n\t\r\n\t    initialize: function (map, options) {\r\n\t      L.setOptions(this, options);\r\n\t      this._map=map;\r\n\t    },\r\n\t\r\n\t    hasLayer:function(layer){\r\n\t      return this._layers2label.indexOf(layer)!=-1;\r\n\t    },\r\n\t\r\n\t    addLayer:function(layer){\r\n\t      if(!this.hasLayer(layer))this._layers2label.push(layer);\r\n\t    },\r\n\t\r\n\t    remLayer:function(layer){\r\n\t      var ind=this._layers2label.indexOf(layer);\r\n\t      if(ind>=0){\r\n\t        this._layers2label.splice(ind,1);\r\n\t      }\r\n\t      return ind>=0;\r\n\t    },\r\n\t\r\n\t    /**\r\n\t    toggles autolabeling\r\n\t    */\r\n\t    toggleAutoLabelling:function(){ //this not tested yet\r\n\t      if(this._autoLabel)this.disableAutoLabel();else this.enableAutoLabel();\r\n\t    },\r\n\t\r\n\t    /**\r\n\t    enable autolabeling\r\n\t    */\r\n\t    enableAutoLabel:function(){\r\n\t      if(!this._map){\r\n\t        this._dodebug('no map attached');\r\n\t        return;\r\n\t      }\r\n\t      if(!this._map.options.renderer){\r\n\t        this._dodebug('renderer is invalid');\r\n\t        return;\r\n\t      }\r\n\t      this._map.options.renderer.on(\"update\",this._apply_doAutoLabel);\r\n\t      this._map.on(\"zoomstart\",function(){this._zoomstarttrig=1});\r\n\t      this._map.on(\"zoomend\",function(){this._zoomstarttrig=0});\r\n\t      this._autoLabel = true;\r\n\t    },\r\n\t\r\n\t    //to check if zoomstart event is fired to prevent autolabeling BEFORE zoomend\r\n\t    _zoomstarttrig:0,\r\n\t\r\n\t    //id of timeout after which AutoLabeling should be done each time - used to stop timer in case of changed map state BEFORE autolabelling was performed\r\n\t    _ctimerID:-1,\r\n\t\r\n\t    /**\r\n\t    disable autolabeling for this map\r\n\t    */\r\n\t    disableAutoLabel:function(){\r\n\t      this._map.options.renderer.off(\"update\",this._apply_doAutoLabel);\r\n\t      this._autoLabel=false;\r\n\t    },\r\n\t\r\n\t    /*\r\n\t    beacuse we using update event of renderer, here we switching to map context and handling two-time update event of SVG renderer\r\n\t    */\r\n\t    _apply_doAutoLabel:function(){\r\n\t      if(this._map.autoLabeler._ctimerID!=-1)clearTimeout(this._map.autoLabeler._ctimerID);\r\n\t      if(this._map.autoLabeler._zoomstarttrig==0){\r\n\t        var al = this._map.autoLabeler;\r\n\t        var lDelay = this._map.autoLabeler.options.labelsDelay;\r\n\t        this._map.autoLabeler._ctimerID=setTimeout(function(){al._doAutoLabel()},lDelay);\r\n\t      }\r\n\t      this._map.autoLabeler._clearNodes();\r\n\t    },\r\n\t\r\n\t    _dodebug:function(message){\r\n\t      if(this.options.debug)console.log(message);\r\n\t    },\r\n\t\r\n\t    /**\r\n\t    this function obtains visible polyline segments from screen and computes optimal positions and draws labels on map\r\n\t    */\r\n\t    _doAutoLabel:function() {\r\n\t      if(!this._autoLabel)return; //nothing to do here\r\n\t      if(this._map.getZoom()>this.options.zoomToStartLabel){\r\n\t        dataReader._map=this._map;\r\n\t        var all_items  =dataReader.readDataToLabel(this._map) //array for storing paths and values\r\n\t        dataReader.prepareCurSegments(all_items,{maxlabelcount:80});\r\n\t        if(all_items.length==0){\r\n\t          this._clearNodes();\r\n\t          return;\r\n\t        }\r\n\t        var curset = simulatedAnnealing.getInitialRandomState(all_items);\r\n\t        this._renderNodes(curset);\r\n\t        //simulatedAnnealing.perform(all_items,this.options.annealingOptions,this._renderNodes,this);\r\n\t      }else{\r\n\t        this._clearNodes();\r\n\t      }\r\n\t    },\r\n\t\r\n\t    /**\r\n\t    for test purposes now, creates a polygon node useing poly Array of points\r\n\t    */\r\n\t    _createPolygonNode:function(poly,highlited){\r\n\t      var node = L.SVG.create('polygon');\r\n\t      var points='';\r\n\t      for(var i=0;i<poly.length;i++){\r\n\t        points+=poly[i].x+','+poly[i].y+' ';\r\n\t      }\r\n\t      node.setAttribute('points', points.trim());\r\n\t      if(highlited){\r\n\t        node.setAttribute('style','fill: red; fill-opacity:0.3; stroke: black;');\r\n\t      }\r\n\t      else node.setAttribute('style','fill: yellow; fill-opacity:0.1; stroke: black;');\r\n\t      return node;\r\n\t    },\r\n\t\r\n\t    /**\r\n\t    clears label on the screen\r\n\t    */\r\n\t    _clearNodes:function() {\r\n\t    var svg = this._map.options.renderer._container;  //to work with SVG\r\n\t      for(var i=0;i<this._nodes.length;i++){//clear _nodes on screen\r\n\t        svg.removeChild(this._nodes[i]);\r\n\t      }\r\n\t      this._nodes=[];\r\n\t      // this._dodebug(\"Cleared nodes\");\r\n\t    },\r\n\t\r\n\t    /**\r\n\t    renders computed labelset on the screen via svg\r\n\t    TODO [_renderNodes] place textOnPath\r\n\t    */\r\n\t    _renderNodes:function(labelset){\r\n\t      var svg =  this._map.options.renderer._container;  //to work with SVG\r\n\t      this._clearNodes(); //clearscreen\r\n\t      for(var m in labelset){\r\n\t        // var node = labelset[m].t.content_node;\r\n\t        // var x = labelset[m].pos.x;\r\n\t        // var y = labelset[m].pos.y;\r\n\t        // node.setAttribute('x', x);\r\n\t        // node.setAttribute('y', y);\r\n\t        // var transform ='rotate('+ Math.floor(labelset[m].a)+','+Math.floor(x)+','+Math.floor(y)+')';\r\n\t        // transform = transform.replace(/ /g, '\\u00A0');\r\n\t        // node.setAttribute('transform',transform);\r\n\t        // svg.appendChild(node);\r\n\t        // this._nodes.push(node);//add this labl to _nodes array, so we can erase it from the screen later\r\n\t        if(this.options.showBBoxes){\r\n\t          //here for testing purposes\r\n\t          var polynode = this._createPolygonNode(labelset[m].poly(),labelset[m].overlaps);\r\n\t          svg.appendChild(polynode);\r\n\t          this._nodes.push(polynode); //add this polygon to _nodes array, so we can erase it from the screen later\r\n\t        }\r\n\t      }\r\n\t    }\r\n\t  }\r\n\t)\r\n\t\r\n\tL.autoLabeler = function(map,options){\r\n\t  return new L.AutoLabeler(map,options);\r\n\t}\r\n\t\r\n\t// module.exports = autoLabeler;\r\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t//a class to compute pixel dimensions of texts\r\n\t/** @namespace DOMEssentials*/\r\n\t'use strict';\r\n\tvar geomEssentials = __webpack_require__(3);\r\n\t\r\n\tmodule.exports = {\r\n\t  /**\r\n\t  converts TextRectangle object to clockwise array of 2d-arrays, representing rectangular poly\r\n\t  @param {TextRectangle} rect: a bbox for text\r\n\t  @returns {Array}\r\n\t  @memberof DOMEssentials#\r\n\t  */\r\n\t  convertClientRectToArrayOfArrays:function(rect) {\r\n\t    var res=[];\r\n\t    var height_correction=rect.height*0.2; //beacuse getBoundingClientRect give a bit false height info\r\n\t    res.push([0,0]);\r\n\t    res.push([0,-rect.height]);\r\n\t    res.push([rect.width,-rect.height]);\r\n\t    res.push([rect.width,0]);\r\n\t    res=geomEssentials.movePolyByAdding(res,[0,height_correction]);\r\n\t    return res;\r\n\t  },\r\n\t\r\n\t  /**\r\n\t  returns a bounding box for horizontal text with style as in t.content_node\r\n\t  @param {Object} map: current map\r\n\t  @param {Object} node: textNode\r\n\t  @returns {L.Point} : a bbox for node, as width and height\r\n\t  @memberof DOMEssentials#\r\n\t  */\r\n\t  getBoundingBox:function(map,node){\r\n\t    var svg = map.options.renderer._container;\r\n\t    svg.appendChild(node);\r\n\t    var rect = node.getBoundingClientRect();\r\n\t    svg.removeChild(node);\r\n\t    return L.point(rect.width,rect.height);\r\n\t  },\r\n\t\r\n\t  /**\r\n\t  creates SVG text node with specified style and handles some formatting issues\r\n\t  @param {String} text: text for node\r\n\t  @param {String} textstyle: CSS style String\r\n\t  @returns {TextNode} : SVG node\r\n\t  */\r\n\t  createSVGTextNode:function(text,textstyle){\r\n\t    text = text.replace(/ /g, '\\u00A0');  // Non breakable spaces\r\n\t    var node =L.SVG.create('text');\r\n\t    node.setAttribute('style',textstyle);\r\n\t    node.textContent = text;\r\n\t    return node;\r\n\t  }\r\n\t}\r\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t//a class to perfrom geometric stuff\r\n\t/** @namespace geomEssentials*/\r\n\t'use strict';\r\n\t\r\n\tvar greinerHormann = __webpack_require__(4);\r\n\t\r\n\tvar geomEssentials = {\r\n\t\r\n\t  /**\r\n\t  @param {Array} polyline: consists of L.Point\r\n\t  @returns {Array}: number array with length=polyline.length-1 with length of segs\r\n\t  */\r\n\t  computeSegmentsLengths:function(polyline){\r\n\t    var result=[];\r\n\t    for(var k=1;k<polyline.length;k++){\r\n\t      result.push(polyline[k].distanceTo(polyline[k-1]));\r\n\t    }\r\n\t    return result;\r\n\t  },\r\n\t\r\n\t  /**\r\n\t  translates segment to new loc by adding point to its vertices\r\n\t  @param {L.Point} a:\r\n\t  @param {L.Point} b:\r\n\t  @param {L.Point} point:\r\n\t  @returns {Array}:\r\n\t  */\r\n\t  translateSegment:function(a,b, point){\r\n\t    var result=[];\r\n\t    result.push(a.add(point)); result.push(b.add(point));\r\n\t    return result;\r\n\t  },\r\n\t\r\n\t  /**\r\n\t  code from L.GeometryUtil plugin\r\n\t       Returns slope (Ax+B) between two points.\r\n\t        @param {L.Point} a\r\n\t        @param {L.Point} b\r\n\t        @returns {Object} with ``a`` and ``b`` properties.\r\n\t     */\r\n\t  computeSlope: function(a, b) {\r\n\t      var s = (b.y - a.y) / (b.x - a.x),\r\n\t          o = a.y - (s * a.x);\r\n\t      return L.point(s,o);\r\n\t  },\r\n\t\r\n\t  /**\r\n\t  computes a point where two lines intersection\r\n\t  @param {L.Point} a: a first point of first line defined by two points\r\n\t  @param {L.Point} b: a second point of first line defined by two points\r\n\t  @param {L.Point} c: a first point of second line defined by two points\r\n\t  @param {L.Point} d: a first point of second line defined by two points\r\n\t  @returns {L.Point} :intersection point or null if lines are parallel to each other\r\n\t  */\r\n\t  lineIntersection:function(a,b,c,d){\r\n\t    var slope1=this.computeSlope(a,b), slope2=this.computeSlope(c,d);\r\n\t    if(slope1.x===slope2.x)return;\r\n\t    var x = (slope2.y - slope1.y) / (slope1.x - slope2.x);\r\n\t    var y = slope1.x*x + slope1.y;\r\n\t    return L.point(x,y);\r\n\t  },\r\n\t\r\n\t  /**\r\n\t    computes a  unit normal for [a,b] segment\r\n\t    @param {L.Point} a:\r\n\t    @param {L.Point} b:\r\n\t    @returns {L.point}: unit normal\r\n\t  */\r\n\t  getNormalOnSegment:function(a,b){\r\n\t    var slope = this.computeSlope(a,b);\r\n\t    return this.normalizePt(slope);\r\n\t  },\r\n\t\r\n\t  /**\r\n\t  Computes an euclidian length of point\r\n\t  @param {L.Point} pt:\r\n\t  @returns {Number}\r\n\t  */\r\n\t  get2dVectorLength:function(pt){\r\n\t    return Math.sqrt(pt.x*pt.x + pt.y*pt.y);\r\n\t  },\r\n\t\r\n\t  /**\r\n\t  Makes this point a unit-lengthed\r\n\t  @param {L.Point} pt:\r\n\t  @returns {L.Point}:\r\n\t  */\r\n\t  normalizePt:function(pt){\r\n\t    return (pt.x===0&&pt.y===0)?0:pt.divideBy(this.get2dVectorLength(pt));\r\n\t  },\r\n\t\r\n\t  /**\r\n\t  copies segment and translates copy in normal direction by height value (may be negative)\r\n\t  It also extands or shrinks new segments to make sure they are connected to each and other\r\n\t  @param {Array} polyline: polyline to translate segments of which\r\n\t  @param {Number} height:  height of normal\r\n\t  @returns {Array}: translated copy of polyline\r\n\t  */\r\n\t  translateByNormals:function(polyline,height){\r\n\t    var out_polyline=[];\r\n\t    for(var i=0;i<polyline.length-1;i++){\r\n\t      var normal = this.getNormalOnSegment(polyline[i],polyline[i+1]).multiplyBy(height);\r\n\t      var current_segment=this.translateSegment(polyline[i],polyline[i+1],normal);\r\n\t      //now check if current segment is connected well to previous\r\n\t      if(i>0){ //so -> it isn't first segment, and out_polyline has at leat two points\r\n\t        var pt_intersect = this.lineIntersection(out_polyline[out_polyline.length-2],out_polyline[out_polyline.length-1],current_segment[0],current_segment[1]);\r\n\t        out_polyline[out_polyline.length-1] = pt_intersect;\r\n\t        out_polyline.push(current_segment[1]);\r\n\t      }else{\r\n\t        out_polyline.push(current_segment[0]); out_polyline.push(current_segment[1]);\r\n\t      }\r\n\t    }\r\n\t    return out_polyline;\r\n\t  },\r\n\t\r\n\t  /**\r\n\t  code from L.GeometryUtil plugin\r\n\t  @memberof geomEssentials#\r\n\t  */\r\n\t  interpolateOnPointSegment: function (a,b, ratio) {\r\n\t      return L.point(\r\n\t          (a.x * (1 - ratio)) + (ratio * b.x),\r\n\t          (a.y * (1 - ratio)) + (ratio * b.y)\r\n\t      );\r\n\t  },\r\n\t\r\n\t  /**\r\n\t  Get a segment from polyline part by it's offset\r\n\t  @param {Number} offset: na offset for the polyline\r\n\t  @param {Array} polyline: points of the polyline\r\n\t  @param {Array} computed_lengths: precomputed lengths (if available) for polyline segments\r\n\t  @returns {Array} : index of start point of segment and dist which is offset from start of the line to the end of found segment\r\n\t  */\r\n\t  getSegmentIdxAndDistByOffset:function(offset,polyline,computed_lengths){\r\n\t    var cdist=0;\r\n\t    for(var i=0;i<polyline.length-1;i++){\r\n\t      cdist+=computed_lengths[i];\r\n\t      if(offset<=cdist){\r\n\t        return [i,cdist]\r\n\t      }\r\n\t    }\r\n\t  },\r\n\t\r\n\t  /**\r\n\t  based on https://blog.dotzero.ru/weighted-random-simple/\r\n\t  get a random element from segments array of the item, assuming it is sorted lengths ascending order\r\n\t  probability is higher for longer segment\r\n\t  @param {Array} polyline: points of the polyline\r\n\t  @param {Array} computed_lengths: precomputed lengths (if available) for polyline segments\r\n\t  @param {NUmber} totalLength: precomputed total length of the polyline\r\n\t  */\r\n\t  getIndexBasedOnTotalLengthRandom:function(polyline,computed_lengths,totalLength){\r\n\t    var random_pos = Math.random()*totalLength; //get a position random for all segments of this polyline visible on the screen\r\n\t    //obtain and index of segment, to which belongs this position, it is assumed tha segments are sorted by length\r\n\t    var clen=0;\r\n\t    for(var i=0;i<polyline.length-1;i++){\r\n\t      clen+=computed_lengths[i];\r\n\t      if(clen>random_pos)break;\r\n\t    }\r\n\t    return i;\r\n\t  },\r\n\t\r\n\t  /**\r\n\t  Supplement function for extractSubPolyline\r\n\t  returns start index, end index in segments array for item, also first cropped seg and last cropped seg.\r\n\t  If only one seg here, it is crop both ends.\r\n\t  @param {Number} offset_start: should be less than total length of polyline\r\n\t  @param {Number} offset_end: should be greater than offset_start\r\n\t  @param {Array} polyline: points of the polyline\r\n\t  @param {Array} computed_lengths: precomputed lengths (if available) for polyline segments\r\n\t  @returns {Object}:\r\n\t  */\r\n\t  extractSubPolylineByOffsetValues:function(offset_start,offset_end,polyline,computed_lengths){\r\n\t    var start = this.getSegmentIdxAndDistByOffset(offset_start,polyline,computed_lengths),\r\n\t        end = this.getSegmentIdxAndDistByOffset(offset_end,polyline,computed_lengths),\r\n\t        start_point= this.interpolateOnPointSegment(polyline[start[0]],polyline[start[0]+1],(start[1]-offset_start)/computed_lengths[start[0]]),\r\n\t        end_point = this.interpolateOnPointSegment(polyline[end[0]],polyline[end[0]+1],(end[1]-offset_end)/computed_lengths[end[0]]),\r\n\t        result = [start_point];\r\n\t    for(var i=start[0]+1;i<=end[0];i++){ //push every point from end of start segment to segment prior to last\r\n\t      result.push(polyline[i]);\r\n\t    }\r\n\t    result.push(end_point);\r\n\t    return result;\r\n\t  },\r\n\t\r\n\t  /**\r\n\t  Used for calculationg overlaps for text along path (textPath SVG).\r\n\t  @param {Number} start_offset: global offset for this polyline (item), same as used in rendering\r\n\t  @param {Number} end_offset: global offset for this polyline (item), same as used in rendering\r\n\t  @param {LabelItem} item:\r\n\t  @returns {Array} : a poly bounding with height of item.txSize.y\r\n\t  */\r\n\t  computeLineBoundaryPolygon:function(polyline,height){\r\n\t    var lower_boundary = polyline.slice(0);\r\n\t    var upper_boundary=this.translateByNormals(polyline,height);\r\n\t    Array.prototype.push.apply(lower_boundary, upper_boundary.reverse());\r\n\t    return lower_boundary;\r\n\t  },\r\n\t\r\n\t  clipPoly:function(poly1,poly2){\r\n\t    var intersection = greinerHormann.intersection(poly1, poly2);\r\n\t    if(!intersection)return [];\r\n\t    if(intersection.length>0)return intersection[0];\r\n\t  },\r\n\t\r\n\t  /**\r\n\t  returns a combined poly from two\r\n\t  */\r\n\t  addPoly:function(poly1,poly2){\r\n\t    var union = greinerHormann.union(poly1, poly2);\r\n\t    if(!union)return [];\r\n\t    if(union.length>0)return union[0];\r\n\t  },\r\n\t\r\n\t  subtractPoly:function(poly1,poly2){\r\n\t    var diff = greinerHormann.diff(poly1, poly2);\r\n\t    if(!diff)return [];else return diff;\r\n\t  },\r\n\t\r\n\t  /**\r\n\t  code from http://www.codeproject.com/Articles/13467/A-JavaScript-Implementation-of-the-Surveyor-s-Form\r\n\t  for single polygon only, and no holes in\r\n\t  @param {Array} poly: a poly to determine area of\r\n\t  @memberof geomEssentials#\r\n\t  */\r\n\t  polyArea:function(poly) {\r\n\t    // Calculate the area of a polygon\r\n\t    // using the data stored\r\n\t    // in the arrays x and y\r\n\t    var area = 0.0;\r\n\t    if(poly){\r\n\t      var poly=poly.slice(0);\r\n\t      if(poly.length>2)poly.push(poly[0]); //close the poly\r\n\t      for(var k = 0; k < poly.length-1; k++ ) {\r\n\t          var xDiff = poly[k+1][0] - poly[k][0];\r\n\t          var yDiff = poly[k+1][1] - poly[k][1];\r\n\t          area += + poly[k][0] * yDiff - poly[k][1] * xDiff;\r\n\t      }\r\n\t      area = 0.5 * area;\r\n\t    }\r\n\t    return area;\r\n\t  },\r\n\t\r\n\t\r\n\t  /**\r\n\t  check if two labels overlab, if no returns false, if yes returns ???area OR polygon??? of averlap\r\n\t  @param {} poly1:a first polygon to check overlap with second\r\n\t  @param {} poly2:a second polygon to check overlap with first\r\n\t  @returns {float}: an area of overlapping, zero if no overlapping\r\n\t  */\r\n\t  checkOverLappingArea:function(poly1,poly2,calculateAreaNotOnlyFactOfOverlapping) {\r\n\t    var clipped = this.clipPoly(poly1,poly2);\r\n\t    if(calculateAreaNotOnlyFactOfOverlapping){\r\n\t      var area =this.polyArea(clipped);\r\n\t      return area;\r\n\t    };\r\n\t    if(clipped.length>0)return 1;else return 0; //for performance, skip area calculation\r\n\t  },\r\n\t\r\n\t  /**\r\n\t  rotates given polygon to a given angle around basepoint\r\n\t  code partialy from web, don't remember from...\r\n\t  @param {Array} poly: a polygon to rotate\r\n\t  @param {Array} basepoint: base point\r\n\t  @param {float} angle: an angle in degrees\r\n\t  @returns {Array}: rotated poly\r\n\t  @memberof geomEssentials#\r\n\t  */\r\n\t  rotatePoly:function(poly, basepoint,angle){\r\n\t    var res=[];\r\n\t    var angleRad = angle*Math.PI/180;\r\n\t    for(var i=0;i<poly.length;i++){\r\n\t      var pPoint = poly[i],\r\n\t      x_rotated = Math.cos(angleRad)*(pPoint[0]-basepoint[0]) - Math.sin(angleRad)*(pPoint[1]-basepoint[1]) + basepoint[0],\r\n\t      y_rotated = Math.sin(angleRad)*(pPoint[0]-basepoint[0]) + Math.cos(angleRad)*(pPoint[1]-basepoint[1]) + basepoint[1];\r\n\t      res.push([x_rotated,y_rotated]);\r\n\t    }\r\n\t    return res;\r\n\t  },\r\n\t\r\n\t  /**\r\n\t  moves a poly by adding pt2add point to all its vertices\r\n\t  @param {Array} poly: a poly to movePoly\r\n\t  @param {Array} pt2add: a point to add to all vertices\r\n\t  @returns {Array}: moved poly\r\n\t  @memberof geomEssentials#\r\n\t  */\r\n\t  movePolyByAdding:function(poly,pt2add) {\r\n\t    var res=poly.slice(0);\r\n\t    for(var i=0;i<poly.length;i++){\r\n\t      res[i][0]+=pt2add[0]; res[i][1]+=pt2add[1];\r\n\t    }\r\n\t    return res;\r\n\t  },\r\n\t\r\n\t  /**\r\n\t  moves a poly by translating all its vertices to moveto, using first vertex as origin\r\n\t  @param {Array} poly: a poly to movePoly\r\n\t  @param {Array} moveto: where translate all vertices\r\n\t  @returns {Array}: moved poly\r\n\t  @memberof geomEssentials#\r\n\t  */\r\n\t  movePolyByMovingTo:function(poly,moveto){\r\n\t    var res=poly.slice(0);\r\n\t    moveto[0] = moveto[0]-poly[0][0];\r\n\t    moveto[1] = moveto[1]-poly[0][1];\r\n\t    for(var i=1;i<poly.length;i++){\r\n\t      res[i][0]+=moveto[0]; res[i][1]+=moveto[1];\r\n\t    }\r\n\t    return res;\r\n\t  },\r\n\t\r\n\t  createPoly:function(width,height){\r\n\t    //TODO[createPoly]\r\n\t  }\r\n\t\r\n\t}\r\n\t\r\n\tmodule.exports = geomEssentials;\r\n\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar clip = __webpack_require__(5);\r\n\t\r\n\tmodule.exports = {\r\n\t    /**\r\n\t     * @api\r\n\t     * @param  {Array.<Array.<Number>|Array.<Object>} polygonA\r\n\t     * @param  {Array.<Array.<Number>|Array.<Object>} polygonB\r\n\t     * @return {Array.<Array.<Number>>|Array.<Array.<Object>|Null}\r\n\t     */\r\n\t    union: function(polygonA, polygonB) {\r\n\t        return clip(polygonA, polygonB, false, false);\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * @api\r\n\t     * @param  {Array.<Array.<Number>|Array.<Object>} polygonA\r\n\t     * @param  {Array.<Array.<Number>|Array.<Object>} polygonB\r\n\t     * @return {Array.<Array.<Number>>|Array.<Array.<Object>>|Null}\r\n\t     */\r\n\t    intersection: function(polygonA, polygonB) {\r\n\t        return clip(polygonA, polygonB, true, true);\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * @api\r\n\t     * @param  {Array.<Array.<Number>|Array.<Object>} polygonA\r\n\t     * @param  {Array.<Array.<Number>|Array.<Object>} polygonB\r\n\t     * @return {Array.<Array.<Number>>|Array.<Array.<Object>>|Null}\r\n\t     */\r\n\t    diff: function(polygonA, polygonB) {\r\n\t        return clip(polygonA, polygonB, false, true);\r\n\t    },\r\n\t\r\n\t    clip: clip\r\n\t};\r\n\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Polygon = __webpack_require__(6);\r\n\t\r\n\t/**\r\n\t * Clip driver\r\n\t * @api\r\n\t * @param  {Array.<Array.<Number>>} polygonA\r\n\t * @param  {Array.<Array.<Number>>} polygonB\r\n\t * @param  {Boolean}                sourceForwards\r\n\t * @param  {Boolean}                clipForwards\r\n\t * @return {Array.<Array.<Number>>}\r\n\t */\r\n\tmodule.exports = function(polygonA, polygonB, eA, eB) {\r\n\t    var result, source = new Polygon(polygonA),\r\n\t        clip = new Polygon(polygonB),\r\n\t        result = source.clip(clip, eA, eB);\r\n\t\r\n\t    return result;\r\n\t};\r\n\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Vertex = __webpack_require__(7);\r\n\tvar Intersection = __webpack_require__(8);\r\n\t\r\n\t/**\r\n\t * Polygon representation\r\n\t * @param {Array.<Array.<Number>>} p\r\n\t * @param {Boolean=}               arrayVertices\r\n\t *\r\n\t * @constructor\r\n\t */\r\n\tvar Polygon = function(p, arrayVertices) {\r\n\t\r\n\t    /**\r\n\t     * @type {Vertex}\r\n\t     */\r\n\t    this.first = null;\r\n\t\r\n\t    /**\r\n\t     * @type {Number}\r\n\t     */\r\n\t    this.vertices = 0;\r\n\t\r\n\t    /**\r\n\t     * @type {Vertex}\r\n\t     */\r\n\t    this._lastUnprocessed = null;\r\n\t\r\n\t    /**\r\n\t     * Whether to handle input and output as [x,y] or {x:x,y:y}\r\n\t     * @type {Boolean}\r\n\t     */\r\n\t    this._arrayVertices = (typeof arrayVertices === \"undefined\") ?\r\n\t        Array.isArray(p[0]) :\r\n\t        arrayVertices;\r\n\t\r\n\t    for (var i = 0, len = p.length; i < len; i++) {\r\n\t        this.addVertex(new Vertex(p[i]));\r\n\t    }\r\n\t};\r\n\t\r\n\t/**\r\n\t * Add a vertex object to the polygon\r\n\t * (vertex is added at the 'end' of the list')\r\n\t *\r\n\t * @param vertex\r\n\t */\r\n\tPolygon.prototype.addVertex = function(vertex) {\r\n\t    if (this.first == null) {\r\n\t        this.first = vertex;\r\n\t        this.first.next = vertex;\r\n\t        this.first.prev = vertex;\r\n\t    } else {\r\n\t        var next = this.first,\r\n\t            prev = next.prev;\r\n\t\r\n\t        next.prev = vertex;\r\n\t        vertex.next = next;\r\n\t        vertex.prev = prev;\r\n\t        prev.next = vertex;\r\n\t    }\r\n\t    this.vertices++;\r\n\t};\r\n\t\r\n\t/**\r\n\t * Inserts a vertex inbetween start and end\r\n\t *\r\n\t * @param {Vertex} vertex\r\n\t * @param {Vertex} start\r\n\t * @param {Vertex} end\r\n\t */\r\n\tPolygon.prototype.insertVertex = function(vertex, start, end) {\r\n\t    var prev, curr = start;\r\n\t\r\n\t    while (!curr.equals(end) && curr._distance < vertex._distance) {\r\n\t        curr = curr.next;\r\n\t    }\r\n\t\r\n\t    vertex.next = curr;\r\n\t    prev = curr.prev;\r\n\t\r\n\t    vertex.prev = prev;\r\n\t    prev.next = vertex;\r\n\t    curr.prev = vertex;\r\n\t\r\n\t    this.vertices++;\r\n\t};\r\n\t\r\n\t/**\r\n\t * Get next non-intersection point\r\n\t * @param  {Vertex} v\r\n\t * @return {Vertex}\r\n\t */\r\n\tPolygon.prototype.getNext = function(v) {\r\n\t    var c = v;\r\n\t    while (c._isIntersection) {\r\n\t        c = c.next;\r\n\t    }\r\n\t    return c;\r\n\t};\r\n\t\r\n\t/**\r\n\t * Unvisited intersection\r\n\t * @return {Vertex}\r\n\t */\r\n\tPolygon.prototype.getFirstIntersect = function() {\r\n\t    var v = this._firstIntersect || this.first;\r\n\t\r\n\t    do {\r\n\t        if (v._isIntersection && !v._visited) {\r\n\t            break;\r\n\t        }\r\n\t\r\n\t        v = v.next;\r\n\t    } while (!v.equals(this.first));\r\n\t\r\n\t    this._firstIntersect = v;\r\n\t    return v;\r\n\t};\r\n\t\r\n\t/**\r\n\t * Does the polygon have unvisited vertices\r\n\t * @return {Boolean} [description]\r\n\t */\r\n\tPolygon.prototype.hasUnprocessed = function() {\r\n\t    var v = this._lastUnprocessed || this.first;\r\n\t    do {\r\n\t        if (v._isIntersection && !v._visited) {\r\n\t            this._lastUnprocessed = v;\r\n\t            return true;\r\n\t        }\r\n\t\r\n\t        v = v.next;\r\n\t    } while (!v.equals(this.first));\r\n\t\r\n\t    this._lastUnprocessed = null;\r\n\t    return false;\r\n\t};\r\n\t\r\n\t/**\r\n\t * The output depends on what you put in, arrays or objects\r\n\t * @return {Array.<Array<Number>|Array.<Object>}\r\n\t */\r\n\tPolygon.prototype.getPoints = function() {\r\n\t    var points = [],\r\n\t        v = this.first;\r\n\t\r\n\t    if (this._arrayVertices) {\r\n\t        do {\r\n\t            points.push([v.x, v.y]);\r\n\t            v = v.next;\r\n\t        } while (v !== this.first);\r\n\t    } else {\r\n\t        do {\r\n\t            points.push({\r\n\t                x: v.x,\r\n\t                y: v.y\r\n\t            });\r\n\t            v = v.next;\r\n\t        } while (v !== this.first);\r\n\t    }\r\n\t\r\n\t    return points;\r\n\t};\r\n\t\r\n\t/**\r\n\t * Clip polygon against another one.\r\n\t * Result depends on algorithm direction:\r\n\t *\r\n\t * Intersection: forwards forwards\r\n\t * Union:        backwars backwards\r\n\t * Diff:         backwards forwards\r\n\t *\r\n\t * @param {Polygon} clip\r\n\t * @param {Boolean} sourceForwards\r\n\t * @param {Boolean} clipForwards\r\n\t */\r\n\tPolygon.prototype.clip = function(clip, sourceForwards, clipForwards) {\r\n\t    var sourceVertex = this.first,\r\n\t        clipVertex = clip.first,\r\n\t        sourceInClip, clipInSource;\r\n\t\r\n\t    // calculate and mark intersections\r\n\t    do {\r\n\t        if (!sourceVertex._isIntersection) {\r\n\t            do {\r\n\t                if (!clipVertex._isIntersection) {\r\n\t                    var i = new Intersection(\r\n\t                        sourceVertex,\r\n\t                        this.getNext(sourceVertex.next),\r\n\t                        clipVertex, clip.getNext(clipVertex.next));\r\n\t\r\n\t                    if (i.valid()) {\r\n\t                        var sourceIntersection =\r\n\t                            Vertex.createIntersection(i.x, i.y, i.toSource),\r\n\t                            clipIntersection =\r\n\t                            Vertex.createIntersection(i.x, i.y, i.toClip);\r\n\t\r\n\t                        sourceIntersection._corresponding = clipIntersection;\r\n\t                        clipIntersection._corresponding = sourceIntersection;\r\n\t\r\n\t                        this.insertVertex(\r\n\t                            sourceIntersection,\r\n\t                            sourceVertex,\r\n\t                            this.getNext(sourceVertex.next));\r\n\t                        clip.insertVertex(\r\n\t                            clipIntersection,\r\n\t                            clipVertex,\r\n\t                            clip.getNext(clipVertex.next));\r\n\t                    }\r\n\t                }\r\n\t                clipVertex = clipVertex.next;\r\n\t            } while (!clipVertex.equals(clip.first));\r\n\t        }\r\n\t\r\n\t        sourceVertex = sourceVertex.next;\r\n\t    } while (!sourceVertex.equals(this.first));\r\n\t\r\n\t    // phase two - identify entry/exit points\r\n\t    sourceVertex = this.first;\r\n\t    clipVertex = clip.first;\r\n\t\r\n\t    sourceInClip = sourceVertex.isInside(clip);\r\n\t    clipInSource = clipVertex.isInside(this);\r\n\t\r\n\t    sourceForwards ^= sourceInClip;\r\n\t    clipForwards ^= clipInSource;\r\n\t\r\n\t    do {\r\n\t        if (sourceVertex._isIntersection) {\r\n\t            sourceVertex._isEntry = sourceForwards;\r\n\t            sourceForwards = !sourceForwards;\r\n\t        }\r\n\t        sourceVertex = sourceVertex.next;\r\n\t    } while (!sourceVertex.equals(this.first));\r\n\t\r\n\t    do {\r\n\t        if (clipVertex._isIntersection) {\r\n\t            clipVertex._isEntry = clipForwards;\r\n\t            clipForwards = !clipForwards;\r\n\t        }\r\n\t        clipVertex = clipVertex.next;\r\n\t    } while (!clipVertex.equals(clip.first));\r\n\t\r\n\t    // phase three - construct a list of clipped polygons\r\n\t    var list = [];\r\n\t\r\n\t    while (this.hasUnprocessed()) {\r\n\t        var current = this.getFirstIntersect(),\r\n\t            // keep format\r\n\t            clipped = new Polygon([], this._arrayVertices);\r\n\t\r\n\t        clipped.addVertex(new Vertex(current.x, current.y));\r\n\t        do {\r\n\t            current.visit();\r\n\t            if (current._isEntry) {\r\n\t                do {\r\n\t                    current = current.next;\r\n\t                    clipped.addVertex(new Vertex(current.x, current.y));\r\n\t                } while (!current._isIntersection);\r\n\t\r\n\t            } else {\r\n\t                do {\r\n\t                    current = current.prev;\r\n\t                    clipped.addVertex(new Vertex(current.x, current.y));\r\n\t                } while (!current._isIntersection);\r\n\t            }\r\n\t            current = current._corresponding;\r\n\t        } while (!current._visited);\r\n\t\r\n\t        list.push(clipped.getPoints());\r\n\t    }\r\n\t\r\n\t    if (list.length === 0) {\r\n\t        if (sourceInClip) {\r\n\t            list.push(this.getPoints());\r\n\t        }\r\n\t        if (clipInSource) {\r\n\t            list.push(clip.getPoints());\r\n\t        }\r\n\t        if (list.length === 0) {\r\n\t            list = null;\r\n\t        }\r\n\t    }\r\n\t\r\n\t    return list;\r\n\t};\r\n\t\r\n\tmodule.exports = Polygon;\r\n\n\n/***/ },\n/* 7 */\n/***/ function(module, exports) {\n\n\t/**\r\n\t * Vertex representation\r\n\t *\r\n\t * @param {Number|Array.<Number>} x\r\n\t * @param {Number=}               y\r\n\t *\r\n\t * @constructor\r\n\t */\r\n\tvar Vertex = function(x, y) {\r\n\t\r\n\t    if (arguments.length === 1) {\r\n\t        // Coords\r\n\t        if (Array.isArray(x)) {\r\n\t            y = x[1];\r\n\t            x = x[0];\r\n\t        } else {\r\n\t            y = x.y;\r\n\t            x = x.x;\r\n\t        }\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * X coordinate\r\n\t     * @type {Number}\r\n\t     */\r\n\t    this.x = x;\r\n\t\r\n\t    /**\r\n\t     * Y coordinate\r\n\t     * @type {Number}\r\n\t     */\r\n\t    this.y = y;\r\n\t\r\n\t    /**\r\n\t     * Next node\r\n\t     * @type {Vertex}\r\n\t     */\r\n\t    this.next = null;\r\n\t\r\n\t    /**\r\n\t     * Previous vertex\r\n\t     * @type {Vertex}\r\n\t     */\r\n\t    this.prev = null;\r\n\t\r\n\t    /**\r\n\t     * Corresponding intersection in other polygon\r\n\t     */\r\n\t    this._corresponding = null;\r\n\t\r\n\t    /**\r\n\t     * Distance from previous\r\n\t     */\r\n\t    this._distance = 0.0;\r\n\t\r\n\t    /**\r\n\t     * Entry/exit point in another polygon\r\n\t     * @type {Boolean}\r\n\t     */\r\n\t    this._isEntry = true;\r\n\t\r\n\t    /**\r\n\t     * Intersection vertex flag\r\n\t     * @type {Boolean}\r\n\t     */\r\n\t    this._isIntersection = false;\r\n\t\r\n\t    /**\r\n\t     * Loop check\r\n\t     * @type {Boolean}\r\n\t     */\r\n\t    this._visited = false;\r\n\t};\r\n\t\r\n\t/**\r\n\t * Creates intersection vertex\r\n\t * @param  {Number} x\r\n\t * @param  {Number} y\r\n\t * @param  {Number} distance\r\n\t * @return {Vertex}\r\n\t */\r\n\tVertex.createIntersection = function(x, y, distance) {\r\n\t    var vertex = new Vertex(x, y);\r\n\t    vertex._distance = distance;\r\n\t    vertex._isIntersection = true;\r\n\t    vertex._isEntry = false;\r\n\t    return vertex;\r\n\t};\r\n\t\r\n\t/**\r\n\t * Mark as visited\r\n\t */\r\n\tVertex.prototype.visit = function() {\r\n\t    this._visited = true;\r\n\t    if (this._corresponding !== null && !this._corresponding._visited) {\r\n\t        this._corresponding.visit();\r\n\t    }\r\n\t};\r\n\t\r\n\t/**\r\n\t * Convenience\r\n\t * @param  {Vertex}  v\r\n\t * @return {Boolean}\r\n\t */\r\n\tVertex.prototype.equals = function(v) {\r\n\t    return this.x === v.x && this.y === v.y;\r\n\t};\r\n\t\r\n\t/**\r\n\t * Check if vertex is inside a polygon by odd-even rule:\r\n\t * If the number of intersections of a ray out of the point and polygon\r\n\t * segments is odd - the point is inside.\r\n\t * @param {Polygon} poly\r\n\t * @return {Boolean}\r\n\t */\r\n\tVertex.prototype.isInside = function(poly) {\r\n\t    var oddNodes = false,\r\n\t        vertex = poly.first,\r\n\t        next = vertex.next,\r\n\t        x = this.x,\r\n\t        y = this.y;\r\n\t\r\n\t    do {\r\n\t        if ((vertex.y < y && next.y >= y ||\r\n\t                next.y < y && vertex.y >= y) &&\r\n\t            (vertex.x <= x || next.x <= x)) {\r\n\t\r\n\t            oddNodes ^= (vertex.x + (y - vertex.y) /\r\n\t                (next.y - vertex.y) * (next.x - vertex.x) < x);\r\n\t        }\r\n\t\r\n\t        vertex = vertex.next;\r\n\t        next = vertex.next || poly.first;\r\n\t    } while (!vertex.equals(poly.first));\r\n\t\r\n\t    return oddNodes;\r\n\t};\r\n\t\r\n\tmodule.exports = Vertex;\r\n\n\n/***/ },\n/* 8 */\n/***/ function(module, exports) {\n\n\t/**\r\n\t * Intersection\r\n\t * @param {Vertex} s1\r\n\t * @param {Vertex} s2\r\n\t * @param {Vertex} c1\r\n\t * @param {Vertex} c2\r\n\t * @constructor\r\n\t */\r\n\tvar Intersection = function(s1, s2, c1, c2) {\r\n\t\r\n\t    /**\r\n\t     * @type {Number}\r\n\t     */\r\n\t    this.x = 0.0;\r\n\t\r\n\t    /**\r\n\t     * @type {Number}\r\n\t     */\r\n\t    this.y = 0.0;\r\n\t\r\n\t    /**\r\n\t     * @type {Number}\r\n\t     */\r\n\t    this.toSource = 0.0;\r\n\t\r\n\t    /**\r\n\t     * @type {Number}\r\n\t     */\r\n\t    this.toClip = 0.0;\r\n\t\r\n\t    var d = (c2.y - c1.y) * (s2.x - s1.x) - (c2.x - c1.x) * (s2.y - s1.y);\r\n\t\r\n\t    if (d === 0) {\r\n\t        return;\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * @type {Number}\r\n\t     */\r\n\t    this.toSource = ((c2.x - c1.x) * (s1.y - c1.y) - (c2.y - c1.y) * (s1.x - c1.x)) / d;\r\n\t\r\n\t    /**\r\n\t     * @type {Number}\r\n\t     */\r\n\t    this.toClip = ((s2.x - s1.x) * (s1.y - c1.y) - (s2.y - s1.y) * (s1.x - c1.x)) / d;\r\n\t\r\n\t    if (this.valid()) {\r\n\t        this.x = s1.x + this.toSource * (s2.x - s1.x);\r\n\t        this.y = s1.y + this.toSource * (s2.y - s1.y);\r\n\t    }\r\n\t};\r\n\t\r\n\t/**\r\n\t * @return {Boolean}\r\n\t */\r\n\tIntersection.prototype.valid = function() {\r\n\t    return (0 < this.toSource && this.toSource < 1) && (0 < this.toClip && this.toClip < 1);\r\n\t};\r\n\t\r\n\tmodule.exports = Intersection;\r\n\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\r\n\t\r\n\tvar geomEssentials = __webpack_require__(3);\r\n\tvar candidateGenerator = __webpack_require__(10);\r\n\t\r\n\tvar simulatedAnnealing = {\r\n\t\r\n\t  /**\r\n\t  computes the random set of positions for text placement with angles and text values\r\n\t  @param {Array} all_items: an array with {t,segs} elements, according to t -text of the polyline, segs - its accepted segments to label on. Result array is generated from items of this array\r\n\t  @returns {Array} : an array with elements such as return values of computeLabelCandidate function\r\n\t  */\r\n\t  getInitialRandomState:function(all_items){\r\n\t    var res=[];\r\n\t    for(var i=0;i<all_items.length;i++){\r\n\t      var candidate = candidateGenerator.computeLabelCandidate(i,all_items);\r\n\t      res.push(candidate);\r\n\t    }\r\n\t    return res;\r\n\t  },\r\n\t\r\n\t  /**\r\n\t  may be a custom function, must add result as last value of input array\r\n\t  @param {Array} overlapping_values: input array of areas\r\n\t  */\r\n\t  assignCostFunctionValuesToLastEl:function(overlapping_values){\r\n\t    var res=0;\r\n\t    for(var i in overlapping_values){\r\n\t      res+=overlapping_values[i];\r\n\t    }\r\n\t    overlapping_values.push(res);\r\n\t  },\r\n\t\r\n\t  /**\r\n\t  summarizing ovelapping of all layers. We store for each label it's total overlapping area with others, the sum values for all labels\r\n\t  @param {Array}:curset:\r\n\t  @returns {Array}: values of areas, last is sum\r\n\t  @memberof MapAutoLabelSupport#\r\n\t  */\r\n\t  evaluateCurSet:function(curset){\r\n\t    var overlap_values=[];\r\n\t    for(var i in curset){\r\n\t      for(var j in curset){\r\n\t        if(i>j){ //to exclude variants like compare (1,3) and then (3,1)\r\n\t        var curlabel_value=geomEssentials.checkOverLappingArea(curset[i].poly(),curset[j].poly(),this.options.minimizeTotalOverlappingArea);\r\n\t        //for each pair(i,j) push it's value into overlap_values array\r\n\t        //we know that we iterate through only lower triangle of matrix (i,j), so we can reconstruct i and j from overlap_values index and vice versa\r\n\t        //we do it to improve speed when recomputing ovelaps in each annealing iteration in order not to compute all overlaps (with high performance cost)\r\n\t        //istead we recompute areas only for changed label\r\n\t        overlap_values.push(curlabel_value);\r\n\t        }\r\n\t      }\r\n\t    }\r\n\t    this.assignCostFunctionValuesToLastEl(overlap_values);\r\n\t    return overlap_values;\r\n\t  },\r\n\t\r\n\t  markOveralppedLabels:function(curset,overlappedvalues){\r\n\t    var counter=0;\r\n\t    for(var i in curset){\r\n\t      for(var j in curset){\r\n\t        if(i>j){\r\n\t          if(overlappedvalues[counter]>0){\r\n\t            curset[i].overlaps = true;\r\n\t            curset[j].overlaps = true;\r\n\t            // this.dodebug(curset[i].t.content_node.textContent +' /// '+curset[j].t.content_node.textContent  )\r\n\t          }\r\n\t          counter++;\r\n\t        }\r\n\t      }\r\n\t    }\r\n\t  },\r\n\t\r\n\t  getOverlappingLabelsIndexes:function(curvalues,curset){\r\n\t    var counter=0, result=[];\r\n\t    for(var i in curset)\r\n\t     for(var j in curset)if(i>j){\r\n\t       if(curvalues[counter]>0){\r\n\t         result.push(i); result.push(j);\r\n\t       }\r\n\t       counter++;\r\n\t     }\r\n\t    return result;\r\n\t  },\r\n\t\r\n\t  /**\r\n\t  swaps position for a random label with another from this label's positions pool\r\n\t  @param {Number} index : index of label in all_items to select new random position from availavle choices.\r\n\t  @param {Array} curset: currently selected label postions\r\n\t  @param {Array} all_items: all available postions\r\n\t  @memberof MapAutoLabelSupport#\r\n\t  */\r\n\t  swapCandidateInLabelSetToNew:function(idx,curset,all_items){\r\n\t    var label_index = curset[idx].all_items_index();\r\n\t    var new_candidate = candidateGenerator.computeLabelCandidate(label_index,all_items);\r\n\t    curset[idx]=new_candidate;\r\n\t  },\r\n\t\r\n\t  applyNewPositionsForLabelsInArray:function(idx_array,curset,all_items){\r\n\t    for(var i in idx_array)this.swapCandidateInLabelSetToNew(idx_array[i],curset,all_items);\r\n\t  },\r\n\t\r\n\t  /**\r\n\t  calculates total overlapping area with knowlesge of previous value and what label was moved, affects curvalues\r\n\t  @param {Array} curvalue: array of float computed at previous step or initital step, consist of elements of lower-triangluar matrix (i,j) of values of overlapping areas for (i,j) els of curset\r\n\t  @param {Array} curset: current set of label with positions\r\n\t  @param {Number} changedLabelIndex: an index of label which position we changed\r\n\t  */\r\n\t  evaluateAfterSeveralChanged:function(curvalues,curset,changedLabels) {\r\n\t    var counter=0; //index to iterate through curvalue array\r\n\t    while(changedLabels.length>0){\r\n\t      var changedLabelIndex=changedLabels.pop();\r\n\t      for(var i=0;i<curset.length;i++){\r\n\t        for(var j=0;j<curset.length;j++){if(i>j){ //i,j like we used them in the evaluateCurSet function, so we get similar counter values\r\n\t          if(i===changedLabelIndex||j===changedLabelIndex){ //here we obtain all indexes of curvales array corresponding to changedLabelIndex\r\n\t            var area=this.checkOverLappingArea(curset[i].poly(),curset[j].poly(),this.options.minimizeTotalOverlappingArea); //and recalculate areas\r\n\t            curvalues[counter]=area;\r\n\t            }\r\n\t            counter++;\r\n\t          }\r\n\t        }\r\n\t      }\r\n\t    }\r\n\t    curvalues.pop(); //remove prev sum\r\n\t    this.assignCostFunctionValuesToLastEl(curvalues);\r\n\t  },\r\n\t\r\n\t  dodebug:function(message){\r\n\t    if(this.options.debug)console.log(message);\r\n\t  },\r\n\t\r\n\t  processOptions:function(options){\r\n\t    this.options=options || {};\r\n\t    this.options.t0 = this.options.t0 || 2.5;\r\n\t    this.options.decrease_value = this.options.decrease_value || 0.9; //decrease by ten percent each decrease step\r\n\t    this.options.tmin = this.options.tmin || 0.0;\r\n\t    this.options.constant_temp_repositionings = this.options.constant_temp_repositionings || 10;\r\n\t    this.options.max_improvments_count = this.options.max_improvments_count || 10;\r\n\t    this.options.max_noimprove_count = this.options.max_noimprove_count || 20;\r\n\t    this.options.maxsteps = this.options.maxsteps || 100;\r\n\t    this.options.maxtotaliterations = this.options.maxtotaliterations || 100000;\r\n\t    this.options.minimizeTotalOverlappingArea=this.options.minimizeTotalOverlappingArea || false;\r\n\t    this.options.debug=this.options.debug || true;\r\n\t    this.options.allowBothSidesOfLine=this.options.allowBothSidesOfLine || true;\r\n\t    candidateGenerator.options.lineDiscreteStepPx = this.options.lineDiscreteStepPx || candidateGenerator.options.lineDiscreteStepPx; //pixels\r\n\t  },\r\n\t\r\n\t  /**\r\n\t  find optimal label placement based on simulated annealing approach, relies on paper https://www.eecs.harvard.edu/shieber/Biblio/Papers/jc.label.pdf\r\n\t  @param {Array} all_items: an arr with labels and their available line segments to place\r\n\t  @param {Object} options: TODO [simulatedAnnealing] add options description\r\n\t  @param {Object} callback: a function to gather results and use them to render\r\n\t  @param {Object} context: a parent conext of the function  above (arguments.callee - but deprecated)\r\n\t  */\r\n\t  perform:function(all_items,options,callback,context) {\r\n\t        if(all_items.length<1){callback([])} //do nothing if no segments\r\n\t        else{\r\n\t          var t0 = performance.now();\r\n\t          this.processOptions(options);\r\n\t          //init\r\n\t          var curset=this.getInitialRandomState(all_items), //current label postions\r\n\t           curvalues = this.evaluateCurSet(curset), //current overlaping matrix (conflict graph)\r\n\t           t=this.options.t0, stepcount=0, doexit=curvalues[curvalues.length-1] === 0,//if no overlaping at init state, do nothing and return curretn state\r\n\t           iterations=0, This=this;\r\n\t\r\n\t          var doReturn = function(){\r\n\t              This.dodebug('overlapping labels count = '+curvalues.pop()+', total labels count = '+curset.length+', iterations = '+iterations);\r\n\t              This.dodebug('time to annealing = '+(performance.now()-t0));\r\n\t              This.markOveralppedLabels(curset,curvalues);\r\n\t              callback.call(context,curset);\r\n\t            }\r\n\t          }\r\n\t\r\n\t          //step\r\n\t          while(true){\r\n\t            //while(t>options.tmin && stepcount<options.maxsteps && !doexit\r\n\t            if(t<=this.options.tmin || stepcount>=this.options.maxsteps){\r\n\t              doReturn();\r\n\t              return;\r\n\t            }\r\n\t            stepcount++;\r\n\t            var improvements_count=0, no_improve_count=0;\r\n\t            for(var i=0;i<this.options.constant_temp_repositionings*curset.length;i++){ //while constant temperature, do some replacments\r\n\t              var oldvalues = curvalues.slice(0), //clone curvalues in order to return to ld ones\r\n\t                  oldset = curset.slice(0),\r\n\t                  overlapped_indexes = this.getOverlappingLabelsIndexes(curvalues,curset);\r\n\t              this.applyNewPositionsForLabelsInArray(overlapped_indexes,curset,all_items);\r\n\t              this.evaluateAfterSeveralChanged(curvalues,curset,overlapped_indexes);\r\n\t              iterations++;\r\n\t              if(curvalues[curvalues.length-1] === 0){ //no overlaps already\r\n\t                This.dodebug('strict solution');\r\n\t                doReturn();\r\n\t                return;\r\n\t              }\r\n\t              if(iterations>this.options.maxtotaliterations){ //not to hang too long\r\n\t                doReturn();\r\n\t                return;\r\n\t              }\r\n\t              var delta = (oldvalues[oldvalues.length-1]-curvalues[curvalues.length-1]);\r\n\t              if(delta<0){//ie, new labeling is worse!\r\n\t                var P=1 - Math.exp(delta/t);\r\n\t                if(P>Math.random()){ //undo label reposition with probability of P\r\n\t                  curvalues = oldvalues;\r\n\t                  curset=oldset;\r\n\t                  no_improve_count++;\r\n\t                }else { //approve new repositioning\r\n\t                  improvements_count++;\r\n\t                  no_improve_count=0;\r\n\t                }\r\n\t              }else{\r\n\t                 improvements_count++;\r\n\t                 no_improve_count=0;\r\n\t               }\r\n\t              if(no_improve_count>=this.options.max_noimprove_count*curset.length){ //it is already optimal\r\n\t                This.dodebug('stable state, finish on it');\r\n\t                doReturn();\r\n\t                return;\r\n\t              }\r\n\t              if(improvements_count>=this.options.max_improvments_count*curset.length){\r\n\t                break; //of for\r\n\t              }\r\n\t            }\r\n\t            //decrease t\r\n\t            t*=this.options.decrease_value;\r\n\t          };\r\n\t      }\r\n\t  }\r\n\t\r\n\t\r\n\tmodule.exports = simulatedAnnealing;\r\n\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar geomEssentials = __webpack_require__(3);\r\n\tvar itemFactory = __webpack_require__(11);\r\n\t\r\n\tvar candidateGenerator = {\r\n\t  options:{\r\n\t    lineDiscreteStepPx:3\r\n\t  },\r\n\t\r\n\t  obtainCandidateForPoint:function(point){\r\n\t    //TODO[obtainCandidateForPoint]\r\n\t  },\r\n\t\r\n\t  obtainCandidateForPoly:function(polygon){\r\n\t    //TODO[obtainCandidateForPoly]\r\n\t  },\r\n\t\r\n\t  /**\r\n\t  Get a poly (simple with no text along path)for random offset on the polyline\r\n\t  @param {Object} item: item from prepareCurSegments's allsegs\r\n\t  @returns {Array} : a poly bounding text, placed on corresponding point for offset on poluline and rotated to match segment's skew\r\n\t  */\r\n\t  obtainCandidateForPolyLineByRandomStartOffset:function(item){\r\n\t    var random_offset = item.totalLength*Math.random();\r\n\t    var candidate = itemFactory.candidatePosition(random_offset,item);\r\n\t    return candidate;\r\n\t  },\r\n\t\r\n\t  /**\r\n\t  computes label candidate object to place on map\r\n\t  @param {Number} i: an index in all_items array to obtain label candidate for i-item\r\n\t  @returns {candidatePosition} : generated candidate\r\n\t  */\r\n\t  computeLabelCandidate:function(i,all_items) {\r\n\t    var candidate;\r\n\t    switch (all_items[i].layer_type()) {\r\n\t      case 0:\r\n\t        break;\r\n\t      case 1:{\r\n\t          candidate=this.obtainCandidateForPolyLineByRandomStartOffset(all_items[i]);\r\n\t          break;\r\n\t        }\r\n\t      case 2:\r\n\t        break;\r\n\t    }\r\n\t    return candidate;\r\n\t  },\r\n\t}\r\n\t\r\n\tmodule.exports = candidateGenerator;\r\n\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*\r\n\tmodlue to create labelItems convenient for labelling and calculation\r\n\t*/\r\n\t\r\n\tvar geomEssentials = __webpack_require__(3);\r\n\t\r\n\tmodule.exports = {\r\n\t  /**\r\n\t  a factory function for label items\r\n\t  @param {TextNode} txNode: SVG TextNode\r\n\t  @param {L.Point} txSize: size of bounding box for txNode\r\n\t  @param {L.Layer} layer: a feature (Marker, Polyline, Path) to aquire data\r\n\t  */\r\n\t  labelItem:function(txNode,txSize,layer,hostArray){\r\n\t    var basic_item= {\r\n\t      data:[],\r\n\t      txNode:txNode,\r\n\t      txSize:txSize,\r\n\t      layer:layer,\r\n\t      host:hostArray,\r\n\t      index:function(){\r\n\t        return this.host.lastIndexOf(this);\r\n\t      },\r\n\t      readData:function(){return false}, //a method stub\r\n\t      layer_type:function(){\r\n\t        //TOFIX for polygon\r\n\t        if(!this._layer_type)this._layer_type = (this.layer._parts.length>0)?1:0;\r\n\t        return this._layer_type;\r\n\t      }\r\n\t    };\r\n\t\r\n\t    if(basic_item.layer_type()==0){\r\n\t      return;\r\n\t      basic_item.readData = function(){\r\n\t        if(basic_item.layer.getLatLngs())\r\n\t        basic_item.data=basic_item.layer._map.latLngToLayerPoint(basic_item.layer.getLatLngs()[0]); //so we adding only L.Point obj\r\n\t      }\r\n\t    }else{\r\n\t      //this give possibility to read all parts to separate items\r\n\t      basic_item.readData=function(partIndex){ //to read consequently\r\n\t        if(!partIndex){var partIndex=0;};\r\n\t        this.data = this.layer._parts[partIndex];\r\n\t        this.partIndex=partIndex; //store this to have ability to compute totalOffset, for example\r\n\t        var nextPart=++partIndex;\r\n\t        if(nextPart<this.layer._parts.length)return nextPart;else return false;\r\n\t      }\r\n\t    }\r\n\t\r\n\t    if(basic_item.layer_type()==1){\r\n\t      if(basic_item.layer._parts.length==0)return;\r\n\t      basic_item.computed_lengths=[];\r\n\t      basic_item.totalLength=0;\r\n\t\r\n\t      basic_item.segCount = function(){return this.data.length -1};\r\n\t\r\n\t      /**\r\n\t      Get a segment from polyline part by it's offset\r\n\t      @param {Number} offset: na offset for the polyline\r\n\t      @returns {Array} : index of start point of segment and dist which is offset from start of the line to the end of found segment\r\n\t      */\r\n\t      basic_item.getSegmentIdxAndDistByOffset=function(offset){\r\n\t        return geomEssentials.getSegmentIdxAndDistByOffset(offset,this.data,this.computed_lengths);\r\n\t      }\r\n\t\r\n\t      /**\r\n\t      get a random element from segments array of the item, assuming it is sorted lengths ascending order\r\n\t      probability is higher for longer segment\r\n\t      */\r\n\t      basic_item.getIndexBasedOnTotalLengthRandom=function(){\r\n\t        return geomEssentials.getIndexBasedOnTotalLengthRandom(this.data,this.computed_lengths,this.totalLength);\r\n\t      }\r\n\t    }\r\n\t    return basic_item;\r\n\t  },\r\n\t\r\n\t  candidatePosition:function(offset_or_origin,item){\r\n\t    return {\r\n\t      _item:item,\r\n\t      offset_or_origin:offset_or_origin,\r\n\t      _poly:false,\r\n\t      all_items_index:function(){\r\n\t        return this._item.index();\r\n\t      },\r\n\t\r\n\t      /**\r\n\t      Used for calculationg overlaps for text along path (textPath SVG).\r\n\t      @param {Number} start_offset: global offset for this polyline (item), same as used in rendering\r\n\t      @param {LabelItem} item:\r\n\t      @returns {Array} : a poly bounding curved text\r\n\t      */\r\n\t      _computePolyForLine:function(start_offset,item){\r\n\t        var final_offset = start_offset + item.txSize.x;\r\n\t        var end_offset=(final_offset<item.totalLength)?final_offset:item.totalLength;\r\n\t        var subPolyline = geomEssentials.extractSubPolylineByOffsetValues(start_offset,end_offset,item.data,item.computed_lengths);\r\n\t        return geomEssentials.computeLineBoundaryPolygon(subPolyline,item.txSize.y);\r\n\t      },\r\n\t\r\n\t      /**\r\n\t      common function switch for computing poly for different layer_types\r\n\t      */\r\n\t      _computePoly:function(){\r\n\t        switch(item.layer_type()){\r\n\t          case 0:break;\r\n\t          case 1:{\r\n\t              this._poly = this._computePolyForLine(this.offset_or_origin,this._item);\r\n\t            }\r\n\t          case 2:break;\r\n\t        }\r\n\t      },\r\n\t\r\n\t      poly:function(){\r\n\t        if(!this._poly)this._computePoly();\r\n\t        return this._poly;\r\n\t      }\r\n\t    }\r\n\t  },\r\n\t\r\n\t}\r\n\n\n/***/ },\n/* 12 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\r\n\tModule to extract sufficient info to label data on the map\r\n\t*/\r\n\t\r\n\t\"use strict\";\r\n\t\r\n\tvar DOMEssentials = __webpack_require__(2);\r\n\tvar geomEssentials = __webpack_require__(3);\r\n\tvar itemFactory = __webpack_require__(11);\r\n\t\r\n\tvar dataReader = {\r\n\t  /**\r\n\t  creates an array of features's segments for each feature  of layers2label's layers on screen along with SVG text corresponding to\r\n\t  @returns [Array] returns an array with values : {t:{content_node:SVG textnode},parts:feature parts,layertype}, then, in next funcs we add apoly param to t object, ir, its bounding polygon, layertype = 0 marker, 1 polyline, 2 polygon\r\n\t  */\r\n\t  readDataToLabel:function(){\r\n\t    var pt  =[];\r\n\t    if(this._map){\r\n\t      for(var i in this._map.autoLabeler._layers2label)\r\n\t      if(this._map.getZoom()>this._map.autoLabeler._layers2label[i]._al_options.zoomToStartLabel)\r\n\t      {\r\n\t        var lg=this._map.autoLabeler._layers2label[i],\r\n\t            map_to_add = this._map;\r\n\t        lg.eachLayer(function(layer){\r\n\t          if(layer.feature)\r\n\t          if(layer.feature.properties[lg._al_options.propertyName]){\r\n\t            var node = DOMEssentials.createSVGTextNode(layer.feature.properties[lg._al_options.propertyName],lg._al_options.labelStyle),\r\n\t                size = DOMEssentials.getBoundingBox(map_to_add,node); //compute ortho aligned bbox for this text, only once, common for all cases\r\n\t            var firstItem = itemFactory.labelItem(node,size,layer,pt)\r\n\t            if(firstItem){\r\n\t              var nextPartIndex=firstItem.readData();\r\n\t              pt.push(firstItem);\r\n\t              while(nextPartIndex){\r\n\t                var item = itemFactory.labelItem(node,size,layer,pt); //create node template\r\n\t                nextPartIndex=item.readData(nextPartIndex);\r\n\t                pt.push(item);\r\n\t              }\r\n\t            }\r\n\t          }\r\n\t        });\r\n\t      }\r\n\t    }\r\n\t    return pt;\r\n\t  },\r\n\t\r\n\t  /**\r\n\t  extracts good segments from available polyline parts and converts to use in next procedures of pos estimation\r\n\t  @param {Array} all_items:\r\n\t  @param {Set} options: options are:  {integer} maxlabelcount: if more labels in all_items, then do nothing\r\n\t  */\r\n\t  prepareCurSegments:function(all_items,options){\r\n\t    options = options || {};\r\n\t    options.maxlabelcount=options.maxlabelcount || 100;\r\n\t    if(all_items.length>options.maxlabelcount || all_items.length==0){\r\n\t      this._map.autoLabeler._dodebug('too much OR no labels to compute('+all_items.length+')');\r\n\t      return false;\r\n\t    }\r\n\t    for(var i=0;i<all_items.length;i++){\r\n\t      var item = all_items[i];\r\n\t      if(item.layer_type()==0){//if point -> do nothing.\r\n\t        continue;\r\n\t      }\r\n\t      //else compute for lines and polygons, now it is only fo lines\r\n\t      if(item.layer_type()==1){\r\n\t        this._applyLineFeatureData(item); //in case where two or move separate polylines generated for original polyline while rendering (imagine big W cutted by screen iwndow)\r\n\t      }\r\n\t    }\r\n\t    return true;\r\n\t  },\r\n\t\r\n\t  /**\r\n\t  Calculates total length for this polyline on screen, and lengths of each segments with their angles\r\n\t  @param {labelItem} item: an item to get above data to\r\n\t  */\r\n\t  _applyLineFeatureData:function(item){ //calculate some data once to increase performance\r\n\t      item.totalLength=0;\r\n\t      item.computed_lengths = geomEssentials.computeSegmentsLengths(item.data);\r\n\t      for(var k=0;k<item.computed_lengths.length;k++){\r\n\t        item.totalLength+=item.computed_lengths[k];\r\n\t      }\r\n\t  }\r\n\t}\r\n\t\r\n\tmodule.exports = dataReader;\r\n\n\n/***/ }\n/******/ ]);\n\n\n/** WEBPACK FOOTER **\n ** l.autolabelSA.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"./\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 7cd8de0c16c34ab5b6ad\n **/","(function () {\r\n  \"use strict\";\r\n\r\n  var autoLabeler = require('./autoLabeler.js');\r\n\r\n  var __onRemove = L.LayerGroup.prototype.onRemove;\r\n  //to include in LabelGroup\r\n  var AutoLabelingSupport = {\r\n      /**\r\n      handle removing layer from the map\r\n      */\r\n      onRemove: function (map) {\r\n      this.disableAutoLabel();\r\n        __onRemove.call(this, map);\r\n    },\r\n\r\n\r\n    /**\r\n     enable autolabeling for this layerGroup, additionally set the current_map variable if it is undefined and hooks label painting on moveend /zoomend events\r\n     it adds this layerGroup to the _layers2label array, so _doAutoLabel function will know about this layerGroup\r\n     @param {Object} options: labelStyle - css string to describe labels look, for now one for all layers in group, propertyName - a property from layer.feature.properties which we label on map\r\n    */\r\n    enableAutoLabel:function(options){\r\n      if(!this._map)return;\r\n      if(!this._map.autoLabeler)return;\r\n      this._al_options = options || {};\r\n      this._al_options.labelStyle = options.labelStyle || \"fill: lime; stroke: #000000;  font-size: 20px;\"; //TODO [enableAutoLabel] add ability to set unique style for each feature\r\n      this._al_options.propertyName = options.propertyName || \"name\";\r\n      this._al_options.priority = options.priority || 0; //highest\r\n      this._al_options.zoomToStartLabel = options.zoomToStartLabel || this._map.autoLabeler.options.zoomToStartLabel;\r\n      this._map.autoLabeler.addLayer(this);\r\n    },\r\n\r\n    /**\r\n    Obtain autlabelling state for this layerGroup\r\n    @returns {Boolean}\r\n    */\r\n    autoLabelEnabled:function(){\r\n      if(!this._map.autoLabeler)return false;\r\n      return this._map.autoLabeler.hasLayer(this);\r\n    },\r\n\r\n    /**\r\n    disable autolabelling\r\n    */\r\n    disableAutoLabel:function(){\r\n      if(!this._map.autoLabeler){\r\n        delete this._al_options;\r\n        return;\r\n      }\r\n      if(this._map.autoLabeler.remLayer(this)){\r\n        delete this._al_options;\r\n      }\r\n    }\r\n  }\r\n\r\n  L.LayerGroup.include(AutoLabelingSupport);\r\n\r\n  L.Map.addInitHook(function () {\r\n          this.whenReady(function () {\r\n              if (this.options.autolabel) {\r\n                this.autoLabeler = L.autoLabeler(this,this.options.autolabelOptions)\r\n              }\r\n          });\r\n      });\r\n\r\n})();\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/MapPart.js\n ** module id = 0\n ** module chunks = 0\n **/","var DOMEssentials = require('./DOMEssentials.js');\r\nvar geomEssentials = require('./geomEssentials.js');\r\nvar simulatedAnnealing = require('./simulatedAnnealing.js');\r\nvar dataReader = require('./DataReader.js');\r\n\r\nL.AutoLabeler = L.Evented.extend(\r\n {\r\n    _nodes:[], //an array for storing SVG node to draw while autolabelling\r\n    _layers2label:[], //an array to know which layergroups are to label\r\n    options:{\r\n      showBBoxes:false, //display bounding boxes around texts\r\n      debug:true,//show debug info in hte cons\r\n      labelsDelay:1000,//a time after update event of renderer when labelling should start, if zero - errors while zooming\r\n      checkLabelsInside:true,//re-clip all segments to entirely fit map window without padding, disabling increases performance, but some labels maybe invisible due to padding of renderer\r\n      zoomToStartLabel:13,//if map zoom lev is below this, do not show labels\r\n      minimizeTotalOverlappingArea:false, //if true, minimize not the count of overlapping labels, but instead their total overlapping area\r\n      deleteIfNoSolution:false,//TODO [setAutoLabelOptions] if no solution can be achieivd, delete some of the labels, which are overlapping, based on their layer al_options.priority or random if equal\r\n      doNotShowIfSegIsTooSmall:false, //TODO [setAutoLabelOptions] if segment length is less then textlength of text, do not show this text\r\n      annealingOptions:{}\r\n    }, //autolabel options\r\n\r\n    _autoLabel:false, //to determine if autolabelling is set for this map\r\n\r\n    initialize: function (map, options) {\r\n      L.setOptions(this, options);\r\n      this._map=map;\r\n    },\r\n\r\n    hasLayer:function(layer){\r\n      return this._layers2label.indexOf(layer)!=-1;\r\n    },\r\n\r\n    addLayer:function(layer){\r\n      if(!this.hasLayer(layer))this._layers2label.push(layer);\r\n    },\r\n\r\n    remLayer:function(layer){\r\n      var ind=this._layers2label.indexOf(layer);\r\n      if(ind>=0){\r\n        this._layers2label.splice(ind,1);\r\n      }\r\n      return ind>=0;\r\n    },\r\n\r\n    /**\r\n    toggles autolabeling\r\n    */\r\n    toggleAutoLabelling:function(){ //this not tested yet\r\n      if(this._autoLabel)this.disableAutoLabel();else this.enableAutoLabel();\r\n    },\r\n\r\n    /**\r\n    enable autolabeling\r\n    */\r\n    enableAutoLabel:function(){\r\n      if(!this._map){\r\n        this._dodebug('no map attached');\r\n        return;\r\n      }\r\n      if(!this._map.options.renderer){\r\n        this._dodebug('renderer is invalid');\r\n        return;\r\n      }\r\n      this._map.options.renderer.on(\"update\",this._apply_doAutoLabel);\r\n      this._map.on(\"zoomstart\",function(){this._zoomstarttrig=1});\r\n      this._map.on(\"zoomend\",function(){this._zoomstarttrig=0});\r\n      this._autoLabel = true;\r\n    },\r\n\r\n    //to check if zoomstart event is fired to prevent autolabeling BEFORE zoomend\r\n    _zoomstarttrig:0,\r\n\r\n    //id of timeout after which AutoLabeling should be done each time - used to stop timer in case of changed map state BEFORE autolabelling was performed\r\n    _ctimerID:-1,\r\n\r\n    /**\r\n    disable autolabeling for this map\r\n    */\r\n    disableAutoLabel:function(){\r\n      this._map.options.renderer.off(\"update\",this._apply_doAutoLabel);\r\n      this._autoLabel=false;\r\n    },\r\n\r\n    /*\r\n    beacuse we using update event of renderer, here we switching to map context and handling two-time update event of SVG renderer\r\n    */\r\n    _apply_doAutoLabel:function(){\r\n      if(this._map.autoLabeler._ctimerID!=-1)clearTimeout(this._map.autoLabeler._ctimerID);\r\n      if(this._map.autoLabeler._zoomstarttrig==0){\r\n        var al = this._map.autoLabeler;\r\n        var lDelay = this._map.autoLabeler.options.labelsDelay;\r\n        this._map.autoLabeler._ctimerID=setTimeout(function(){al._doAutoLabel()},lDelay);\r\n      }\r\n      this._map.autoLabeler._clearNodes();\r\n    },\r\n\r\n    _dodebug:function(message){\r\n      if(this.options.debug)console.log(message);\r\n    },\r\n\r\n    /**\r\n    this function obtains visible polyline segments from screen and computes optimal positions and draws labels on map\r\n    */\r\n    _doAutoLabel:function() {\r\n      if(!this._autoLabel)return; //nothing to do here\r\n      if(this._map.getZoom()>this.options.zoomToStartLabel){\r\n        dataReader._map=this._map;\r\n        var all_items  =dataReader.readDataToLabel(this._map) //array for storing paths and values\r\n        dataReader.prepareCurSegments(all_items,{maxlabelcount:80});\r\n        if(all_items.length==0){\r\n          this._clearNodes();\r\n          return;\r\n        }\r\n        var curset = simulatedAnnealing.getInitialRandomState(all_items);\r\n        this._renderNodes(curset);\r\n        //simulatedAnnealing.perform(all_items,this.options.annealingOptions,this._renderNodes,this);\r\n      }else{\r\n        this._clearNodes();\r\n      }\r\n    },\r\n\r\n    /**\r\n    for test purposes now, creates a polygon node useing poly Array of points\r\n    */\r\n    _createPolygonNode:function(poly,highlited){\r\n      var node = L.SVG.create('polygon');\r\n      var points='';\r\n      for(var i=0;i<poly.length;i++){\r\n        points+=poly[i].x+','+poly[i].y+' ';\r\n      }\r\n      node.setAttribute('points', points.trim());\r\n      if(highlited){\r\n        node.setAttribute('style','fill: red; fill-opacity:0.3; stroke: black;');\r\n      }\r\n      else node.setAttribute('style','fill: yellow; fill-opacity:0.1; stroke: black;');\r\n      return node;\r\n    },\r\n\r\n    /**\r\n    clears label on the screen\r\n    */\r\n    _clearNodes:function() {\r\n    var svg = this._map.options.renderer._container;  //to work with SVG\r\n      for(var i=0;i<this._nodes.length;i++){//clear _nodes on screen\r\n        svg.removeChild(this._nodes[i]);\r\n      }\r\n      this._nodes=[];\r\n      // this._dodebug(\"Cleared nodes\");\r\n    },\r\n\r\n    /**\r\n    renders computed labelset on the screen via svg\r\n    TODO [_renderNodes] place textOnPath\r\n    */\r\n    _renderNodes:function(labelset){\r\n      var svg =  this._map.options.renderer._container;  //to work with SVG\r\n      this._clearNodes(); //clearscreen\r\n      for(var m in labelset){\r\n        // var node = labelset[m].t.content_node;\r\n        // var x = labelset[m].pos.x;\r\n        // var y = labelset[m].pos.y;\r\n        // node.setAttribute('x', x);\r\n        // node.setAttribute('y', y);\r\n        // var transform ='rotate('+ Math.floor(labelset[m].a)+','+Math.floor(x)+','+Math.floor(y)+')';\r\n        // transform = transform.replace(/ /g, '\\u00A0');\r\n        // node.setAttribute('transform',transform);\r\n        // svg.appendChild(node);\r\n        // this._nodes.push(node);//add this labl to _nodes array, so we can erase it from the screen later\r\n        if(this.options.showBBoxes){\r\n          //here for testing purposes\r\n          var polynode = this._createPolygonNode(labelset[m].poly(),labelset[m].overlaps);\r\n          svg.appendChild(polynode);\r\n          this._nodes.push(polynode); //add this polygon to _nodes array, so we can erase it from the screen later\r\n        }\r\n      }\r\n    }\r\n  }\r\n)\r\n\r\nL.autoLabeler = function(map,options){\r\n  return new L.AutoLabeler(map,options);\r\n}\r\n\r\n// module.exports = autoLabeler;\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/autoLabeler.js\n ** module id = 1\n ** module chunks = 0\n **/","//a class to compute pixel dimensions of texts\r\n/** @namespace DOMEssentials*/\r\n'use strict';\r\nvar geomEssentials = require(\"./geomEssentials.js\");\r\n\r\nmodule.exports = {\r\n  /**\r\n  converts TextRectangle object to clockwise array of 2d-arrays, representing rectangular poly\r\n  @param {TextRectangle} rect: a bbox for text\r\n  @returns {Array}\r\n  @memberof DOMEssentials#\r\n  */\r\n  convertClientRectToArrayOfArrays:function(rect) {\r\n    var res=[];\r\n    var height_correction=rect.height*0.2; //beacuse getBoundingClientRect give a bit false height info\r\n    res.push([0,0]);\r\n    res.push([0,-rect.height]);\r\n    res.push([rect.width,-rect.height]);\r\n    res.push([rect.width,0]);\r\n    res=geomEssentials.movePolyByAdding(res,[0,height_correction]);\r\n    return res;\r\n  },\r\n\r\n  /**\r\n  returns a bounding box for horizontal text with style as in t.content_node\r\n  @param {Object} map: current map\r\n  @param {Object} node: textNode\r\n  @returns {L.Point} : a bbox for node, as width and height\r\n  @memberof DOMEssentials#\r\n  */\r\n  getBoundingBox:function(map,node){\r\n    var svg = map.options.renderer._container;\r\n    svg.appendChild(node);\r\n    var rect = node.getBoundingClientRect();\r\n    svg.removeChild(node);\r\n    return L.point(rect.width,rect.height);\r\n  },\r\n\r\n  /**\r\n  creates SVG text node with specified style and handles some formatting issues\r\n  @param {String} text: text for node\r\n  @param {String} textstyle: CSS style String\r\n  @returns {TextNode} : SVG node\r\n  */\r\n  createSVGTextNode:function(text,textstyle){\r\n    text = text.replace(/ /g, '\\u00A0');  // Non breakable spaces\r\n    var node =L.SVG.create('text');\r\n    node.setAttribute('style',textstyle);\r\n    node.textContent = text;\r\n    return node;\r\n  }\r\n}\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/DOMEssentials.js\n ** module id = 2\n ** module chunks = 0\n **/","//a class to perfrom geometric stuff\r\n/** @namespace geomEssentials*/\r\n'use strict';\r\n\r\nvar greinerHormann = require('./third_party/GreinerHormann');\r\n\r\nvar geomEssentials = {\r\n\r\n  /**\r\n  @param {Array} polyline: consists of L.Point\r\n  @returns {Array}: number array with length=polyline.length-1 with length of segs\r\n  */\r\n  computeSegmentsLengths:function(polyline){\r\n    var result=[];\r\n    for(var k=1;k<polyline.length;k++){\r\n      result.push(polyline[k].distanceTo(polyline[k-1]));\r\n    }\r\n    return result;\r\n  },\r\n\r\n  /**\r\n  translates segment to new loc by adding point to its vertices\r\n  @param {L.Point} a:\r\n  @param {L.Point} b:\r\n  @param {L.Point} point:\r\n  @returns {Array}:\r\n  */\r\n  translateSegment:function(a,b, point){\r\n    var result=[];\r\n    result.push(a.add(point)); result.push(b.add(point));\r\n    return result;\r\n  },\r\n\r\n  /**\r\n  code from L.GeometryUtil plugin\r\n       Returns slope (Ax+B) between two points.\r\n        @param {L.Point} a\r\n        @param {L.Point} b\r\n        @returns {Object} with ``a`` and ``b`` properties.\r\n     */\r\n  computeSlope: function(a, b) {\r\n      var s = (b.y - a.y) / (b.x - a.x),\r\n          o = a.y - (s * a.x);\r\n      return L.point(s,o);\r\n  },\r\n\r\n  /**\r\n  computes a point where two lines intersection\r\n  @param {L.Point} a: a first point of first line defined by two points\r\n  @param {L.Point} b: a second point of first line defined by two points\r\n  @param {L.Point} c: a first point of second line defined by two points\r\n  @param {L.Point} d: a first point of second line defined by two points\r\n  @returns {L.Point} :intersection point or null if lines are parallel to each other\r\n  */\r\n  lineIntersection:function(a,b,c,d){\r\n    var slope1=this.computeSlope(a,b), slope2=this.computeSlope(c,d);\r\n    if(slope1.x===slope2.x)return;\r\n    var x = (slope2.y - slope1.y) / (slope1.x - slope2.x);\r\n    var y = slope1.x*x + slope1.y;\r\n    return L.point(x,y);\r\n  },\r\n\r\n  /**\r\n    computes a  unit normal for [a,b] segment\r\n    @param {L.Point} a:\r\n    @param {L.Point} b:\r\n    @returns {L.point}: unit normal\r\n  */\r\n  getNormalOnSegment:function(a,b){\r\n    var slope = this.computeSlope(a,b);\r\n    return this.normalizePt(slope);\r\n  },\r\n\r\n  /**\r\n  Computes an euclidian length of point\r\n  @param {L.Point} pt:\r\n  @returns {Number}\r\n  */\r\n  get2dVectorLength:function(pt){\r\n    return Math.sqrt(pt.x*pt.x + pt.y*pt.y);\r\n  },\r\n\r\n  /**\r\n  Makes this point a unit-lengthed\r\n  @param {L.Point} pt:\r\n  @returns {L.Point}:\r\n  */\r\n  normalizePt:function(pt){\r\n    return (pt.x===0&&pt.y===0)?0:pt.divideBy(this.get2dVectorLength(pt));\r\n  },\r\n\r\n  /**\r\n  copies segment and translates copy in normal direction by height value (may be negative)\r\n  It also extands or shrinks new segments to make sure they are connected to each and other\r\n  @param {Array} polyline: polyline to translate segments of which\r\n  @param {Number} height:  height of normal\r\n  @returns {Array}: translated copy of polyline\r\n  */\r\n  translateByNormals:function(polyline,height){\r\n    var out_polyline=[];\r\n    for(var i=0;i<polyline.length-1;i++){\r\n      var normal = this.getNormalOnSegment(polyline[i],polyline[i+1]).multiplyBy(height);\r\n      var current_segment=this.translateSegment(polyline[i],polyline[i+1],normal);\r\n      //now check if current segment is connected well to previous\r\n      if(i>0){ //so -> it isn't first segment, and out_polyline has at leat two points\r\n        var pt_intersect = this.lineIntersection(out_polyline[out_polyline.length-2],out_polyline[out_polyline.length-1],current_segment[0],current_segment[1]);\r\n        out_polyline[out_polyline.length-1] = pt_intersect;\r\n        out_polyline.push(current_segment[1]);\r\n      }else{\r\n        out_polyline.push(current_segment[0]); out_polyline.push(current_segment[1]);\r\n      }\r\n    }\r\n    return out_polyline;\r\n  },\r\n\r\n  /**\r\n  code from L.GeometryUtil plugin\r\n  @memberof geomEssentials#\r\n  */\r\n  interpolateOnPointSegment: function (a,b, ratio) {\r\n      return L.point(\r\n          (a.x * (1 - ratio)) + (ratio * b.x),\r\n          (a.y * (1 - ratio)) + (ratio * b.y)\r\n      );\r\n  },\r\n\r\n  /**\r\n  Get a segment from polyline part by it's offset\r\n  @param {Number} offset: na offset for the polyline\r\n  @param {Array} polyline: points of the polyline\r\n  @param {Array} computed_lengths: precomputed lengths (if available) for polyline segments\r\n  @returns {Array} : index of start point of segment and dist which is offset from start of the line to the end of found segment\r\n  */\r\n  getSegmentIdxAndDistByOffset:function(offset,polyline,computed_lengths){\r\n    var cdist=0;\r\n    for(var i=0;i<polyline.length-1;i++){\r\n      cdist+=computed_lengths[i];\r\n      if(offset<=cdist){\r\n        return [i,cdist]\r\n      }\r\n    }\r\n  },\r\n\r\n  /**\r\n  based on https://blog.dotzero.ru/weighted-random-simple/\r\n  get a random element from segments array of the item, assuming it is sorted lengths ascending order\r\n  probability is higher for longer segment\r\n  @param {Array} polyline: points of the polyline\r\n  @param {Array} computed_lengths: precomputed lengths (if available) for polyline segments\r\n  @param {NUmber} totalLength: precomputed total length of the polyline\r\n  */\r\n  getIndexBasedOnTotalLengthRandom:function(polyline,computed_lengths,totalLength){\r\n    var random_pos = Math.random()*totalLength; //get a position random for all segments of this polyline visible on the screen\r\n    //obtain and index of segment, to which belongs this position, it is assumed tha segments are sorted by length\r\n    var clen=0;\r\n    for(var i=0;i<polyline.length-1;i++){\r\n      clen+=computed_lengths[i];\r\n      if(clen>random_pos)break;\r\n    }\r\n    return i;\r\n  },\r\n\r\n  /**\r\n  Supplement function for extractSubPolyline\r\n  returns start index, end index in segments array for item, also first cropped seg and last cropped seg.\r\n  If only one seg here, it is crop both ends.\r\n  @param {Number} offset_start: should be less than total length of polyline\r\n  @param {Number} offset_end: should be greater than offset_start\r\n  @param {Array} polyline: points of the polyline\r\n  @param {Array} computed_lengths: precomputed lengths (if available) for polyline segments\r\n  @returns {Object}:\r\n  */\r\n  extractSubPolylineByOffsetValues:function(offset_start,offset_end,polyline,computed_lengths){\r\n    var start = this.getSegmentIdxAndDistByOffset(offset_start,polyline,computed_lengths),\r\n        end = this.getSegmentIdxAndDistByOffset(offset_end,polyline,computed_lengths),\r\n        start_point= this.interpolateOnPointSegment(polyline[start[0]],polyline[start[0]+1],(start[1]-offset_start)/computed_lengths[start[0]]),\r\n        end_point = this.interpolateOnPointSegment(polyline[end[0]],polyline[end[0]+1],(end[1]-offset_end)/computed_lengths[end[0]]),\r\n        result = [start_point];\r\n    for(var i=start[0]+1;i<=end[0];i++){ //push every point from end of start segment to segment prior to last\r\n      result.push(polyline[i]);\r\n    }\r\n    result.push(end_point);\r\n    return result;\r\n  },\r\n\r\n  /**\r\n  Used for calculationg overlaps for text along path (textPath SVG).\r\n  @param {Number} start_offset: global offset for this polyline (item), same as used in rendering\r\n  @param {Number} end_offset: global offset for this polyline (item), same as used in rendering\r\n  @param {LabelItem} item:\r\n  @returns {Array} : a poly bounding with height of item.txSize.y\r\n  */\r\n  computeLineBoundaryPolygon:function(polyline,height){\r\n    var lower_boundary = polyline.slice(0);\r\n    var upper_boundary=this.translateByNormals(polyline,height);\r\n    Array.prototype.push.apply(lower_boundary, upper_boundary.reverse());\r\n    return lower_boundary;\r\n  },\r\n\r\n  clipPoly:function(poly1,poly2){\r\n    var intersection = greinerHormann.intersection(poly1, poly2);\r\n    if(!intersection)return [];\r\n    if(intersection.length>0)return intersection[0];\r\n  },\r\n\r\n  /**\r\n  returns a combined poly from two\r\n  */\r\n  addPoly:function(poly1,poly2){\r\n    var union = greinerHormann.union(poly1, poly2);\r\n    if(!union)return [];\r\n    if(union.length>0)return union[0];\r\n  },\r\n\r\n  subtractPoly:function(poly1,poly2){\r\n    var diff = greinerHormann.diff(poly1, poly2);\r\n    if(!diff)return [];else return diff;\r\n  },\r\n\r\n  /**\r\n  code from http://www.codeproject.com/Articles/13467/A-JavaScript-Implementation-of-the-Surveyor-s-Form\r\n  for single polygon only, and no holes in\r\n  @param {Array} poly: a poly to determine area of\r\n  @memberof geomEssentials#\r\n  */\r\n  polyArea:function(poly) {\r\n    // Calculate the area of a polygon\r\n    // using the data stored\r\n    // in the arrays x and y\r\n    var area = 0.0;\r\n    if(poly){\r\n      var poly=poly.slice(0);\r\n      if(poly.length>2)poly.push(poly[0]); //close the poly\r\n      for(var k = 0; k < poly.length-1; k++ ) {\r\n          var xDiff = poly[k+1][0] - poly[k][0];\r\n          var yDiff = poly[k+1][1] - poly[k][1];\r\n          area += + poly[k][0] * yDiff - poly[k][1] * xDiff;\r\n      }\r\n      area = 0.5 * area;\r\n    }\r\n    return area;\r\n  },\r\n\r\n\r\n  /**\r\n  check if two labels overlab, if no returns false, if yes returns ???area OR polygon??? of averlap\r\n  @param {} poly1:a first polygon to check overlap with second\r\n  @param {} poly2:a second polygon to check overlap with first\r\n  @returns {float}: an area of overlapping, zero if no overlapping\r\n  */\r\n  checkOverLappingArea:function(poly1,poly2,calculateAreaNotOnlyFactOfOverlapping) {\r\n    var clipped = this.clipPoly(poly1,poly2);\r\n    if(calculateAreaNotOnlyFactOfOverlapping){\r\n      var area =this.polyArea(clipped);\r\n      return area;\r\n    };\r\n    if(clipped.length>0)return 1;else return 0; //for performance, skip area calculation\r\n  },\r\n\r\n  /**\r\n  rotates given polygon to a given angle around basepoint\r\n  code partialy from web, don't remember from...\r\n  @param {Array} poly: a polygon to rotate\r\n  @param {Array} basepoint: base point\r\n  @param {float} angle: an angle in degrees\r\n  @returns {Array}: rotated poly\r\n  @memberof geomEssentials#\r\n  */\r\n  rotatePoly:function(poly, basepoint,angle){\r\n    var res=[];\r\n    var angleRad = angle*Math.PI/180;\r\n    for(var i=0;i<poly.length;i++){\r\n      var pPoint = poly[i],\r\n      x_rotated = Math.cos(angleRad)*(pPoint[0]-basepoint[0]) - Math.sin(angleRad)*(pPoint[1]-basepoint[1]) + basepoint[0],\r\n      y_rotated = Math.sin(angleRad)*(pPoint[0]-basepoint[0]) + Math.cos(angleRad)*(pPoint[1]-basepoint[1]) + basepoint[1];\r\n      res.push([x_rotated,y_rotated]);\r\n    }\r\n    return res;\r\n  },\r\n\r\n  /**\r\n  moves a poly by adding pt2add point to all its vertices\r\n  @param {Array} poly: a poly to movePoly\r\n  @param {Array} pt2add: a point to add to all vertices\r\n  @returns {Array}: moved poly\r\n  @memberof geomEssentials#\r\n  */\r\n  movePolyByAdding:function(poly,pt2add) {\r\n    var res=poly.slice(0);\r\n    for(var i=0;i<poly.length;i++){\r\n      res[i][0]+=pt2add[0]; res[i][1]+=pt2add[1];\r\n    }\r\n    return res;\r\n  },\r\n\r\n  /**\r\n  moves a poly by translating all its vertices to moveto, using first vertex as origin\r\n  @param {Array} poly: a poly to movePoly\r\n  @param {Array} moveto: where translate all vertices\r\n  @returns {Array}: moved poly\r\n  @memberof geomEssentials#\r\n  */\r\n  movePolyByMovingTo:function(poly,moveto){\r\n    var res=poly.slice(0);\r\n    moveto[0] = moveto[0]-poly[0][0];\r\n    moveto[1] = moveto[1]-poly[0][1];\r\n    for(var i=1;i<poly.length;i++){\r\n      res[i][0]+=moveto[0]; res[i][1]+=moveto[1];\r\n    }\r\n    return res;\r\n  },\r\n\r\n  createPoly:function(width,height){\r\n    //TODO[createPoly]\r\n  }\r\n\r\n}\r\n\r\nmodule.exports = geomEssentials;\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/geomEssentials.js\n ** module id = 3\n ** module chunks = 0\n **/","var clip = require('./clip');\r\n\r\nmodule.exports = {\r\n    /**\r\n     * @api\r\n     * @param  {Array.<Array.<Number>|Array.<Object>} polygonA\r\n     * @param  {Array.<Array.<Number>|Array.<Object>} polygonB\r\n     * @return {Array.<Array.<Number>>|Array.<Array.<Object>|Null}\r\n     */\r\n    union: function(polygonA, polygonB) {\r\n        return clip(polygonA, polygonB, false, false);\r\n    },\r\n\r\n    /**\r\n     * @api\r\n     * @param  {Array.<Array.<Number>|Array.<Object>} polygonA\r\n     * @param  {Array.<Array.<Number>|Array.<Object>} polygonB\r\n     * @return {Array.<Array.<Number>>|Array.<Array.<Object>>|Null}\r\n     */\r\n    intersection: function(polygonA, polygonB) {\r\n        return clip(polygonA, polygonB, true, true);\r\n    },\r\n\r\n    /**\r\n     * @api\r\n     * @param  {Array.<Array.<Number>|Array.<Object>} polygonA\r\n     * @param  {Array.<Array.<Number>|Array.<Object>} polygonB\r\n     * @return {Array.<Array.<Number>>|Array.<Array.<Object>>|Null}\r\n     */\r\n    diff: function(polygonA, polygonB) {\r\n        return clip(polygonA, polygonB, false, true);\r\n    },\r\n\r\n    clip: clip\r\n};\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/third_party/GreinerHormann/src/greiner-hormann.js\n ** module id = 4\n ** module chunks = 0\n **/","var Polygon = require('./polygon');\r\n\r\n/**\r\n * Clip driver\r\n * @api\r\n * @param  {Array.<Array.<Number>>} polygonA\r\n * @param  {Array.<Array.<Number>>} polygonB\r\n * @param  {Boolean}                sourceForwards\r\n * @param  {Boolean}                clipForwards\r\n * @return {Array.<Array.<Number>>}\r\n */\r\nmodule.exports = function(polygonA, polygonB, eA, eB) {\r\n    var result, source = new Polygon(polygonA),\r\n        clip = new Polygon(polygonB),\r\n        result = source.clip(clip, eA, eB);\r\n\r\n    return result;\r\n};\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/third_party/GreinerHormann/src/clip.js\n ** module id = 5\n ** module chunks = 0\n **/","var Vertex = require('./vertex');\r\nvar Intersection = require('./intersection');\r\n\r\n/**\r\n * Polygon representation\r\n * @param {Array.<Array.<Number>>} p\r\n * @param {Boolean=}               arrayVertices\r\n *\r\n * @constructor\r\n */\r\nvar Polygon = function(p, arrayVertices) {\r\n\r\n    /**\r\n     * @type {Vertex}\r\n     */\r\n    this.first = null;\r\n\r\n    /**\r\n     * @type {Number}\r\n     */\r\n    this.vertices = 0;\r\n\r\n    /**\r\n     * @type {Vertex}\r\n     */\r\n    this._lastUnprocessed = null;\r\n\r\n    /**\r\n     * Whether to handle input and output as [x,y] or {x:x,y:y}\r\n     * @type {Boolean}\r\n     */\r\n    this._arrayVertices = (typeof arrayVertices === \"undefined\") ?\r\n        Array.isArray(p[0]) :\r\n        arrayVertices;\r\n\r\n    for (var i = 0, len = p.length; i < len; i++) {\r\n        this.addVertex(new Vertex(p[i]));\r\n    }\r\n};\r\n\r\n/**\r\n * Add a vertex object to the polygon\r\n * (vertex is added at the 'end' of the list')\r\n *\r\n * @param vertex\r\n */\r\nPolygon.prototype.addVertex = function(vertex) {\r\n    if (this.first == null) {\r\n        this.first = vertex;\r\n        this.first.next = vertex;\r\n        this.first.prev = vertex;\r\n    } else {\r\n        var next = this.first,\r\n            prev = next.prev;\r\n\r\n        next.prev = vertex;\r\n        vertex.next = next;\r\n        vertex.prev = prev;\r\n        prev.next = vertex;\r\n    }\r\n    this.vertices++;\r\n};\r\n\r\n/**\r\n * Inserts a vertex inbetween start and end\r\n *\r\n * @param {Vertex} vertex\r\n * @param {Vertex} start\r\n * @param {Vertex} end\r\n */\r\nPolygon.prototype.insertVertex = function(vertex, start, end) {\r\n    var prev, curr = start;\r\n\r\n    while (!curr.equals(end) && curr._distance < vertex._distance) {\r\n        curr = curr.next;\r\n    }\r\n\r\n    vertex.next = curr;\r\n    prev = curr.prev;\r\n\r\n    vertex.prev = prev;\r\n    prev.next = vertex;\r\n    curr.prev = vertex;\r\n\r\n    this.vertices++;\r\n};\r\n\r\n/**\r\n * Get next non-intersection point\r\n * @param  {Vertex} v\r\n * @return {Vertex}\r\n */\r\nPolygon.prototype.getNext = function(v) {\r\n    var c = v;\r\n    while (c._isIntersection) {\r\n        c = c.next;\r\n    }\r\n    return c;\r\n};\r\n\r\n/**\r\n * Unvisited intersection\r\n * @return {Vertex}\r\n */\r\nPolygon.prototype.getFirstIntersect = function() {\r\n    var v = this._firstIntersect || this.first;\r\n\r\n    do {\r\n        if (v._isIntersection && !v._visited) {\r\n            break;\r\n        }\r\n\r\n        v = v.next;\r\n    } while (!v.equals(this.first));\r\n\r\n    this._firstIntersect = v;\r\n    return v;\r\n};\r\n\r\n/**\r\n * Does the polygon have unvisited vertices\r\n * @return {Boolean} [description]\r\n */\r\nPolygon.prototype.hasUnprocessed = function() {\r\n    var v = this._lastUnprocessed || this.first;\r\n    do {\r\n        if (v._isIntersection && !v._visited) {\r\n            this._lastUnprocessed = v;\r\n            return true;\r\n        }\r\n\r\n        v = v.next;\r\n    } while (!v.equals(this.first));\r\n\r\n    this._lastUnprocessed = null;\r\n    return false;\r\n};\r\n\r\n/**\r\n * The output depends on what you put in, arrays or objects\r\n * @return {Array.<Array<Number>|Array.<Object>}\r\n */\r\nPolygon.prototype.getPoints = function() {\r\n    var points = [],\r\n        v = this.first;\r\n\r\n    if (this._arrayVertices) {\r\n        do {\r\n            points.push([v.x, v.y]);\r\n            v = v.next;\r\n        } while (v !== this.first);\r\n    } else {\r\n        do {\r\n            points.push({\r\n                x: v.x,\r\n                y: v.y\r\n            });\r\n            v = v.next;\r\n        } while (v !== this.first);\r\n    }\r\n\r\n    return points;\r\n};\r\n\r\n/**\r\n * Clip polygon against another one.\r\n * Result depends on algorithm direction:\r\n *\r\n * Intersection: forwards forwards\r\n * Union:        backwars backwards\r\n * Diff:         backwards forwards\r\n *\r\n * @param {Polygon} clip\r\n * @param {Boolean} sourceForwards\r\n * @param {Boolean} clipForwards\r\n */\r\nPolygon.prototype.clip = function(clip, sourceForwards, clipForwards) {\r\n    var sourceVertex = this.first,\r\n        clipVertex = clip.first,\r\n        sourceInClip, clipInSource;\r\n\r\n    // calculate and mark intersections\r\n    do {\r\n        if (!sourceVertex._isIntersection) {\r\n            do {\r\n                if (!clipVertex._isIntersection) {\r\n                    var i = new Intersection(\r\n                        sourceVertex,\r\n                        this.getNext(sourceVertex.next),\r\n                        clipVertex, clip.getNext(clipVertex.next));\r\n\r\n                    if (i.valid()) {\r\n                        var sourceIntersection =\r\n                            Vertex.createIntersection(i.x, i.y, i.toSource),\r\n                            clipIntersection =\r\n                            Vertex.createIntersection(i.x, i.y, i.toClip);\r\n\r\n                        sourceIntersection._corresponding = clipIntersection;\r\n                        clipIntersection._corresponding = sourceIntersection;\r\n\r\n                        this.insertVertex(\r\n                            sourceIntersection,\r\n                            sourceVertex,\r\n                            this.getNext(sourceVertex.next));\r\n                        clip.insertVertex(\r\n                            clipIntersection,\r\n                            clipVertex,\r\n                            clip.getNext(clipVertex.next));\r\n                    }\r\n                }\r\n                clipVertex = clipVertex.next;\r\n            } while (!clipVertex.equals(clip.first));\r\n        }\r\n\r\n        sourceVertex = sourceVertex.next;\r\n    } while (!sourceVertex.equals(this.first));\r\n\r\n    // phase two - identify entry/exit points\r\n    sourceVertex = this.first;\r\n    clipVertex = clip.first;\r\n\r\n    sourceInClip = sourceVertex.isInside(clip);\r\n    clipInSource = clipVertex.isInside(this);\r\n\r\n    sourceForwards ^= sourceInClip;\r\n    clipForwards ^= clipInSource;\r\n\r\n    do {\r\n        if (sourceVertex._isIntersection) {\r\n            sourceVertex._isEntry = sourceForwards;\r\n            sourceForwards = !sourceForwards;\r\n        }\r\n        sourceVertex = sourceVertex.next;\r\n    } while (!sourceVertex.equals(this.first));\r\n\r\n    do {\r\n        if (clipVertex._isIntersection) {\r\n            clipVertex._isEntry = clipForwards;\r\n            clipForwards = !clipForwards;\r\n        }\r\n        clipVertex = clipVertex.next;\r\n    } while (!clipVertex.equals(clip.first));\r\n\r\n    // phase three - construct a list of clipped polygons\r\n    var list = [];\r\n\r\n    while (this.hasUnprocessed()) {\r\n        var current = this.getFirstIntersect(),\r\n            // keep format\r\n            clipped = new Polygon([], this._arrayVertices);\r\n\r\n        clipped.addVertex(new Vertex(current.x, current.y));\r\n        do {\r\n            current.visit();\r\n            if (current._isEntry) {\r\n                do {\r\n                    current = current.next;\r\n                    clipped.addVertex(new Vertex(current.x, current.y));\r\n                } while (!current._isIntersection);\r\n\r\n            } else {\r\n                do {\r\n                    current = current.prev;\r\n                    clipped.addVertex(new Vertex(current.x, current.y));\r\n                } while (!current._isIntersection);\r\n            }\r\n            current = current._corresponding;\r\n        } while (!current._visited);\r\n\r\n        list.push(clipped.getPoints());\r\n    }\r\n\r\n    if (list.length === 0) {\r\n        if (sourceInClip) {\r\n            list.push(this.getPoints());\r\n        }\r\n        if (clipInSource) {\r\n            list.push(clip.getPoints());\r\n        }\r\n        if (list.length === 0) {\r\n            list = null;\r\n        }\r\n    }\r\n\r\n    return list;\r\n};\r\n\r\nmodule.exports = Polygon;\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/third_party/GreinerHormann/src/polygon.js\n ** module id = 6\n ** module chunks = 0\n **/","/**\r\n * Vertex representation\r\n *\r\n * @param {Number|Array.<Number>} x\r\n * @param {Number=}               y\r\n *\r\n * @constructor\r\n */\r\nvar Vertex = function(x, y) {\r\n\r\n    if (arguments.length === 1) {\r\n        // Coords\r\n        if (Array.isArray(x)) {\r\n            y = x[1];\r\n            x = x[0];\r\n        } else {\r\n            y = x.y;\r\n            x = x.x;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * X coordinate\r\n     * @type {Number}\r\n     */\r\n    this.x = x;\r\n\r\n    /**\r\n     * Y coordinate\r\n     * @type {Number}\r\n     */\r\n    this.y = y;\r\n\r\n    /**\r\n     * Next node\r\n     * @type {Vertex}\r\n     */\r\n    this.next = null;\r\n\r\n    /**\r\n     * Previous vertex\r\n     * @type {Vertex}\r\n     */\r\n    this.prev = null;\r\n\r\n    /**\r\n     * Corresponding intersection in other polygon\r\n     */\r\n    this._corresponding = null;\r\n\r\n    /**\r\n     * Distance from previous\r\n     */\r\n    this._distance = 0.0;\r\n\r\n    /**\r\n     * Entry/exit point in another polygon\r\n     * @type {Boolean}\r\n     */\r\n    this._isEntry = true;\r\n\r\n    /**\r\n     * Intersection vertex flag\r\n     * @type {Boolean}\r\n     */\r\n    this._isIntersection = false;\r\n\r\n    /**\r\n     * Loop check\r\n     * @type {Boolean}\r\n     */\r\n    this._visited = false;\r\n};\r\n\r\n/**\r\n * Creates intersection vertex\r\n * @param  {Number} x\r\n * @param  {Number} y\r\n * @param  {Number} distance\r\n * @return {Vertex}\r\n */\r\nVertex.createIntersection = function(x, y, distance) {\r\n    var vertex = new Vertex(x, y);\r\n    vertex._distance = distance;\r\n    vertex._isIntersection = true;\r\n    vertex._isEntry = false;\r\n    return vertex;\r\n};\r\n\r\n/**\r\n * Mark as visited\r\n */\r\nVertex.prototype.visit = function() {\r\n    this._visited = true;\r\n    if (this._corresponding !== null && !this._corresponding._visited) {\r\n        this._corresponding.visit();\r\n    }\r\n};\r\n\r\n/**\r\n * Convenience\r\n * @param  {Vertex}  v\r\n * @return {Boolean}\r\n */\r\nVertex.prototype.equals = function(v) {\r\n    return this.x === v.x && this.y === v.y;\r\n};\r\n\r\n/**\r\n * Check if vertex is inside a polygon by odd-even rule:\r\n * If the number of intersections of a ray out of the point and polygon\r\n * segments is odd - the point is inside.\r\n * @param {Polygon} poly\r\n * @return {Boolean}\r\n */\r\nVertex.prototype.isInside = function(poly) {\r\n    var oddNodes = false,\r\n        vertex = poly.first,\r\n        next = vertex.next,\r\n        x = this.x,\r\n        y = this.y;\r\n\r\n    do {\r\n        if ((vertex.y < y && next.y >= y ||\r\n                next.y < y && vertex.y >= y) &&\r\n            (vertex.x <= x || next.x <= x)) {\r\n\r\n            oddNodes ^= (vertex.x + (y - vertex.y) /\r\n                (next.y - vertex.y) * (next.x - vertex.x) < x);\r\n        }\r\n\r\n        vertex = vertex.next;\r\n        next = vertex.next || poly.first;\r\n    } while (!vertex.equals(poly.first));\r\n\r\n    return oddNodes;\r\n};\r\n\r\nmodule.exports = Vertex;\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/third_party/GreinerHormann/src/vertex.js\n ** module id = 7\n ** module chunks = 0\n **/","/**\r\n * Intersection\r\n * @param {Vertex} s1\r\n * @param {Vertex} s2\r\n * @param {Vertex} c1\r\n * @param {Vertex} c2\r\n * @constructor\r\n */\r\nvar Intersection = function(s1, s2, c1, c2) {\r\n\r\n    /**\r\n     * @type {Number}\r\n     */\r\n    this.x = 0.0;\r\n\r\n    /**\r\n     * @type {Number}\r\n     */\r\n    this.y = 0.0;\r\n\r\n    /**\r\n     * @type {Number}\r\n     */\r\n    this.toSource = 0.0;\r\n\r\n    /**\r\n     * @type {Number}\r\n     */\r\n    this.toClip = 0.0;\r\n\r\n    var d = (c2.y - c1.y) * (s2.x - s1.x) - (c2.x - c1.x) * (s2.y - s1.y);\r\n\r\n    if (d === 0) {\r\n        return;\r\n    }\r\n\r\n    /**\r\n     * @type {Number}\r\n     */\r\n    this.toSource = ((c2.x - c1.x) * (s1.y - c1.y) - (c2.y - c1.y) * (s1.x - c1.x)) / d;\r\n\r\n    /**\r\n     * @type {Number}\r\n     */\r\n    this.toClip = ((s2.x - s1.x) * (s1.y - c1.y) - (s2.y - s1.y) * (s1.x - c1.x)) / d;\r\n\r\n    if (this.valid()) {\r\n        this.x = s1.x + this.toSource * (s2.x - s1.x);\r\n        this.y = s1.y + this.toSource * (s2.y - s1.y);\r\n    }\r\n};\r\n\r\n/**\r\n * @return {Boolean}\r\n */\r\nIntersection.prototype.valid = function() {\r\n    return (0 < this.toSource && this.toSource < 1) && (0 < this.toClip && this.toClip < 1);\r\n};\r\n\r\nmodule.exports = Intersection;\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/third_party/GreinerHormann/src/intersection.js\n ** module id = 8\n ** module chunks = 0\n **/","'use strict';\r\n\r\nvar geomEssentials = require(\"./geomEssentials.js\");\r\nvar candidateGenerator = require(\"./CandidateGenerator.js\");\r\n\r\nvar simulatedAnnealing = {\r\n\r\n  /**\r\n  computes the random set of positions for text placement with angles and text values\r\n  @param {Array} all_items: an array with {t,segs} elements, according to t -text of the polyline, segs - its accepted segments to label on. Result array is generated from items of this array\r\n  @returns {Array} : an array with elements such as return values of computeLabelCandidate function\r\n  */\r\n  getInitialRandomState:function(all_items){\r\n    var res=[];\r\n    for(var i=0;i<all_items.length;i++){\r\n      var candidate = candidateGenerator.computeLabelCandidate(i,all_items);\r\n      res.push(candidate);\r\n    }\r\n    return res;\r\n  },\r\n\r\n  /**\r\n  may be a custom function, must add result as last value of input array\r\n  @param {Array} overlapping_values: input array of areas\r\n  */\r\n  assignCostFunctionValuesToLastEl:function(overlapping_values){\r\n    var res=0;\r\n    for(var i in overlapping_values){\r\n      res+=overlapping_values[i];\r\n    }\r\n    overlapping_values.push(res);\r\n  },\r\n\r\n  /**\r\n  summarizing ovelapping of all layers. We store for each label it's total overlapping area with others, the sum values for all labels\r\n  @param {Array}:curset:\r\n  @returns {Array}: values of areas, last is sum\r\n  @memberof MapAutoLabelSupport#\r\n  */\r\n  evaluateCurSet:function(curset){\r\n    var overlap_values=[];\r\n    for(var i in curset){\r\n      for(var j in curset){\r\n        if(i>j){ //to exclude variants like compare (1,3) and then (3,1)\r\n        var curlabel_value=geomEssentials.checkOverLappingArea(curset[i].poly(),curset[j].poly(),this.options.minimizeTotalOverlappingArea);\r\n        //for each pair(i,j) push it's value into overlap_values array\r\n        //we know that we iterate through only lower triangle of matrix (i,j), so we can reconstruct i and j from overlap_values index and vice versa\r\n        //we do it to improve speed when recomputing ovelaps in each annealing iteration in order not to compute all overlaps (with high performance cost)\r\n        //istead we recompute areas only for changed label\r\n        overlap_values.push(curlabel_value);\r\n        }\r\n      }\r\n    }\r\n    this.assignCostFunctionValuesToLastEl(overlap_values);\r\n    return overlap_values;\r\n  },\r\n\r\n  markOveralppedLabels:function(curset,overlappedvalues){\r\n    var counter=0;\r\n    for(var i in curset){\r\n      for(var j in curset){\r\n        if(i>j){\r\n          if(overlappedvalues[counter]>0){\r\n            curset[i].overlaps = true;\r\n            curset[j].overlaps = true;\r\n            // this.dodebug(curset[i].t.content_node.textContent +' /// '+curset[j].t.content_node.textContent  )\r\n          }\r\n          counter++;\r\n        }\r\n      }\r\n    }\r\n  },\r\n\r\n  getOverlappingLabelsIndexes:function(curvalues,curset){\r\n    var counter=0, result=[];\r\n    for(var i in curset)\r\n     for(var j in curset)if(i>j){\r\n       if(curvalues[counter]>0){\r\n         result.push(i); result.push(j);\r\n       }\r\n       counter++;\r\n     }\r\n    return result;\r\n  },\r\n\r\n  /**\r\n  swaps position for a random label with another from this label's positions pool\r\n  @param {Number} index : index of label in all_items to select new random position from availavle choices.\r\n  @param {Array} curset: currently selected label postions\r\n  @param {Array} all_items: all available postions\r\n  @memberof MapAutoLabelSupport#\r\n  */\r\n  swapCandidateInLabelSetToNew:function(idx,curset,all_items){\r\n    var label_index = curset[idx].all_items_index();\r\n    var new_candidate = candidateGenerator.computeLabelCandidate(label_index,all_items);\r\n    curset[idx]=new_candidate;\r\n  },\r\n\r\n  applyNewPositionsForLabelsInArray:function(idx_array,curset,all_items){\r\n    for(var i in idx_array)this.swapCandidateInLabelSetToNew(idx_array[i],curset,all_items);\r\n  },\r\n\r\n  /**\r\n  calculates total overlapping area with knowlesge of previous value and what label was moved, affects curvalues\r\n  @param {Array} curvalue: array of float computed at previous step or initital step, consist of elements of lower-triangluar matrix (i,j) of values of overlapping areas for (i,j) els of curset\r\n  @param {Array} curset: current set of label with positions\r\n  @param {Number} changedLabelIndex: an index of label which position we changed\r\n  */\r\n  evaluateAfterSeveralChanged:function(curvalues,curset,changedLabels) {\r\n    var counter=0; //index to iterate through curvalue array\r\n    while(changedLabels.length>0){\r\n      var changedLabelIndex=changedLabels.pop();\r\n      for(var i=0;i<curset.length;i++){\r\n        for(var j=0;j<curset.length;j++){if(i>j){ //i,j like we used them in the evaluateCurSet function, so we get similar counter values\r\n          if(i===changedLabelIndex||j===changedLabelIndex){ //here we obtain all indexes of curvales array corresponding to changedLabelIndex\r\n            var area=this.checkOverLappingArea(curset[i].poly(),curset[j].poly(),this.options.minimizeTotalOverlappingArea); //and recalculate areas\r\n            curvalues[counter]=area;\r\n            }\r\n            counter++;\r\n          }\r\n        }\r\n      }\r\n    }\r\n    curvalues.pop(); //remove prev sum\r\n    this.assignCostFunctionValuesToLastEl(curvalues);\r\n  },\r\n\r\n  dodebug:function(message){\r\n    if(this.options.debug)console.log(message);\r\n  },\r\n\r\n  processOptions:function(options){\r\n    this.options=options || {};\r\n    this.options.t0 = this.options.t0 || 2.5;\r\n    this.options.decrease_value = this.options.decrease_value || 0.9; //decrease by ten percent each decrease step\r\n    this.options.tmin = this.options.tmin || 0.0;\r\n    this.options.constant_temp_repositionings = this.options.constant_temp_repositionings || 10;\r\n    this.options.max_improvments_count = this.options.max_improvments_count || 10;\r\n    this.options.max_noimprove_count = this.options.max_noimprove_count || 20;\r\n    this.options.maxsteps = this.options.maxsteps || 100;\r\n    this.options.maxtotaliterations = this.options.maxtotaliterations || 100000;\r\n    this.options.minimizeTotalOverlappingArea=this.options.minimizeTotalOverlappingArea || false;\r\n    this.options.debug=this.options.debug || true;\r\n    this.options.allowBothSidesOfLine=this.options.allowBothSidesOfLine || true;\r\n    candidateGenerator.options.lineDiscreteStepPx = this.options.lineDiscreteStepPx || candidateGenerator.options.lineDiscreteStepPx; //pixels\r\n  },\r\n\r\n  /**\r\n  find optimal label placement based on simulated annealing approach, relies on paper https://www.eecs.harvard.edu/shieber/Biblio/Papers/jc.label.pdf\r\n  @param {Array} all_items: an arr with labels and their available line segments to place\r\n  @param {Object} options: TODO [simulatedAnnealing] add options description\r\n  @param {Object} callback: a function to gather results and use them to render\r\n  @param {Object} context: a parent conext of the function  above (arguments.callee - but deprecated)\r\n  */\r\n  perform:function(all_items,options,callback,context) {\r\n        if(all_items.length<1){callback([])} //do nothing if no segments\r\n        else{\r\n          var t0 = performance.now();\r\n          this.processOptions(options);\r\n          //init\r\n          var curset=this.getInitialRandomState(all_items), //current label postions\r\n           curvalues = this.evaluateCurSet(curset), //current overlaping matrix (conflict graph)\r\n           t=this.options.t0, stepcount=0, doexit=curvalues[curvalues.length-1] === 0,//if no overlaping at init state, do nothing and return curretn state\r\n           iterations=0, This=this;\r\n\r\n          var doReturn = function(){\r\n              This.dodebug('overlapping labels count = '+curvalues.pop()+', total labels count = '+curset.length+', iterations = '+iterations);\r\n              This.dodebug('time to annealing = '+(performance.now()-t0));\r\n              This.markOveralppedLabels(curset,curvalues);\r\n              callback.call(context,curset);\r\n            }\r\n          }\r\n\r\n          //step\r\n          while(true){\r\n            //while(t>options.tmin && stepcount<options.maxsteps && !doexit\r\n            if(t<=this.options.tmin || stepcount>=this.options.maxsteps){\r\n              doReturn();\r\n              return;\r\n            }\r\n            stepcount++;\r\n            var improvements_count=0, no_improve_count=0;\r\n            for(var i=0;i<this.options.constant_temp_repositionings*curset.length;i++){ //while constant temperature, do some replacments\r\n              var oldvalues = curvalues.slice(0), //clone curvalues in order to return to ld ones\r\n                  oldset = curset.slice(0),\r\n                  overlapped_indexes = this.getOverlappingLabelsIndexes(curvalues,curset);\r\n              this.applyNewPositionsForLabelsInArray(overlapped_indexes,curset,all_items);\r\n              this.evaluateAfterSeveralChanged(curvalues,curset,overlapped_indexes);\r\n              iterations++;\r\n              if(curvalues[curvalues.length-1] === 0){ //no overlaps already\r\n                This.dodebug('strict solution');\r\n                doReturn();\r\n                return;\r\n              }\r\n              if(iterations>this.options.maxtotaliterations){ //not to hang too long\r\n                doReturn();\r\n                return;\r\n              }\r\n              var delta = (oldvalues[oldvalues.length-1]-curvalues[curvalues.length-1]);\r\n              if(delta<0){//ie, new labeling is worse!\r\n                var P=1 - Math.exp(delta/t);\r\n                if(P>Math.random()){ //undo label reposition with probability of P\r\n                  curvalues = oldvalues;\r\n                  curset=oldset;\r\n                  no_improve_count++;\r\n                }else { //approve new repositioning\r\n                  improvements_count++;\r\n                  no_improve_count=0;\r\n                }\r\n              }else{\r\n                 improvements_count++;\r\n                 no_improve_count=0;\r\n               }\r\n              if(no_improve_count>=this.options.max_noimprove_count*curset.length){ //it is already optimal\r\n                This.dodebug('stable state, finish on it');\r\n                doReturn();\r\n                return;\r\n              }\r\n              if(improvements_count>=this.options.max_improvments_count*curset.length){\r\n                break; //of for\r\n              }\r\n            }\r\n            //decrease t\r\n            t*=this.options.decrease_value;\r\n          };\r\n      }\r\n  }\r\n\r\n\r\nmodule.exports = simulatedAnnealing;\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/simulatedAnnealing.js\n ** module id = 9\n ** module chunks = 0\n **/","var geomEssentials = require('./geomEssentials.js');\r\nvar itemFactory = require('./LabelItem.js');\r\n\r\nvar candidateGenerator = {\r\n  options:{\r\n    lineDiscreteStepPx:3\r\n  },\r\n\r\n  obtainCandidateForPoint:function(point){\r\n    //TODO[obtainCandidateForPoint]\r\n  },\r\n\r\n  obtainCandidateForPoly:function(polygon){\r\n    //TODO[obtainCandidateForPoly]\r\n  },\r\n\r\n  /**\r\n  Get a poly (simple with no text along path)for random offset on the polyline\r\n  @param {Object} item: item from prepareCurSegments's allsegs\r\n  @returns {Array} : a poly bounding text, placed on corresponding point for offset on poluline and rotated to match segment's skew\r\n  */\r\n  obtainCandidateForPolyLineByRandomStartOffset:function(item){\r\n    var random_offset = item.totalLength*Math.random();\r\n    var candidate = itemFactory.candidatePosition(random_offset,item);\r\n    return candidate;\r\n  },\r\n\r\n  /**\r\n  computes label candidate object to place on map\r\n  @param {Number} i: an index in all_items array to obtain label candidate for i-item\r\n  @returns {candidatePosition} : generated candidate\r\n  */\r\n  computeLabelCandidate:function(i,all_items) {\r\n    var candidate;\r\n    switch (all_items[i].layer_type()) {\r\n      case 0:\r\n        break;\r\n      case 1:{\r\n          candidate=this.obtainCandidateForPolyLineByRandomStartOffset(all_items[i]);\r\n          break;\r\n        }\r\n      case 2:\r\n        break;\r\n    }\r\n    return candidate;\r\n  },\r\n}\r\n\r\nmodule.exports = candidateGenerator;\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/CandidateGenerator.js\n ** module id = 10\n ** module chunks = 0\n **/","/*\r\nmodlue to create labelItems convenient for labelling and calculation\r\n*/\r\n\r\nvar geomEssentials = require('./geomEssentials.js');\r\n\r\nmodule.exports = {\r\n  /**\r\n  a factory function for label items\r\n  @param {TextNode} txNode: SVG TextNode\r\n  @param {L.Point} txSize: size of bounding box for txNode\r\n  @param {L.Layer} layer: a feature (Marker, Polyline, Path) to aquire data\r\n  */\r\n  labelItem:function(txNode,txSize,layer,hostArray){\r\n    var basic_item= {\r\n      data:[],\r\n      txNode:txNode,\r\n      txSize:txSize,\r\n      layer:layer,\r\n      host:hostArray,\r\n      index:function(){\r\n        return this.host.lastIndexOf(this);\r\n      },\r\n      readData:function(){return false}, //a method stub\r\n      layer_type:function(){\r\n        //TOFIX for polygon\r\n        if(!this._layer_type)this._layer_type = (this.layer._parts.length>0)?1:0;\r\n        return this._layer_type;\r\n      }\r\n    };\r\n\r\n    if(basic_item.layer_type()==0){\r\n      return;\r\n      basic_item.readData = function(){\r\n        if(basic_item.layer.getLatLngs())\r\n        basic_item.data=basic_item.layer._map.latLngToLayerPoint(basic_item.layer.getLatLngs()[0]); //so we adding only L.Point obj\r\n      }\r\n    }else{\r\n      //this give possibility to read all parts to separate items\r\n      basic_item.readData=function(partIndex){ //to read consequently\r\n        if(!partIndex){var partIndex=0;};\r\n        this.data = this.layer._parts[partIndex];\r\n        this.partIndex=partIndex; //store this to have ability to compute totalOffset, for example\r\n        var nextPart=++partIndex;\r\n        if(nextPart<this.layer._parts.length)return nextPart;else return false;\r\n      }\r\n    }\r\n\r\n    if(basic_item.layer_type()==1){\r\n      if(basic_item.layer._parts.length==0)return;\r\n      basic_item.computed_lengths=[];\r\n      basic_item.totalLength=0;\r\n\r\n      basic_item.segCount = function(){return this.data.length -1};\r\n\r\n      /**\r\n      Get a segment from polyline part by it's offset\r\n      @param {Number} offset: na offset for the polyline\r\n      @returns {Array} : index of start point of segment and dist which is offset from start of the line to the end of found segment\r\n      */\r\n      basic_item.getSegmentIdxAndDistByOffset=function(offset){\r\n        return geomEssentials.getSegmentIdxAndDistByOffset(offset,this.data,this.computed_lengths);\r\n      }\r\n\r\n      /**\r\n      get a random element from segments array of the item, assuming it is sorted lengths ascending order\r\n      probability is higher for longer segment\r\n      */\r\n      basic_item.getIndexBasedOnTotalLengthRandom=function(){\r\n        return geomEssentials.getIndexBasedOnTotalLengthRandom(this.data,this.computed_lengths,this.totalLength);\r\n      }\r\n    }\r\n    return basic_item;\r\n  },\r\n\r\n  candidatePosition:function(offset_or_origin,item){\r\n    return {\r\n      _item:item,\r\n      offset_or_origin:offset_or_origin,\r\n      _poly:false,\r\n      all_items_index:function(){\r\n        return this._item.index();\r\n      },\r\n\r\n      /**\r\n      Used for calculationg overlaps for text along path (textPath SVG).\r\n      @param {Number} start_offset: global offset for this polyline (item), same as used in rendering\r\n      @param {LabelItem} item:\r\n      @returns {Array} : a poly bounding curved text\r\n      */\r\n      _computePolyForLine:function(start_offset,item){\r\n        var final_offset = start_offset + item.txSize.x;\r\n        var end_offset=(final_offset<item.totalLength)?final_offset:item.totalLength;\r\n        var subPolyline = geomEssentials.extractSubPolylineByOffsetValues(start_offset,end_offset,item.data,item.computed_lengths);\r\n        return geomEssentials.computeLineBoundaryPolygon(subPolyline,item.txSize.y);\r\n      },\r\n\r\n      /**\r\n      common function switch for computing poly for different layer_types\r\n      */\r\n      _computePoly:function(){\r\n        switch(item.layer_type()){\r\n          case 0:break;\r\n          case 1:{\r\n              this._poly = this._computePolyForLine(this.offset_or_origin,this._item);\r\n            }\r\n          case 2:break;\r\n        }\r\n      },\r\n\r\n      poly:function(){\r\n        if(!this._poly)this._computePoly();\r\n        return this._poly;\r\n      }\r\n    }\r\n  },\r\n\r\n}\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/LabelItem.js\n ** module id = 11\n ** module chunks = 0\n **/","/**\r\nModule to extract sufficient info to label data on the map\r\n*/\r\n\r\n\"use strict\";\r\n\r\nvar DOMEssentials = require(\"./DOMEssentials.js\");\r\nvar geomEssentials = require(\"./geomEssentials.js\");\r\nvar itemFactory = require('./LabelItem.js');\r\n\r\nvar dataReader = {\r\n  /**\r\n  creates an array of features's segments for each feature  of layers2label's layers on screen along with SVG text corresponding to\r\n  @returns [Array] returns an array with values : {t:{content_node:SVG textnode},parts:feature parts,layertype}, then, in next funcs we add apoly param to t object, ir, its bounding polygon, layertype = 0 marker, 1 polyline, 2 polygon\r\n  */\r\n  readDataToLabel:function(){\r\n    var pt  =[];\r\n    if(this._map){\r\n      for(var i in this._map.autoLabeler._layers2label)\r\n      if(this._map.getZoom()>this._map.autoLabeler._layers2label[i]._al_options.zoomToStartLabel)\r\n      {\r\n        var lg=this._map.autoLabeler._layers2label[i],\r\n            map_to_add = this._map;\r\n        lg.eachLayer(function(layer){\r\n          if(layer.feature)\r\n          if(layer.feature.properties[lg._al_options.propertyName]){\r\n            var node = DOMEssentials.createSVGTextNode(layer.feature.properties[lg._al_options.propertyName],lg._al_options.labelStyle),\r\n                size = DOMEssentials.getBoundingBox(map_to_add,node); //compute ortho aligned bbox for this text, only once, common for all cases\r\n            var firstItem = itemFactory.labelItem(node,size,layer,pt)\r\n            if(firstItem){\r\n              var nextPartIndex=firstItem.readData();\r\n              pt.push(firstItem);\r\n              while(nextPartIndex){\r\n                var item = itemFactory.labelItem(node,size,layer,pt); //create node template\r\n                nextPartIndex=item.readData(nextPartIndex);\r\n                pt.push(item);\r\n              }\r\n            }\r\n          }\r\n        });\r\n      }\r\n    }\r\n    return pt;\r\n  },\r\n\r\n  /**\r\n  extracts good segments from available polyline parts and converts to use in next procedures of pos estimation\r\n  @param {Array} all_items:\r\n  @param {Set} options: options are:  {integer} maxlabelcount: if more labels in all_items, then do nothing\r\n  */\r\n  prepareCurSegments:function(all_items,options){\r\n    options = options || {};\r\n    options.maxlabelcount=options.maxlabelcount || 100;\r\n    if(all_items.length>options.maxlabelcount || all_items.length==0){\r\n      this._map.autoLabeler._dodebug('too much OR no labels to compute('+all_items.length+')');\r\n      return false;\r\n    }\r\n    for(var i=0;i<all_items.length;i++){\r\n      var item = all_items[i];\r\n      if(item.layer_type()==0){//if point -> do nothing.\r\n        continue;\r\n      }\r\n      //else compute for lines and polygons, now it is only fo lines\r\n      if(item.layer_type()==1){\r\n        this._applyLineFeatureData(item); //in case where two or move separate polylines generated for original polyline while rendering (imagine big W cutted by screen iwndow)\r\n      }\r\n    }\r\n    return true;\r\n  },\r\n\r\n  /**\r\n  Calculates total length for this polyline on screen, and lengths of each segments with their angles\r\n  @param {labelItem} item: an item to get above data to\r\n  */\r\n  _applyLineFeatureData:function(item){ //calculate some data once to increase performance\r\n      item.totalLength=0;\r\n      item.computed_lengths = geomEssentials.computeSegmentsLengths(item.data);\r\n      for(var k=0;k<item.computed_lengths.length;k++){\r\n        item.totalLength+=item.computed_lengths[k];\r\n      }\r\n  }\r\n}\r\n\r\nmodule.exports = dataReader;\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/DataReader.js\n ** module id = 12\n ** module chunks = 0\n **/"],"sourceRoot":""}