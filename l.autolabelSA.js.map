{"version":3,"sources":["webpack:///webpack/bootstrap 4bc95d5dd92579f2e72b","webpack:///./src/MapPart.js","webpack:///./src/autoLabeler.js","webpack:///./src/DOMEssentials.js","webpack:///./src/geomEssentials.js","webpack:///./src/third_party/GreinerHormann/src/greiner-hormann.js","webpack:///./src/third_party/GreinerHormann/src/clip.js","webpack:///./src/third_party/GreinerHormann/src/polygon.js","webpack:///./src/third_party/GreinerHormann/src/vertex.js","webpack:///./src/third_party/GreinerHormann/src/intersection.js","webpack:///./src/simulatedAnnealing.js","webpack:///./src/autoLabelManager.js","webpack:///./src/CandidateGenerator.js","webpack:///./src/LabelItem.js","webpack:///./src/DataReader.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;ACtCA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;;AAGL;AACA;AACA;AACA,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA,uEAAsE,iBAAiB,kBAAkB,EAAE;AAC3G;AACA,yDAAwD;AACxD;AACA;AACA,MAAK;;AAEL;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX,QAAO;;AAEP,EAAC;;;;;;;AC5ED;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,oCAAmC;AACnC,kDAAiD;AACjD,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA0C,sBAAsB;AAChE,yCAAwC,sBAAsB;AAC9D;AACA,MAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA8D,kBAAkB;AAChF,QAAO;AACP;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,kCAAiC;AACjC;AACA;AACA;AACA,kDAAiD,iBAAiB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA,0CAAyC,kDAAkD;AAC3F;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,wDAAuD;AACvD,0BAAyB;AACzB,mCAAkC;AAClC;AACA;AACA;AACA,UAAS,kDAAkD;AAC3D;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb,YAAW;AACX;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;ACpMA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAU,cAAc;AACxB,aAAY;AACZ;AACA;AACA;AACA;AACA,2CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,WAAU,OAAO;AACjB,WAAU,OAAO;AACjB,aAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,WAAU,OAAO;AACjB,WAAU,OAAO;AACjB,aAAY,SAAS;AACrB;AACA;AACA,yCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;;;;;;;ACnDA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,WAAU,MAAM;AAChB,aAAY,MAAM;AAClB;AACA;AACA;AACA,iBAAgB,kBAAkB;AAClC;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,WAAU,QAAQ;AAClB,WAAU,QAAQ;AAClB,WAAU,QAAQ;AAClB,aAAY,MAAM;AAClB;AACA;AACA;AACA,+BAA8B;AAC9B;AACA,IAAG;;AAEH;AACA;AACA,WAAU,QAAQ;AAClB,WAAU,QAAQ;AAClB,aAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,iBAAgB,QAAQ;AACxB,iBAAgB,QAAQ;AACxB,mBAAkB,OAAO;AACzB;AACA;AACA,+CAA8C;AAC9C;AACA;AACA;AACA,IAAG;;;AAGH;AACA;AACA,WAAU,QAAQ;AAClB,WAAU,QAAQ;AAClB,WAAU,QAAQ;AAClB,WAAU,QAAQ;AAClB,aAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,aAAY,QAAQ;AACpB,aAAY,QAAQ;AACpB,eAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,WAAU,QAAQ;AAClB,aAAY;AACZ;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,WAAU,QAAQ;AAClB,aAAY,QAAQ;AACpB;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA,WAAU,MAAM;AAChB,WAAU,OAAO;AACjB,aAAY,MAAM;AAClB;AACA,gDAA+C;AAC/C;AACA,iBAAgB,oBAAoB;AACpC;AACA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA,QAAO;AACP,+CAA8C;AAC9C;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,WAAU,OAAO;AACjB,WAAU,MAAM;AAChB,WAAU,MAAM;AAChB,aAAY,MAAM;AAClB;AACA;AACA;AACA,iBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,WAAU,MAAM;AAChB,WAAU,MAAM;AAChB,WAAU,OAAO;AACjB;AACA;AACA,gDAA+C;AAC/C;AACA;AACA,iBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA,WAAU,OAAO;AACjB,WAAU,OAAO;AACjB,WAAU,MAAM;AAChB,WAAU,MAAM;AAChB,aAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAAyB,UAAU,KAAK;AACxC;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,WAAU,OAAO;AACjB,WAAU,OAAO;AACjB,WAAU,UAAU;AACpB,aAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,WAAU,MAAM;AAChB;AACA;AACA,iBAAgB,oBAAoB;AACpC;AACA,IAAG;;AAEH;AACA;AACA,SAAQ,MAAM;AACd,SAAQ,MAAM;AACd,WAAU,MAAM;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA,IAAG;;;AAGH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,wBAAuB;AACvB,IAAG;;AAEH;AACA;AACA;AACA,WAAU,MAAM;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA0C;AAC1C,qBAAoB,mBAAmB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;;AAGH;AACA;AACA,YAAW;AACX,YAAW;AACX,aAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAiC,cAAc;AAC/C,IAAG;;AAEH;AACA;AACA;AACA,WAAU,MAAM;AAChB,WAAU,MAAM;AAChB,WAAU,MAAM;AAChB,aAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA,iBAAgB,cAAc;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,WAAU,MAAM;AAChB,WAAU,MAAM;AAChB,aAAY,MAAM;AAClB;AACA;AACA;AACA;AACA,iBAAgB,cAAc;AAC9B,4BAA2B;AAC3B;AACA;AACA,IAAG;;AAEH;AACA;AACA,WAAU,MAAM;AAChB,WAAU,MAAM;AAChB,aAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB,cAAc;AAC9B,4BAA2B;AAC3B;AACA;AACA;AACA;;AAEA;;;;;;;ACtYA;;AAEA;AACA;AACA;AACA,iBAAgB,qCAAqC;AACrD,iBAAgB,qCAAqC;AACrD,iBAAgB;AAChB;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,iBAAgB,qCAAqC;AACrD,iBAAgB,qCAAqC;AACrD,iBAAgB;AAChB;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,iBAAgB,qCAAqC;AACrD,iBAAgB,qCAAqC;AACrD,iBAAgB;AAChB;AACA;AACA;AACA,MAAK;;AAEL;AACA;;;;;;;AClCA;;AAEA;AACA;AACA;AACA,aAAY,uBAAuB;AACnC,aAAY,uBAAuB;AACnC,aAAY,QAAQ;AACpB,aAAY,QAAQ;AACpB,aAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;ACjBA;AACA;;AAEA;AACA;AACA,YAAW,uBAAuB;AAClC,YAAW,SAAS;AACpB;AACA;AACA;AACA;;AAEA;AACA,eAAc;AACd;AACA;;AAEA;AACA,eAAc;AACd;AACA;;AAEA;AACA,eAAc;AACd;AACA;;AAEA;AACA,wDAAuD;AACvD,eAAc;AACd;AACA;AACA;AACA;;AAEA,oCAAmC,SAAS;AAC5C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAY,OAAO;AACnB,aAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA,aAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAS;AACT,MAAK;AACL;AACA;AACA;AACA;AACA,cAAa;AACb;AACA,UAAS;AACT;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,QAAQ;AACnB,YAAW,QAAQ;AACnB,YAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;;AAEA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;;AAEjB,cAAa;AACb;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA,UAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;AC/RA;AACA;AACA;AACA,YAAW,sBAAsB;AACjC,YAAW,QAAQ;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;AACA;;AAEA;AACA;AACA,aAAY,OAAO;AACnB,aAAY,OAAO;AACnB,aAAY,OAAO;AACnB,aAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAY,OAAO;AACnB,aAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,QAAQ;AACnB,aAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;;AAEA;;;;;;;AC1IA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB;AACA;AACA;;AAEA;AACA,eAAc;AACd;AACA;;AAEA;AACA,eAAc;AACd;AACA;;AAEA;AACA,eAAc;AACd;AACA;;AAEA;AACA,eAAc;AACd;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,eAAc;AACd;AACA;;AAEA;AACA,eAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAY;AACZ;AACA;AACA;AACA;;AAEA;;;;;;;AC3DA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,IAAG;;AAEH;AACA;AACA,WAAU,MAAM;AAChB,aAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,WAAU,MAAM;AAChB;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA,mBAAkB;AAClB,mBAAkB,8BAA8B;AAChD;AACA,qBAAoB,8BAA8B,YAAY;AAC9D,4DAA2D;AAC3D,+HAA8H;AAC9H;AACA;AACA;AACA;AACA;AACA,mCAAkC;AAClC;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA,sEAAqE;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA,IAAG;;AAEH;AACA,WAAU,MAAM;AAChB,aAAY,MAAM;AAClB;AACA;AACA;AACA,2CAA0C;AAC1C,2BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,mBAAkB,wEAAwE,KAAK;AAC/F;AACA;AACA;AACA;AACA;AACA,iDAAgD,mCAAmC;AACnF,wDAAuD,mCAAmC;AAC1F;AACA,qBAAoB;AACpB;AACA,+BAA8B;AAC9B;AACA;AACA,YAAW,MAAM;AACjB;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,4FAA2F;AAC3F;AACA;AACA;AACA,iBAAgB;AAChB;AACA;AACA,sCAAqC;AACrC;AACA,IAAG;;AAEH;AACA;AACA,WAAU,MAAM;AAChB,WAAU,OAAO;AACjB,WAAU,OAAO;AACjB,WAAU,OAAO;AACjB;AACA;AACA,0CAAyC,aAAa;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;;;;;;AC7JA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;AACL;AACA;AACA,aAAY,MAAM,2BAA2B,OAAO;AACpD,eAAc,MAAM;AACpB;AACA;AACA;AACA;AACA,mBAAkB,oBAAoB;AACtC;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAY,MAAM;AAClB,eAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA8C;AAC9C;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,aAAY,OAAO;AACnB,aAAY,MAAM;AAClB,aAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;AC1HA;AACA;;AAEA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA,WAAU,OAAO;AACjB,aAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,WAAU,OAAO;AACjB,aAAY,kBAAkB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;;;;;;;AChDA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,WAAU,OAAO;AACjB,WAAU,OAAO;AACjB,WAAU,QAAQ;AAClB,WAAU,QAAQ;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP,2BAA0B,aAAa;AACvC;AACA;AACA;AACA;AACA,QAAO;;AAEP,+BAA8B,cAAc;AAC5C,oCAAmC;;AAEnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,oGAAmG;AACnG;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,+CAA8C;AAC9C,wBAAuB;AACvB;AACA;AACA,kCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;;AAEA,wCAAuC;;AAEvC;AACA;AACA,eAAc,OAAO;AACrB,iBAAgB,MAAM;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,eAAc,UAAU;AACxB;AACA;AACA;AACA;AACA,qBAAoB,+BAA+B;AACnD;AACA;AACA;AACA;;AAEA;;AAEA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA;AACA;AACA,eAAc,OAAO;AACrB,eAAc,UAAU;AACxB,iBAAgB,MAAM;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;;;;;;;AChKA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,oDAAmD,GAAG,0BAA0B,+BAA+B;AAC/G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAqE;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA2E;AAC3E;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,WAAU,MAAM;AAChB,WAAU,IAAI,yBAAyB,QAAQ;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA6D;AAC7D;AACA;AACA;AACA,IAAG;AACH;;AAEA","file":"l.autolabelSA.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"./\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 4bc95d5dd92579f2e72b\n **/","(function () {\r\n  \"use strict\";\r\n\r\n  var autoLabeler = require('./autoLabeler.js');\r\n\r\n  var __onRemove = L.LayerGroup.prototype.onRemove;\r\n  //\r\n  // var geomEssentials = require(\"./geomEssentials.js\");\r\n  //\r\n  // var poly1 =[[195.28215910639838,47.1410795531992],[231,65],[261,9],[273.7383792229255,15.079680992759897],[297.859236050962,-35.4592571231262],[236.8793791587075,-64.56327973079307],[207.3470977755445,-9.43635448222185],[220.326120454396,-2.946843142796098]];\r\n  //\r\n  // var poly2 =[[407.0824120592751,-65.5164843828588],[302,-82],[291.5910849433034,-86.16356602267865],[270.7932070674736,-34.16887133310413],[287.07399919130665,-27.65655448357095],[398.40421700394324,-10.192990905118151]];\r\n  //\r\n  // var poly3 = geomEssentials.clipPoly(poly1,poly2);\r\n  //\r\n  // console.log(poly3);\r\n  //to include in LabelGroup\r\n  var AutoLabelingSupport = {\r\n      /**\r\n      handle removing layer from the map\r\n      */\r\n      onRemove: function (map) {\r\n      this.disableAutoLabel();\r\n        __onRemove.call(this, map);\r\n    },\r\n\r\n\r\n    /**\r\n     enable autolabeling for this layerGroup, additionally set the current_map variable if it is undefined and hooks label painting on moveend /zoomend events\r\n     it adds this layerGroup to the _layers2label array, so _doAutoLabel function will know about this layerGroup\r\n     @param {Object} options: labelStyle - css string to describe labels look, for now one for all layers in group, propertyName - a property from layer.feature.properties which we label on map\r\n    */\r\n    enableAutoLabel:function(options){\r\n      if(!this._map)return;\r\n      if(!this._map.autoLabeler)return;\r\n      this._al_options = options || {};\r\n      this._al_options.labelStyle = options.labelStyle || \"fill: lime; stroke: #000000;  font-size: 20px;\"; //TODO [enableAutoLabel] add ability to set unique style for each feature\r\n      this._al_options.propertyName = options.propertyName || \"name\";\r\n      this._al_options.priority = options.priority || 0; //highest\r\n      this._al_options.zoomToStartLabel = options.zoomToStartLabel || this._map.autoLabeler.options.zoomToStartLabel;\r\n      this._map.autoLabeler.addLayer(this);\r\n    },\r\n\r\n    /**\r\n    Obtain autlabelling state for this layerGroup\r\n    @returns {Boolean}\r\n    */\r\n    autoLabelEnabled:function(){\r\n      if(!this._map.autoLabeler)return false;\r\n      return this._map.autoLabeler.hasLayer(this);\r\n    },\r\n\r\n    /**\r\n    disable autolabelling\r\n    */\r\n    disableAutoLabel:function(){\r\n      if(!this._map.autoLabeler){\r\n        delete this._al_options;\r\n        return;\r\n      }\r\n      if(this._map.autoLabeler.remLayer(this)){\r\n        delete this._al_options;\r\n      }\r\n    }\r\n  }\r\n\r\n  L.LayerGroup.include(AutoLabelingSupport);\r\n\r\n  L.Map.addInitHook(function () {\r\n          this.whenReady(function () {\r\n              if (this.options.autolabel) {\r\n                this.autoLabeler = L.autoLabeler(this,this.options.autolabelOptions)\r\n              }\r\n          });\r\n      });\r\n\r\n})();\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/MapPart.js\n ** module id = 0\n ** module chunks = 0\n **/","var DOMEssentials = require('./DOMEssentials.js');\r\nvar geomEssentials = require('./geomEssentials.js');\r\nvar simulatedAnnealing = require('./simulatedAnnealing.js');\r\nvar autoLabelManager =require(\"./autoLabelManager.js\");\r\nvar dataReader = require('./DataReader.js');\r\n\r\nL.AutoLabeler = L.Evented.extend(\r\n {\r\n    _layers2label:[], //an array to know which layergroups are to label\r\n    options:{\r\n      showBBoxes:false, //display bounding boxes around texts\r\n      debug:true,//show debug info in hte cons\r\n      labelsDelay:1000,//a time after update event of renderer when labelling should start, if zero - errors while zooming\r\n      checkLabelsInside:true,//re-clip all segments to entirely fit map window without padding, disabling increases performance, but some labels maybe invisible due to padding of renderer\r\n      zoomToStartLabel:13,//if map zoom lev is below this, do not show labels\r\n      minimizeTotalOverlappingArea:false, //if true, minimize not the count of overlapping labels, but instead their total overlapping area\r\n      deleteIfNoSolution:false,//TODO [setAutoLabelOptions] if no solution can be achieivd, delete some of the labels, which are overlapping, based on their layer al_options.priority or random if equal\r\n      doNotShowIfSegIsTooSmall:false, //TODO [setAutoLabelOptions] if segment length is less then textlength of text, do not show this text\r\n      annealingOptions:{}\r\n    }, //autolabel options\r\n\r\n    _autoLabel:false, //to determine if autolabelling is set for this map\r\n\r\n    initialize: function (map, options) {\r\n      L.setOptions(this, options);\r\n      this._map=map;\r\n    },\r\n\r\n    hasLayer:function(layer){\r\n      return this._layers2label.indexOf(layer)!=-1;\r\n    },\r\n\r\n    addLayer:function(layer){\r\n      if(!this.hasLayer(layer))this._layers2label.push(layer);\r\n    },\r\n\r\n    remLayer:function(layer){\r\n      var ind=this._layers2label.indexOf(layer);\r\n      if(ind>=0){\r\n        this._layers2label.splice(ind,1);\r\n      }\r\n      return ind>=0;\r\n    },\r\n\r\n    /**\r\n    toggles autolabeling\r\n    */\r\n    toggleAutoLabelling:function(){ //this not tested yet\r\n      if(this._autoLabel)this.disableAutoLabel();else this.enableAutoLabel();\r\n    },\r\n\r\n    /**\r\n    enable autolabeling\r\n    */\r\n    enableAutoLabel:function(){\r\n      if(!this._map){\r\n        this._dodebug('no map attached');\r\n        return;\r\n      }\r\n      if(!this._map.options.renderer){\r\n        this._dodebug('renderer is invalid');\r\n        return;\r\n      }\r\n      this._map.options.renderer.on(\"update\",this._apply_doAutoLabel);\r\n      this._map.on(\"zoomstart\",function(){this._zoomstarttrig=1});\r\n      this._map.on(\"zoomend\",function(){this._zoomstarttrig=0});\r\n      this._autoLabel = true;\r\n    },\r\n\r\n    //to check if zoomstart event is fired to prevent autolabeling BEFORE zoomend\r\n    _zoomstarttrig:0,\r\n\r\n    //id of timeout after which AutoLabeling should be done each time - used to stop timer in case of changed map state BEFORE autolabelling was performed\r\n    _ctimerID:-1,\r\n\r\n    /**\r\n    disable autolabeling for this map\r\n    */\r\n    disableAutoLabel:function(){\r\n      this._map.options.renderer.off(\"update\",this._apply_doAutoLabel);\r\n      this._autoLabel=false;\r\n    },\r\n\r\n    /*\r\n    beacuse we using update event of renderer, here we switching to map context and handling two-time update event of SVG renderer\r\n    */\r\n    _apply_doAutoLabel:function(){\r\n      if(this._map.autoLabeler._ctimerID!=-1)clearTimeout(this._map.autoLabeler._ctimerID);\r\n      if(this._map.autoLabeler._zoomstarttrig==0){\r\n        var al = this._map.autoLabeler;\r\n        var lDelay = this._map.autoLabeler.options.labelsDelay;\r\n        this._map.autoLabeler._ctimerID=setTimeout(function(){al._doAutoLabel()},lDelay);\r\n      }else\r\n      this._map.autoLabeler._clearNodes();\r\n    },\r\n\r\n    _dodebug:function(message){\r\n      if(this.options.debug)console.log(message);\r\n    },\r\n\r\n    /**\r\n    this function obtains visible polyline segments from screen and computes optimal positions and draws labels on map\r\n    */\r\n    _doAutoLabel:function() {\r\n      if(!this._autoLabel)return; //nothing to do here\r\n      if(this._map.getZoom()>this.options.zoomToStartLabel){\r\n        dataReader._map=this._map;\r\n        var all_items  =dataReader.readDataToLabel(this._map) //array for storing paths and values\r\n        dataReader.prepareCurSegments(all_items,{maxlabelcount:80});\r\n        if(all_items.length==0){\r\n          this._clearNodes();\r\n          return;\r\n        }\r\n        var annMan = new autoLabelManager(all_items);\r\n        // annMan.getInitialRandomState();\r\n        // this._renderNodes(annMan.curset);\r\n        var annPerformer = new simulatedAnnealing(annMan,this.options.annealingOptions);\r\n        annPerformer.perform(this._renderNodes,this);\r\n        //simulatedAnnealing.perform(annMan,this.options.annealingOptions,this._renderNodes,this);\r\n      }else{\r\n        this._clearNodes();\r\n      }\r\n    },\r\n\r\n    addPolyToLayer:function(poly,overlaps,data_to_show){\r\n      if(!this._polyLayer){\r\n        this._polyLayer = L.featureGroup().addTo(this._map)\r\n      }\r\n      var latlngs=[]; for(var i in poly)latlngs.push(this._map.layerPointToLatLng(\r\n        L.point(poly[i][0],poly[i][1])));\r\n      map_polygon = L.polygon([latlngs],{color:(overlaps)?'red':'yellow',fillOpacity:'0.5'});\r\n      map_polygon.data_to_show = JSON.stringify(poly);\r\n      this._polyLayer.addLayer(map_polygon);\r\n    },\r\n\r\n    /**\r\n    clears label on the screen\r\n    */\r\n    _clearNodes:function() {\r\n      var svg = this._map.options.renderer._container,  //to work with SVG\r\n          i=svg.childNodes.length-1;\r\n      while(i>0){ //because 0 is for g\r\n        var node = svg.childNodes[i--];\r\n        if(node.id.search('auto_label')!==-1)svg.removeChild(node);\r\n      }\r\n      if(this._polyLayer){\r\n        this._map.removeLayer(this._polyLayer);\r\n        delete this._polyLayer;\r\n      }\r\n    },\r\n\r\n    /**\r\n    renders computed labelset on the screen via svg\r\n    */\r\n    _renderNodes:function(labelset){\r\n      var svg =  this._map.options.renderer._container;  //to work with SVG\r\n      this._clearNodes(); //clearscreen\r\n      var curID,cur_zero_offset=0; //for handling several parts path - to ensure we have label on each part of feature\r\n      for(var m in labelset){\r\n        if(!curID){\r\n          curID = labelset[m]._item.layer._path.id;\r\n        }else if(curID!==labelset[m]._item.layer._path.id){ //new feature -> start offset from 0\r\n          cur_zero_offset=0;\r\n          curID = labelset[m]._item.layer._path.id;\r\n        }else\r\n         cur_zero_offset+=labelset[m-1]._item.totalLength;\r\n         var cOffset =Math.round(cur_zero_offset+labelset[m].offset_or_origin);\r\n         if(this.options.showBBoxes){\r\n           this.addPolyToLayer(labelset[m].poly(),labelset[m].overlaps,m+'_'+labelset[m]._item.text+'_'+cOffset+'@'+labelset[m]._item.txSize.x);\r\n         }\r\n        labelset[m]._item.layer.feature.properties.alabel_offset=m+'__'+cOffset;\r\n        var textPath = L.SVG.create('textPath');\r\n        textPath.setAttributeNS(\"http://www.w3.org/1999/xlink\", \"xlink:href\", '#'+curID);\r\n        textPath.setAttribute('startOffset',cOffset);\r\n        textPath.appendChild(document.createTextNode(labelset[m]._item.text));\r\n        var txNode = DOMEssentials.createSVGTextNode(\"\",labelset[m]._item.style);\r\n        txNode.appendChild(textPath);\r\n        txNode.setAttribute('id','auto_label'+m);\r\n        svg.appendChild(txNode);\r\n      }\r\n      if(this.options.showBBoxes){\r\n        this._polyLayer.eachLayer(function(layer){\r\n            //layer.bindPopup(layer.data_to_show);\r\n            layer.on('click',function(e){\r\n              console.log(layer.data_to_show);\r\n            });\r\n          });\r\n      }\r\n    }\r\n  }\r\n)\r\n\r\nL.autoLabeler = function(map,options){\r\n  return new L.AutoLabeler(map,options);\r\n}\r\n\r\n// module.exports = autoLabeler;\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/autoLabeler.js\n ** module id = 1\n ** module chunks = 0\n **/","//a class to compute pixel dimensions of texts\r\n/** @namespace DOMEssentials*/\r\n'use strict';\r\nvar geomEssentials = require(\"./geomEssentials.js\");\r\n\r\nmodule.exports = {\r\n  /**\r\n  converts TextRectangle object to clockwise array of 2d-arrays, representing rectangular poly\r\n  @param {TextRectangle} rect: a bbox for text\r\n  @returns {Array}\r\n  @memberof DOMEssentials#\r\n  */\r\n  convertClientRectToArrayOfArrays:function(rect) {\r\n    var res=[];\r\n    var height_correction=rect.height*0.2; //beacuse getBoundingClientRect give a bit false height info\r\n    res.push([0,0]);\r\n    res.push([0,-rect.height]);\r\n    res.push([rect.width,-rect.height]);\r\n    res.push([rect.width,0]);\r\n    res=geomEssentials.movePolyByAdding(res,[0,height_correction]);\r\n    return res;\r\n  },\r\n\r\n  /**\r\n  returns a bounding box for horizontal text with style as in t.content_node\r\n  @param {Object} map: current map\r\n  @param {Object} node: textNode\r\n  @returns {L.Point} : a bbox for node, as width and height\r\n  @memberof DOMEssentials#\r\n  */\r\n  getBoundingBox:function(map,node){\r\n    var svg = map.options.renderer._container;\r\n    svg.appendChild(node);\r\n    var rect = node.getBoundingClientRect();\r\n    svg.removeChild(node);\r\n    return L.point(rect.width,-rect.height);\r\n  },\r\n\r\n  /**\r\n  creates SVG text node with specified style and handles some formatting issues\r\n  @param {String} text: text for node\r\n  @param {String} textstyle: CSS style String\r\n  @returns {TextNode} : SVG node\r\n  */\r\n  createSVGTextNode:function(text,textstyle){\r\n    text = text.replace(/ /g, '\\u00A0');  // Non breakable spaces\r\n    var node =L.SVG.create('text');\r\n    node.setAttribute('style',textstyle);\r\n    node.textContent = text;\r\n    return node;\r\n  }\r\n}\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/DOMEssentials.js\n ** module id = 2\n ** module chunks = 0\n **/","//a class to perfrom geometric stuff\r\n/** @namespace geomEssentials*/\r\n'use strict';\r\n\r\nvar greinerHormann = require('./third_party/GreinerHormann');\r\n\r\nvar geomEssentials = {\r\n\r\n  /**\r\n  @param {Array} polyline: consists of L.Point\r\n  @returns {Array}: number array with length=polyline.length-1 with length of segs\r\n  */\r\n  computeSegmentsLengths:function(polyline){\r\n    var result=[];\r\n    for(var k=1;k<polyline.length;k++){\r\n      result.push(polyline[k].distanceTo(polyline[k-1]));\r\n    }\r\n    return result;\r\n  },\r\n\r\n  /**\r\n  translates segment to new loc by adding point to its vertices\r\n  @param {L.Point} a:\r\n  @param {L.Point} b:\r\n  @param {L.Point} point:\r\n  @returns {Array}:\r\n  */\r\n  translateSegment:function(a,b, point){\r\n    var result=[];\r\n    result.push(a.add(point)); result.push(b.add(point));\r\n    return result;\r\n  },\r\n\r\n  /**\r\n  using two points, computes A,B,C such as Ax+By+c=0 for these points.\r\n  @param {L.Point} start: first point of segment\r\n  @param {L.Point} finish: second point of segment\r\n  @returns {Array}: [A,B,C]\r\n  */\r\n  computeCanonicCoeffs:function(start,finish){\r\n    var ABC=[];\r\n    ABC.push(start.y-finish.y);\r\n    ABC.push(finish.x - start.x);\r\n    ABC.push(start.x * finish.y - finish.x * start.y);\r\n    return ABC;\r\n  },\r\n\r\n  /**\r\n        Returns slope (Ax+B) between two points, safe for degenerate cases\r\n        @param {L.Point} a\r\n        @param {L.Point} b\r\n        @returns {Object} with ``a`` and ``b`` properties.\r\n     */\r\n  computeSlope: function(start, finish) {\r\n     var abc = this.computeCanonicCoeffs(a,b); //ax+by+c=0 => y=-a/b x - c/b\r\n     if(abc[1]!=0){\r\n       return L.point(-abc[0]/abc[1],-abc[2]/abc[1]);\r\n     }\r\n  },\r\n\r\n\r\n  /**\r\n  computes a point where two lines intersection\r\n  @param {L.Point} a: a first point of first line defined by two points\r\n  @param {L.Point} b: a second point of first line defined by two points\r\n  @param {L.Point} c: a first point of second line defined by two points\r\n  @param {L.Point} d: a first point of second line defined by two points\r\n  @returns {L.Point} :intersection point or null if lines are parallel to each other\r\n  */\r\n  lineIntersection:function(a,b,c,d){\r\n    var abc1=this.computeCanonicCoeffs(a,b),abc2 = this.computeCanonicCoeffs(c,d);\r\n    var denominator = abc1[0]*abc2[1] - abc2[0]*abc1[1];\r\n    if(denominator==0){\r\n      return;\r\n    }\r\n    var x = -(abc1[2]*abc2[1] - abc2[2]*abc1[1])/denominator;\r\n    var y = -(abc1[0]*abc2[2] - abc2[0]*abc1[2])/denominator;\r\n    return L.point(x,y);\r\n  },\r\n\r\n  /**\r\n    computes a  unit normal for [a,b] segment\r\n    @param {L.Point} a:\r\n    @param {L.Point} b:\r\n    @returns {L.point}: unit normal\r\n  */\r\n  getNormalOnSegment:function(a,b){\r\n    var abc=this.computeCanonicCoeffs(a,b);\r\n    var normal = L.point(abc[0],abc[1]);\r\n    return this.normalizePt(normal);\r\n  },\r\n\r\n  /**\r\n  Computes an euclidian length of point\r\n  @param {L.Point} pt:\r\n  @returns {Number}\r\n  */\r\n  get2dVectorLength:function(pt){\r\n    return Math.sqrt(pt.x*pt.x + pt.y*pt.y);\r\n  },\r\n\r\n  /**\r\n  Makes this point a unit-lengthed\r\n  @param {L.Point} pt:\r\n  @returns {L.Point}:\r\n  */\r\n  normalizePt:function(pt){\r\n    return (pt.x===0&&pt.y===0)?L.point(0,0):pt.divideBy(this.get2dVectorLength(pt));\r\n  },\r\n\r\n  /**\r\n  copies segment and translates copy in normal direction by height value (may be negative)\r\n  It also extands or shrinks new segments to make sure they are connected to each and other\r\n  @param {Array} polyline: polyline to translate segments of which\r\n  @param {Number} height:  height of normal\r\n  @returns {Array}: translated copy of polyline\r\n  */\r\n  translateByNormals:function(polyline,height){ //TODO [translateByNormals] not working properly - when segments are fully inside polygon\r\n    var out_polyline=[];\r\n    for(var i=0;i<polyline.length-1;i++){\r\n      var normal = this.getNormalOnSegment(polyline[i],polyline[i+1]).multiplyBy(height);\r\n      var current_segment=this.translateSegment(polyline[i],polyline[i+1],normal);\r\n      //now check if current segment is connected well to previous\r\n      if(i>0){ //so -> it isn't first segment, and out_polyline has at least two points\r\n        var pt_intersect = this.lineIntersection(out_polyline[out_polyline.length-2],out_polyline[out_polyline.length-1],current_segment[0],current_segment[1]);\r\n        out_polyline[out_polyline.length-1] = pt_intersect;\r\n        out_polyline.push(current_segment[1]);\r\n      }else{\r\n        out_polyline.push(current_segment[0]); out_polyline.push(current_segment[1]);\r\n      }\r\n    }\r\n    return out_polyline;\r\n  },\r\n\r\n  /**\r\n  code from L.GeometryUtil plugin\r\n  @memberof geomEssentials#\r\n  */\r\n  interpolateOnPointSegment: function (a,b, ratio) {\r\n      var res= L.point(\r\n          (a.x * (1 - ratio)) + (ratio * b.x),\r\n          (a.y * (1 - ratio)) + (ratio * b.y)\r\n      );\r\n      return res;\r\n  },\r\n\r\n  /**\r\n  Get a segment from polyline part by it's offset\r\n  @param {Number} offset: na offset for the polyline\r\n  @param {Array} polyline: points of the polyline\r\n  @param {Array} computed_lengths: precomputed lengths (if available) for polyline segments\r\n  @returns {Array} : index of start point of segment and dist which is offset from start of the line to the end of found segment\r\n  */\r\n  getSegmentIdxAndDistByOffset:function(offset,polyline,computed_lengths){\r\n    var cdist=0;\r\n    for(var i=0;i<polyline.length-1;i++){\r\n      cdist+=computed_lengths[i];\r\n      if(offset<=cdist){\r\n        return [i,cdist]\r\n      }\r\n    }\r\n  },\r\n\r\n  /**\r\n  NOT USED TOFIX [getIndexBasedOnTotalLengthRandom] remove?\r\n  based on https://blog.dotzero.ru/weighted-random-simple/\r\n  get a random element from segments array of the item, assuming it is sorted lengths ascending order\r\n  probability is higher for longer segment\r\n  @param {Array} polyline: points of the polyline\r\n  @param {Array} computed_lengths: precomputed lengths (if available) for polyline segments\r\n  @param {NUmber} totalLength: precomputed total length of the polyline\r\n  */\r\n  getIndexBasedOnTotalLengthRandom:function(polyline,computed_lengths,totalLength){\r\n    var random_pos = Math.random()*totalLength; //get a position random for all segments of this polyline visible on the screen\r\n    //obtain and index of segment, to which belongs this position, it is assumed tha segments are sorted by length\r\n    var clen=0;\r\n    for(var i=0;i<polyline.length-1;i++){\r\n      clen+=computed_lengths[i];\r\n      if(clen>random_pos)break;\r\n    }\r\n    return i;\r\n  },\r\n\r\n  /**\r\n  Supplement function for extractSubPolyline\r\n  returns start index, end index in segments array for item, also first cropped seg and last cropped seg.\r\n  If only one seg here, it is crop both ends.\r\n  @param {Number} offset_start: should be less than total length of polyline\r\n  @param {Number} offset_end: should be greater than offset_start\r\n  @param {Array} polyline: points of the polyline\r\n  @param {Array} computed_lengths: precomputed lengths (if available) for polyline segments\r\n  @returns {Object}:\r\n  */\r\n  extractSubPolyline:function(offset_start,offset_end,polyline,computed_lengths){\r\n    var start = this.getSegmentIdxAndDistByOffset(offset_start,polyline,computed_lengths),\r\n        end = this.getSegmentIdxAndDistByOffset(offset_end,polyline,computed_lengths),\r\n        start_point= this.interpolateOnPointSegment(polyline[start[0]],polyline[start[0]+1],(computed_lengths[start[0]]-start[1]+offset_start)/computed_lengths[start[0]]),\r\n        end_point = this.interpolateOnPointSegment(polyline[end[0]],polyline[end[0]+1],(computed_lengths[end[0]]-end[1]+offset_end)/computed_lengths[end[0]]),\r\n        result = [start_point];\r\n    for(var i=start[0]+1;i<=end[0];i++){ //push every point from end of start segment to segment prior to last\r\n      result.push(polyline[i]);\r\n    }\r\n    result.push(end_point);\r\n    return result;\r\n  },\r\n\r\n  /**\r\n  Used for calculationg overlaps for text along path (textPath SVG).\r\n  @param {Number} start_offset: global offset for this polyline (item), same as used in rendering\r\n  @param {Number} end_offset: global offset for this polyline (item), same as used in rendering\r\n  @param {LabelItem} item:\r\n  @returns {Array} : a poly bounding with height of item.txSize.y\r\n  */\r\n  computeLineBoundaryPolygon:function(polyline,height){\r\n    var lower_boundary = polyline.slice(0);\r\n    var upper_boundary=this.translateByNormals(polyline,height);\r\n    Array.prototype.push.apply(lower_boundary, upper_boundary.reverse());\r\n    this.polyLPointToArray(lower_boundary);\r\n    return lower_boundary;\r\n  },\r\n\r\n  /*\r\n  Converts poly of L.Point to poly of [x,y]. Note - original variable is to be modified\r\n  @param {Array} polyLPoint: poly to modify\r\n  **/\r\n  polyLPointToArray:function(polyLPoint){\r\n    for(var i=0;i<polyLPoint.length;i++)\r\n      polyLPoint[i] = [polyLPoint[i].x,polyLPoint[i].y];\r\n  },\r\n\r\n  /**\r\nfunction from https://rosettacode.org/wiki/Sutherland-Hodgman_polygon_clipping#JavaScript\r\n@param {Array} subjectPolygon: first poly\r\n@param {Array} clipPolygon: second poly\r\n@returns {Array} : result poly\r\n@memberof geomEssentials#\r\n*/\r\nclipPoly2:function(subjectPolygon, clipPolygon) {\r\n  var cp1, cp2, s, e;\r\n  var inside = function (p) {\r\n      return (cp2[0]-cp1[0])*(p[1]-cp1[1]) > (cp2[1]-cp1[1])*(p[0]-cp1[0]);\r\n  };\r\n  var intersection = function () {\r\n      var dc = [ cp1[0] - cp2[0], cp1[1] - cp2[1] ],\r\n          dp = [ s[0] - e[0], s[1] - e[1] ],\r\n          n1 = cp1[0] * cp2[1] - cp1[1] * cp2[0],\r\n          n2 = s[0] * e[1] - s[1] * e[0],\r\n          n3 = 1.0 / (dc[0] * dp[1] - dc[1] * dp[0]);\r\n      return [(n1*dp[0] - n2*dc[0]) * n3, (n1*dp[1] - n2*dc[1]) * n3];\r\n  };\r\n  var outputList = subjectPolygon;\r\n  cp1 = clipPolygon[clipPolygon.length-1];\r\n  for (var j in clipPolygon) {\r\n      var cp2 = clipPolygon[j];\r\n      var inputList = outputList;\r\n      outputList = [];\r\n      s = inputList[inputList.length - 1]; //last on the input list\r\n      for (var i in inputList) {\r\n          var e = inputList[i];\r\n          if (inside(e)) {\r\n              if (!inside(s)) {\r\n                  outputList.push(intersection());\r\n              }\r\n              outputList.push(e);\r\n          }\r\n          else if (inside(s)) {\r\n              outputList.push(intersection());\r\n          }\r\n          s = e;\r\n      }\r\n      cp1 = cp2;\r\n  }\r\n  return outputList\r\n},\r\n\r\nclipPoly:function(poly1,poly2){\r\n    var intersection = greinerHormann.intersection(poly1, poly2);\r\n    if(!intersection)return [];\r\n    if(intersection.length>0)return intersection[0];\r\n  },\r\n\r\n\r\n  /**\r\n  returns a combined poly from two\r\n  */\r\n  addPoly:function(poly1,poly2){\r\n    var union = greinerHormann.union(poly1, poly2);\r\n    if(!union)return [];\r\n    if(union.length>0)return union[0];\r\n  },\r\n\r\n  subtractPoly:function(poly1,poly2){\r\n    var diff = greinerHormann.diff(poly1, poly2);\r\n    if(!diff)return [];else return diff;\r\n  },\r\n\r\n  /**\r\n  code from http://www.codeproject.com/Articles/13467/A-JavaScript-Implementation-of-the-Surveyor-s-Form\r\n  for single polygon only, and no holes in\r\n  @param {Array} poly: a poly to determine area of\r\n  @memberof geomEssentials#\r\n  */\r\n  polyArea:function(poly) {\r\n    // Calculate the area of a polygon\r\n    // using the data stored\r\n    // in the arrays x and y\r\n    var area = 0.0;\r\n    if(poly){\r\n      var poly=poly.slice(0);\r\n      if(poly.length>2)poly.push(poly[0]); //close the poly\r\n      for(var k = 0; k < poly.length-1; k++ ) {\r\n          var xDiff = poly[k+1][0] - poly[k][0];\r\n          var yDiff = poly[k+1][1] - poly[k][1];\r\n          area += + poly[k][0] * yDiff - poly[k][1] * xDiff;\r\n      }\r\n      area = 0.5 * area;\r\n    }\r\n    return area;\r\n  },\r\n\r\n\r\n  /**\r\n  check if two labels overlab, if no returns false, if yes returns ???area OR polygon??? of averlap\r\n  @param {} poly1:a first polygon to check overlap with second\r\n  @param {} poly2:a second polygon to check overlap with first\r\n  @returns {float}: an area of overlapping, zero if no overlapping\r\n  */\r\n  checkOverLappingArea:function(poly1,poly2,calculateAreaNotOnlyFactOfOverlapping) {\r\n    var clipped = this.clipPoly(poly1,poly2);\r\n    if(calculateAreaNotOnlyFactOfOverlapping){\r\n      var area =this.polyArea(clipped);\r\n      return area;\r\n    };\r\n    if(clipped.length>0)return 1;else return 0; //for performance, skip area calculation\r\n  },\r\n\r\n  /**\r\n  rotates given polygon to a given angle around basepoint\r\n  code partialy from web, don't remember from...\r\n  @param {Array} poly: a polygon to rotate\r\n  @param {Array} basepoint: base point\r\n  @param {float} angle: an angle in degrees\r\n  @returns {Array}: rotated poly\r\n  @memberof geomEssentials#\r\n  */\r\n  rotatePoly:function(poly, basepoint,angle){\r\n    var res=[];\r\n    var angleRad = angle*Math.PI/180;\r\n    for(var i=0;i<poly.length;i++){\r\n      var pPoint = poly[i],\r\n      x_rotated = Math.cos(angleRad)*(pPoint[0]-basepoint[0]) - Math.sin(angleRad)*(pPoint[1]-basepoint[1]) + basepoint[0],\r\n      y_rotated = Math.sin(angleRad)*(pPoint[0]-basepoint[0]) + Math.cos(angleRad)*(pPoint[1]-basepoint[1]) + basepoint[1];\r\n      res.push([x_rotated,y_rotated]);\r\n    }\r\n    return res;\r\n  },\r\n\r\n  /**\r\n  moves a poly by adding pt2add point to all its vertices\r\n  @param {Array} poly: a poly to movePoly\r\n  @param {Array} pt2add: a point to add to all vertices\r\n  @returns {Array}: moved poly\r\n  @memberof geomEssentials#\r\n  */\r\n  movePolyByAdding:function(poly,pt2add) {\r\n    var res=poly.slice(0);\r\n    for(var i=0;i<poly.length;i++){\r\n      res[i][0]+=pt2add[0]; res[i][1]+=pt2add[1];\r\n    }\r\n    return res;\r\n  },\r\n\r\n  /**\r\n  moves a poly by translating all its vertices to moveto, using first vertex as origin\r\n  @param {Array} poly: a poly to movePoly\r\n  @param {Array} moveto: where translate all vertices\r\n  @returns {Array}: moved poly\r\n  @memberof geomEssentials#\r\n  */\r\n  movePolyByMovingTo:function(poly,moveto){\r\n    var res=poly.slice(0);\r\n    moveto[0] = moveto[0]-poly[0][0];\r\n    moveto[1] = moveto[1]-poly[0][1];\r\n    for(var i=1;i<poly.length;i++){\r\n      res[i][0]+=moveto[0]; res[i][1]+=moveto[1];\r\n    }\r\n    return res;\r\n  }\r\n}\r\n\r\nmodule.exports = geomEssentials;\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/geomEssentials.js\n ** module id = 3\n ** module chunks = 0\n **/","var clip = require('./clip');\r\n\r\nmodule.exports = {\r\n    /**\r\n     * @api\r\n     * @param  {Array.<Array.<Number>|Array.<Object>} polygonA\r\n     * @param  {Array.<Array.<Number>|Array.<Object>} polygonB\r\n     * @return {Array.<Array.<Number>>|Array.<Array.<Object>|Null}\r\n     */\r\n    union: function(polygonA, polygonB) {\r\n        return clip(polygonA, polygonB, false, false);\r\n    },\r\n\r\n    /**\r\n     * @api\r\n     * @param  {Array.<Array.<Number>|Array.<Object>} polygonA\r\n     * @param  {Array.<Array.<Number>|Array.<Object>} polygonB\r\n     * @return {Array.<Array.<Number>>|Array.<Array.<Object>>|Null}\r\n     */\r\n    intersection: function(polygonA, polygonB) {\r\n        return clip(polygonA, polygonB, true, true);\r\n    },\r\n\r\n    /**\r\n     * @api\r\n     * @param  {Array.<Array.<Number>|Array.<Object>} polygonA\r\n     * @param  {Array.<Array.<Number>|Array.<Object>} polygonB\r\n     * @return {Array.<Array.<Number>>|Array.<Array.<Object>>|Null}\r\n     */\r\n    diff: function(polygonA, polygonB) {\r\n        return clip(polygonA, polygonB, false, true);\r\n    },\r\n\r\n    clip: clip\r\n};\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/third_party/GreinerHormann/src/greiner-hormann.js\n ** module id = 4\n ** module chunks = 0\n **/","var Polygon = require('./polygon');\r\n\r\n/**\r\n * Clip driver\r\n * @api\r\n * @param  {Array.<Array.<Number>>} polygonA\r\n * @param  {Array.<Array.<Number>>} polygonB\r\n * @param  {Boolean}                sourceForwards\r\n * @param  {Boolean}                clipForwards\r\n * @return {Array.<Array.<Number>>}\r\n */\r\nmodule.exports = function(polygonA, polygonB, eA, eB) {\r\n    var result, source = new Polygon(polygonA),\r\n        clip = new Polygon(polygonB),\r\n        result = source.clip(clip, eA, eB);\r\n\r\n    return result;\r\n};\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/third_party/GreinerHormann/src/clip.js\n ** module id = 5\n ** module chunks = 0\n **/","var Vertex = require('./vertex');\r\nvar Intersection = require('./intersection');\r\n\r\n/**\r\n * Polygon representation\r\n * @param {Array.<Array.<Number>>} p\r\n * @param {Boolean=}               arrayVertices\r\n *\r\n * @constructor\r\n */\r\nvar Polygon = function(p, arrayVertices) {\r\n\r\n    /**\r\n     * @type {Vertex}\r\n     */\r\n    this.first = null;\r\n\r\n    /**\r\n     * @type {Number}\r\n     */\r\n    this.vertices = 0;\r\n\r\n    /**\r\n     * @type {Vertex}\r\n     */\r\n    this._lastUnprocessed = null;\r\n\r\n    /**\r\n     * Whether to handle input and output as [x,y] or {x:x,y:y}\r\n     * @type {Boolean}\r\n     */\r\n    this._arrayVertices = (typeof arrayVertices === \"undefined\") ?\r\n        Array.isArray(p[0]) :\r\n        arrayVertices;\r\n\r\n    for (var i = 0, len = p.length; i < len; i++) {\r\n        this.addVertex(new Vertex(p[i]));\r\n    }\r\n};\r\n\r\n/**\r\n * Add a vertex object to the polygon\r\n * (vertex is added at the 'end' of the list')\r\n *\r\n * @param vertex\r\n */\r\nPolygon.prototype.addVertex = function(vertex) {\r\n    if (this.first == null) {\r\n        this.first = vertex;\r\n        this.first.next = vertex;\r\n        this.first.prev = vertex;\r\n    } else {\r\n        var next = this.first,\r\n            prev = next.prev;\r\n\r\n        next.prev = vertex;\r\n        vertex.next = next;\r\n        vertex.prev = prev;\r\n        prev.next = vertex;\r\n    }\r\n    this.vertices++;\r\n};\r\n\r\n/**\r\n * Inserts a vertex inbetween start and end\r\n *\r\n * @param {Vertex} vertex\r\n * @param {Vertex} start\r\n * @param {Vertex} end\r\n */\r\nPolygon.prototype.insertVertex = function(vertex, start, end) {\r\n    var prev, curr = start;\r\n\r\n    while (!curr.equals(end) && curr._distance < vertex._distance) {\r\n        curr = curr.next;\r\n    }\r\n\r\n    vertex.next = curr;\r\n    prev = curr.prev;\r\n\r\n    vertex.prev = prev;\r\n    prev.next = vertex;\r\n    curr.prev = vertex;\r\n\r\n    this.vertices++;\r\n};\r\n\r\n/**\r\n * Get next non-intersection point\r\n * @param  {Vertex} v\r\n * @return {Vertex}\r\n */\r\nPolygon.prototype.getNext = function(v) {\r\n    var c = v;\r\n    while (c._isIntersection) {\r\n        c = c.next;\r\n    }\r\n    return c;\r\n};\r\n\r\n/**\r\n * Unvisited intersection\r\n * @return {Vertex}\r\n */\r\nPolygon.prototype.getFirstIntersect = function() {\r\n    var v = this._firstIntersect || this.first;\r\n\r\n    do {\r\n        if (v._isIntersection && !v._visited) {\r\n            break;\r\n        }\r\n\r\n        v = v.next;\r\n    } while (!v.equals(this.first));\r\n\r\n    this._firstIntersect = v;\r\n    return v;\r\n};\r\n\r\n/**\r\n * Does the polygon have unvisited vertices\r\n * @return {Boolean} [description]\r\n */\r\nPolygon.prototype.hasUnprocessed = function() {\r\n    var v = this._lastUnprocessed || this.first;\r\n    do {\r\n        if (v._isIntersection && !v._visited) {\r\n            this._lastUnprocessed = v;\r\n            return true;\r\n        }\r\n\r\n        v = v.next;\r\n    } while (!v.equals(this.first));\r\n\r\n    this._lastUnprocessed = null;\r\n    return false;\r\n};\r\n\r\n/**\r\n * The output depends on what you put in, arrays or objects\r\n * @return {Array.<Array<Number>|Array.<Object>}\r\n */\r\nPolygon.prototype.getPoints = function() {\r\n    var points = [],\r\n        v = this.first;\r\n\r\n    if (this._arrayVertices) {\r\n        do {\r\n            points.push([v.x, v.y]);\r\n            v = v.next;\r\n        } while (v !== this.first);\r\n    } else {\r\n        do {\r\n            points.push({\r\n                x: v.x,\r\n                y: v.y\r\n            });\r\n            v = v.next;\r\n        } while (v !== this.first);\r\n    }\r\n\r\n    return points;\r\n};\r\n\r\n/**\r\n * Clip polygon against another one.\r\n * Result depends on algorithm direction:\r\n *\r\n * Intersection: forwards forwards\r\n * Union:        backwars backwards\r\n * Diff:         backwards forwards\r\n *\r\n * @param {Polygon} clip\r\n * @param {Boolean} sourceForwards\r\n * @param {Boolean} clipForwards\r\n */\r\nPolygon.prototype.clip = function(clip, sourceForwards, clipForwards) {\r\n    var sourceVertex = this.first,\r\n        clipVertex = clip.first,\r\n        sourceInClip, clipInSource;\r\n\r\n    // calculate and mark intersections\r\n    do {\r\n        if (!sourceVertex._isIntersection) {\r\n            do {\r\n                if (!clipVertex._isIntersection) {\r\n                    var i = new Intersection(\r\n                        sourceVertex,\r\n                        this.getNext(sourceVertex.next),\r\n                        clipVertex, clip.getNext(clipVertex.next));\r\n\r\n                    if (i.valid()) {\r\n                        var sourceIntersection =\r\n                            Vertex.createIntersection(i.x, i.y, i.toSource),\r\n                            clipIntersection =\r\n                            Vertex.createIntersection(i.x, i.y, i.toClip);\r\n\r\n                        sourceIntersection._corresponding = clipIntersection;\r\n                        clipIntersection._corresponding = sourceIntersection;\r\n\r\n                        this.insertVertex(\r\n                            sourceIntersection,\r\n                            sourceVertex,\r\n                            this.getNext(sourceVertex.next));\r\n                        clip.insertVertex(\r\n                            clipIntersection,\r\n                            clipVertex,\r\n                            clip.getNext(clipVertex.next));\r\n                    }\r\n                }\r\n                clipVertex = clipVertex.next;\r\n            } while (!clipVertex.equals(clip.first));\r\n        }\r\n\r\n        sourceVertex = sourceVertex.next;\r\n    } while (!sourceVertex.equals(this.first));\r\n\r\n    // phase two - identify entry/exit points\r\n    sourceVertex = this.first;\r\n    clipVertex = clip.first;\r\n\r\n    sourceInClip = sourceVertex.isInside(clip);\r\n    clipInSource = clipVertex.isInside(this);\r\n\r\n    sourceForwards ^= sourceInClip;\r\n    clipForwards ^= clipInSource;\r\n\r\n    do {\r\n        if (sourceVertex._isIntersection) {\r\n            sourceVertex._isEntry = sourceForwards;\r\n            sourceForwards = !sourceForwards;\r\n        }\r\n        sourceVertex = sourceVertex.next;\r\n    } while (!sourceVertex.equals(this.first));\r\n\r\n    do {\r\n        if (clipVertex._isIntersection) {\r\n            clipVertex._isEntry = clipForwards;\r\n            clipForwards = !clipForwards;\r\n        }\r\n        clipVertex = clipVertex.next;\r\n    } while (!clipVertex.equals(clip.first));\r\n\r\n    // phase three - construct a list of clipped polygons\r\n    var list = [];\r\n\r\n    while (this.hasUnprocessed()) {\r\n        var current = this.getFirstIntersect(),\r\n            // keep format\r\n            clipped = new Polygon([], this._arrayVertices);\r\n\r\n        clipped.addVertex(new Vertex(current.x, current.y));\r\n        do {\r\n            current.visit();\r\n            if (current._isEntry) {\r\n                do {\r\n                    current = current.next;\r\n                    clipped.addVertex(new Vertex(current.x, current.y));\r\n                } while (!current._isIntersection);\r\n\r\n            } else {\r\n                do {\r\n                    current = current.prev;\r\n                    clipped.addVertex(new Vertex(current.x, current.y));\r\n                } while (!current._isIntersection);\r\n            }\r\n            current = current._corresponding;\r\n        } while (!current._visited);\r\n\r\n        list.push(clipped.getPoints());\r\n    }\r\n\r\n    if (list.length === 0) {\r\n        if (sourceInClip) {\r\n            list.push(this.getPoints());\r\n        }\r\n        if (clipInSource) {\r\n            list.push(clip.getPoints());\r\n        }\r\n        if (list.length === 0) {\r\n            list = null;\r\n        }\r\n    }\r\n\r\n    return list;\r\n};\r\n\r\nmodule.exports = Polygon;\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/third_party/GreinerHormann/src/polygon.js\n ** module id = 6\n ** module chunks = 0\n **/","/**\r\n * Vertex representation\r\n *\r\n * @param {Number|Array.<Number>} x\r\n * @param {Number=}               y\r\n *\r\n * @constructor\r\n */\r\nvar Vertex = function(x, y) {\r\n\r\n    if (arguments.length === 1) {\r\n        // Coords\r\n        if (Array.isArray(x)) {\r\n            y = x[1];\r\n            x = x[0];\r\n        } else {\r\n            y = x.y;\r\n            x = x.x;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * X coordinate\r\n     * @type {Number}\r\n     */\r\n    this.x = x;\r\n\r\n    /**\r\n     * Y coordinate\r\n     * @type {Number}\r\n     */\r\n    this.y = y;\r\n\r\n    /**\r\n     * Next node\r\n     * @type {Vertex}\r\n     */\r\n    this.next = null;\r\n\r\n    /**\r\n     * Previous vertex\r\n     * @type {Vertex}\r\n     */\r\n    this.prev = null;\r\n\r\n    /**\r\n     * Corresponding intersection in other polygon\r\n     */\r\n    this._corresponding = null;\r\n\r\n    /**\r\n     * Distance from previous\r\n     */\r\n    this._distance = 0.0;\r\n\r\n    /**\r\n     * Entry/exit point in another polygon\r\n     * @type {Boolean}\r\n     */\r\n    this._isEntry = true;\r\n\r\n    /**\r\n     * Intersection vertex flag\r\n     * @type {Boolean}\r\n     */\r\n    this._isIntersection = false;\r\n\r\n    /**\r\n     * Loop check\r\n     * @type {Boolean}\r\n     */\r\n    this._visited = false;\r\n};\r\n\r\n/**\r\n * Creates intersection vertex\r\n * @param  {Number} x\r\n * @param  {Number} y\r\n * @param  {Number} distance\r\n * @return {Vertex}\r\n */\r\nVertex.createIntersection = function(x, y, distance) {\r\n    var vertex = new Vertex(x, y);\r\n    vertex._distance = distance;\r\n    vertex._isIntersection = true;\r\n    vertex._isEntry = false;\r\n    return vertex;\r\n};\r\n\r\n/**\r\n * Mark as visited\r\n */\r\nVertex.prototype.visit = function() {\r\n    this._visited = true;\r\n    if (this._corresponding !== null && !this._corresponding._visited) {\r\n        this._corresponding.visit();\r\n    }\r\n};\r\n\r\n/**\r\n * Convenience\r\n * @param  {Vertex}  v\r\n * @return {Boolean}\r\n */\r\nVertex.prototype.equals = function(v) {\r\n    return this.x === v.x && this.y === v.y;\r\n};\r\n\r\n/**\r\n * Check if vertex is inside a polygon by odd-even rule:\r\n * If the number of intersections of a ray out of the point and polygon\r\n * segments is odd - the point is inside.\r\n * @param {Polygon} poly\r\n * @return {Boolean}\r\n */\r\nVertex.prototype.isInside = function(poly) {\r\n    var oddNodes = false,\r\n        vertex = poly.first,\r\n        next = vertex.next,\r\n        x = this.x,\r\n        y = this.y;\r\n\r\n    do {\r\n        if ((vertex.y < y && next.y >= y ||\r\n                next.y < y && vertex.y >= y) &&\r\n            (vertex.x <= x || next.x <= x)) {\r\n\r\n            oddNodes ^= (vertex.x + (y - vertex.y) /\r\n                (next.y - vertex.y) * (next.x - vertex.x) < x);\r\n        }\r\n\r\n        vertex = vertex.next;\r\n        next = vertex.next || poly.first;\r\n    } while (!vertex.equals(poly.first));\r\n\r\n    return oddNodes;\r\n};\r\n\r\nmodule.exports = Vertex;\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/third_party/GreinerHormann/src/vertex.js\n ** module id = 7\n ** module chunks = 0\n **/","/**\r\n * Intersection\r\n * @param {Vertex} s1\r\n * @param {Vertex} s2\r\n * @param {Vertex} c1\r\n * @param {Vertex} c2\r\n * @constructor\r\n */\r\nvar Intersection = function(s1, s2, c1, c2) {\r\n\r\n    /**\r\n     * @type {Number}\r\n     */\r\n    this.x = 0.0;\r\n\r\n    /**\r\n     * @type {Number}\r\n     */\r\n    this.y = 0.0;\r\n\r\n    /**\r\n     * @type {Number}\r\n     */\r\n    this.toSource = 0.0;\r\n\r\n    /**\r\n     * @type {Number}\r\n     */\r\n    this.toClip = 0.0;\r\n\r\n    var d = (c2.y - c1.y) * (s2.x - s1.x) - (c2.x - c1.x) * (s2.y - s1.y);\r\n\r\n    if (d === 0) {\r\n        return;\r\n    }\r\n\r\n    /**\r\n     * @type {Number}\r\n     */\r\n    this.toSource = ((c2.x - c1.x) * (s1.y - c1.y) - (c2.y - c1.y) * (s1.x - c1.x)) / d;\r\n\r\n    /**\r\n     * @type {Number}\r\n     */\r\n    this.toClip = ((s2.x - s1.x) * (s1.y - c1.y) - (s2.y - s1.y) * (s1.x - c1.x)) / d;\r\n\r\n    if (this.valid()) {\r\n        this.x = s1.x + this.toSource * (s2.x - s1.x);\r\n        this.y = s1.y + this.toSource * (s2.y - s1.y);\r\n    }\r\n};\r\n\r\n/**\r\n * @return {Boolean}\r\n */\r\nIntersection.prototype.valid = function() {\r\n    return (0 < this.toSource && this.toSource < 1) && (0 < this.toClip && this.toClip < 1);\r\n};\r\n\r\nmodule.exports = Intersection;\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/third_party/GreinerHormann/src/intersection.js\n ** module id = 8\n ** module chunks = 0\n **/","'use strict';\r\n\r\nvar geomEssentials = require(\"./geomEssentials.js\");\r\nvar autoLabelManager =require(\"./autoLabelManager.js\");\r\nvar candidateGenerator =require(\"./CandidateGenerator.js\");\r\n\r\nvar simulatedAnnealing =function(autoLabelMan,options) {\r\n  var result = {\r\n  aManager:autoLabelMan,\r\n\r\n  _overlapPair:function(i,j){\r\n\r\n  },\r\n\r\n  /**\r\n  summarizing ovelapping of all layers. We store for each label it's total overlapping area with others, the sum values for all labels\r\n  @param {Array}:curset:\r\n  @returns {Array}: values of areas, last is sum\r\n  @memberof MapAutoLabelSupport#\r\n  */\r\n  evaluateCurSet:function(){\r\n    for(var i in this.aManager.conflictMatrix){\r\n      var ij = this.aManager.conflictMatrix[i];\r\n      var curlabel_value = geomEssentials.checkOverLappingArea(this.aManager.curset[ij[0]].poly(),this.aManager.curset[ij[1]].poly(),false);\r\n      if(curlabel_value>0){\r\n        ij[2]++;\r\n        this.aManager.curvalues[i] = curlabel_value;\r\n      }\r\n    }\r\n    this.assignCostFunctionValuesToLastEl();\r\n  },\r\n\r\n  /**\r\n  may be a custom function, must add result as last value of input array\r\n  @param {Array} overlapping_values: input array of areas\r\n  */\r\n  assignCostFunctionValuesToLastEl:function(){\r\n    var res=0;\r\n    for(var i in this.aManager.curvalues)res+=this.aManager.curvalues[i];\r\n    this.aManager.curvalues.push(res);\r\n  },\r\n\r\n  /**\r\n  calculates total overlapping area with knowlesge of previous value and what label was moved, affects curvalues\r\n  */\r\n  evaluateAfterSeveralChanged:function(changedLabels) {\r\n    var counter=0; //index to iterate through curvalue array\r\n      for(var i=0;i<this.aManager.curset.length;i++){\r\n        var changedLabelIndex = (changedLabels[i])?i:-1;\r\n        for(var j=0;j<this.aManager.curset.length;j++)if(i>j){ //i,j like we used them in the evaluateCurSet function, so we get similar counter values\r\n          if(i===changedLabelIndex||j===changedLabelIndex){ //here we obtain all indexes of curvales array corresponding to changedLabelIndex\r\n            var area=geomEssentials.checkOverLappingArea(this.aManager.curset[i].poly(),this.aManager.curset[j].poly(),false); //and recalculate areas\r\n            this.aManager.curvalues[counter]=area;\r\n            }\r\n            counter++;\r\n          }\r\n      }\r\n    this.aManager.curvalues.pop(); //remove prev sum\r\n    this.assignCostFunctionValuesToLastEl();\r\n  },\r\n\r\n  dodebug:function(message){\r\n    if(this.options.debug)console.log(message);\r\n  },\r\n\r\n  processOptions:function(options){\r\n    this.options=options || {};\r\n    this.options.t0 = this.options.t0 || 2.5;\r\n    this.options.decrease_value = this.options.decrease_value || 0.9; //decrease by ten percent each decrease step\r\n    this.options.tmin = this.options.tmin || 0.0;\r\n    this.options.constant_temp_repositionings = this.options.constant_temp_repositionings || 10;\r\n    this.options.max_improvments_count = this.options.max_improvments_count || 10;\r\n    this.options.max_noimprove_count = this.options.max_noimprove_count || 20;\r\n    this.options.maxsteps = this.options.maxsteps || 100;\r\n    this.options.maxtotaliterations = this.options.maxtotaliterations || 1000;\r\n    this.options.minimizeTotalOverlappingArea=this.options.minimizeTotalOverlappingArea || false;\r\n    this.options.debug=this.options.debug || true;\r\n    this.options.allowBothSidesOfLine=this.options.allowBothSidesOfLine || true;\r\n    this.options.maxContiniousOverlapsForPair = this.options.maxOverlapsForPair || 50;\r\n  },\r\n\r\n  _doReturn:function(iterations){\r\n    this.aManager.markOveralppedLabels();\r\n    this.aManager.iterations=iterations;\r\n  },\r\n\r\n  /**\r\n  @param {Array} items: an arr with labels and their available line segments to place\r\n  @returns {Array}: first is computed label placement array, 2nd is overlapping graph for this array, third is number of iterations.\r\n  */\r\n  _doAnnealing:function(){\r\n    //init\r\n    this.aManager.getInitialRandomState(); //current label postions\r\n    this.evaluateCurSet(); //current overlaping matrix (conflict graph)\r\n    var t=this.options.t0, stepcount=0, doexit=this.aManager.overlap_count()=== 0,//if no overlaping at init state, do nothing and return current state\r\n        iterations=0;\r\n    while(true){\r\n      if(t<=this.options.tmin || stepcount>=this.options.maxsteps) return this._doReturn(iterations);\r\n      stepcount++;\r\n      var improvements_count=0, no_improve_count=0;\r\n      for(var i=0;i<this.options.constant_temp_repositionings*this.aManager.curset.length;i++){ //while constant temperature, do some replacments\r\n        this.aManager.saveOld();\r\n        this.aManager.applyNewPosToOverlappedLabels();\r\n        // this.evaluateAfterSeveralChanged(overlapped_indexes);\r\n        this.evaluateCurSet();\r\n        iterations++;\r\n        if(this.aManager.overlap_count() === 0){ return this._doReturn(iterations); }\r\n        if(iterations>this.options.maxtotaliterations){ return this._doReturn(iterations); }\r\n        var delta = (this.aManager.old_overlap_count() - this.aManager.overlap_count());\r\n        if(delta<0){//ie, new labeling is worse!\r\n          var P=1 - Math.exp(delta/t);\r\n          if(P>Math.random()){ //undo label reposition with probability of P\r\n            this.aManager.restoreOld();\r\n            no_improve_count++;\r\n          }else { //approve new repositioning\r\n            improvements_count++;\r\n            no_improve_count=0;\r\n          }\r\n        }else{\r\n           improvements_count++;\r\n           no_improve_count=0;\r\n         }\r\n        if(no_improve_count>=this.options.max_noimprove_count*this.aManager.curset.length){ //it is already optimal\r\n            return this._doReturn(iterations);\r\n        }\r\n        if(improvements_count>=this.options.max_improvments_count*this.aManager.curset.length){\r\n          break; //of for\r\n        }\r\n      }\r\n      t*=this.options.decrease_value; //decrease temp\r\n    };\r\n  },\r\n\r\n  /**\r\n  find optimal label placement based on simulated annealing approach, relies on paper https://www.eecs.harvard.edu/shieber/Biblio/Papers/jc.label.pdf\r\n  @param {Array} all_items: an arr with labels and their available line segments to place\r\n  @param {Object} options: TODO [simulatedAnnealing] add options description\r\n  @param {Object} callback: a function to gather results and use them to render\r\n  @param {Object} context: a parent conext of the function  above (arguments.callee - but deprecated)\r\n  */\r\n  perform:function(callback,context) {\r\n        if(this.aManager.isDegenerate()){callback([])} //do nothing if no segments\r\n        else{\r\n          var t0 = performance.now();\r\n          this._doAnnealing();\r\n          this.dodebug('overlapping labels count = '+this.aManager.countOverlappedLabels()+\r\n                       ', total labels count = '+this.aManager.curset.length+', iterations = '+this.aManager.iterations);\r\n          this.dodebug('time to annealing = '+(performance.now()-t0));\r\n          callback.call(context,this.aManager.curset);\r\n          }\r\n      }\r\n    }\r\n    result.processOptions(options);\r\n    return result;\r\n  }\r\n\r\n\r\nmodule.exports = simulatedAnnealing;\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/simulatedAnnealing.js\n ** module id = 9\n ** module chunks = 0\n **/","var candidateGenerator = require(\"./CandidateGenerator.js\");\r\nvar geomEssentials = require(\"./geomEssentials.js\");\r\n\r\nvar autoLabelManager = function(all_items){\r\n  var result = {\r\n    items:all_items,\r\n    curset:[],\r\n    curvalues:[],\r\n    conflictMatrix:[],\r\n    _oldvalues:[],\r\n    _oldset:[],\r\n    overlap_count:function(){\r\n      return (this.curvalues.length>0)?this.curvalues[this.curvalues.length-1]:0;\r\n    },\r\n\r\n    isDegenerate:function(){\r\n      return this.items.length ==0;\r\n    },\r\n\r\n    saveOld:function(){\r\n      this._oldvalues = this.curvalues.slice(0);\r\n      this._oldset = this.curset.slice(0);\r\n    },\r\n\r\n    restoreOld:function(){\r\n      this.curvalues = this._oldvalues;\r\n      this.curset = this._oldset;\r\n    },\r\n\r\n    old_overlap_count:function(){\r\n      return (this._oldvalues.length>0)?this._oldvalues[this._oldvalues.length-1]:0;\r\n    },\r\n    /**\r\n    computes the random set of positions for text placement with angles and text values\r\n    @param {Array} all_items: an array with {t,segs} elements, according to t -text of the polyline, segs - its accepted segments to label on. Result array is generated from items of aMan array\r\n    @returns {Array} : an array with elements such as return values of computeLabelCandidate function\r\n    */\r\n    getInitialRandomState:function(){\r\n      this.compConflictMatrix();\r\n      this.curset=[];\r\n      for(var i=0;i<this.items.length;i++){\r\n        var candidate = candidateGenerator.computeLabelCandidate(i,this.items);\r\n        this.curset.push(candidate);\r\n      }\r\n    },\r\n\r\n    _testPossibleFitting:function(ind1,ind2){\r\n      //TODO\r\n      return true;\r\n    },\r\n\r\n    /**\r\n    Divides all_items into clusters (or builds a graph), such as:\r\n    cluster consists of items with potential label intersections, which are computed by intersecting each item's boundaries (itemPoly)\r\n    Also: if free-of-intersections part of item's poly is capable for containing item's label, then such item is moved to separate cluster\r\n    with only aMan item -> no further computation for aMan item at all\r\n    After finishing clustering -> we applying simulatedAnnealing to each cluster independently, and thus, potentially, we\r\n    decrease degree of a problem.\r\n    @param {Array} all_items:\r\n    @returns {Array}: two-dim array if clusters first level, indices of items secodn level.\r\n    */\r\n    compConflictMatrix:function(){\r\n      this.conflictMatrix=[];\r\n      //no need to intersect i,j items and j,i items\r\n      //TODO mark items which overlaps anyway\r\n      for(var i in this.items){\r\n        for(var j in this.items)if(i>j){\r\n          var curClip=geomEssentials.clipPoly(this.items[i].getItemPoly(),this.items[j].getItemPoly());\r\n          if(curClip.length>0 && this._testPossibleFitting(i,j)){\r\n            this.conflictMatrix.push([i,j,0]);//i,j,overlapCount for this pair\r\n            this.curvalues.push(0);\r\n          }\r\n        }\r\n      }\r\n    },\r\n\r\n    markOveralppedLabels:function(){\r\n        for(var i in this.conflictMatrix){\r\n          if(this.curvalues[i]>0){\r\n            var ij = this.conflictMatrix[i];\r\n            this.curset[ij[0]].overlaps = true;\r\n            this.curset[ij[1]].overlaps = true;\r\n          }\r\n        }\r\n    },\r\n\r\n    countOverlappedLabels:function(){\r\n      var result=0;\r\n      this.markOveralppedLabels();\r\n      for(var i in this.curset)if(this.curset[i].overlaps){\r\n        this.curset[i].overlaps=false;\r\n        result++;\r\n      }\r\n      return result;\r\n    },\r\n\r\n    /**\r\n    swaps position for a random label with another from this label's positions pool\r\n    @param {Number} index : index of label in all_items to select new random position from availavle choices.\r\n    @param {Array} curset: currently selected label postions\r\n    @param {Array} all_items: all available postions\r\n    @memberof MapAutoLabelSupport#\r\n    */\r\n    swapCandidateInLabelSetToNew:function(idx){\r\n      var label_index = this.curset[idx].all_items_index();\r\n      var new_candidate = candidateGenerator.computeLabelCandidate(label_index,this.items);\r\n      this.curset[idx]=new_candidate;\r\n    },\r\n\r\n    applyNewPosToOverlappedLabels:function(){\r\n      this.markOveralppedLabels();\r\n      for(var i in this.curset){\r\n        if(this.curset[i].overlaps){\r\n          this.swapCandidateInLabelSetToNew(i);\r\n          this.curset[i].overlaps=false;\r\n        }\r\n      }\r\n    }\r\n  };\r\n  return result;\r\n}\r\n\r\nmodule.exports = autoLabelManager;\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/autoLabelManager.js\n ** module id = 10\n ** module chunks = 0\n **/","var geomEssentials = require('./geomEssentials.js');\r\nvar itemFactory = require('./LabelItem.js');\r\n\r\nvar candidateGenerator = {\r\n  options:{\r\n    lineDiscreteStepPx:3\r\n  },\r\n\r\n  obtainCandidateForPoint:function(point){\r\n    //TODO[obtainCandidateForPoint]\r\n  },\r\n\r\n  obtainCandidateForPoly:function(polygon){\r\n    //TODO[obtainCandidateForPoly]\r\n  },\r\n\r\n  /**\r\n  Get a poly (simple with no text along path)for random offset on the polyline\r\n  @param {Object} item: item from prepareCurSegments's allsegs\r\n  @returns {Array} : a poly bounding text, placed on corresponding point for offset on poluline and rotated to match segment's skew\r\n  */\r\n  obtainCandidateForPolyLineByRandomStartOffset:function(item){\r\n    var random_offset =(item.totalLength - item.txSize.x>0) ?  (item.totalLength - item.txSize.x)*Math.random():0;\r\n    var candidate = itemFactory.candidatePosition(random_offset,item);\r\n    return candidate;\r\n  },\r\n\r\n  /**\r\n  computes label candidate object to place on map\r\n  @param {Number} i: an index in all_items array to obtain label candidate for i-item\r\n  @returns {candidatePosition} : generated candidate\r\n  */\r\n  computeLabelCandidate:function(i,all_items) {\r\n    var candidate;\r\n    switch (all_items[i].layer_type()) {\r\n      case 0:\r\n        break;\r\n      case 1:{\r\n          candidate=this.obtainCandidateForPolyLineByRandomStartOffset(all_items[i]);\r\n          break;\r\n        }\r\n      case 2:\r\n        break;\r\n    }\r\n    return candidate;\r\n  },\r\n}\r\n\r\nmodule.exports = candidateGenerator;\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/CandidateGenerator.js\n ** module id = 11\n ** module chunks = 0\n **/","/*\r\nmodlue to create labelItems convenient for labelling and calculation\r\n*/\r\n\r\nvar geomEssentials = require('./geomEssentials.js');\r\n\r\nmodule.exports = {\r\n  /**\r\n  a factory function for label items\r\n  @param {String} text:\r\n  @param {String} style: text style\r\n  @param {L.Point} txSize: size of bounding box for txNode\r\n  @param {L.Layer} layer: a feature (Marker, Polyline, Path) to aquire data\r\n  */\r\n  labelItem:function(text,style,txSize,layer,hostArray){\r\n    var basic_item= {\r\n      data:[],\r\n      text:text,\r\n      style:style,\r\n      txSize:txSize,\r\n      layer:layer,\r\n      host:hostArray,\r\n      _itemPoly:false, //all available textlabel positions for this label\r\n      ignoreWhileLabel:false,\r\n      index:function(){\r\n        return this.host.lastIndexOf(this);\r\n      },\r\n      readData:function(){return false}, //a method stub,\r\n      layer_type:function(){\r\n        //TOFIX for polygon\r\n        if(!this._layer_type)this._layer_type = (this.layer._parts.length>0)?1:0;\r\n        return this._layer_type;\r\n      },\r\n\r\n      _getBoundary:function(){return false;}, //a method stub, to obtain polygon with all postions\r\n      applyFeatureData:function(){}, //a method stub\r\n\r\n      /**\r\n      get all available positions for this item. Depending on layer_type -> diff funcs.\r\n      Used in clustering computation\r\n      */\r\n      getItemPoly:function(){\r\n        if(!this._itemPoly){\r\n          this._itemPoly =  this._getBoundary();\r\n        }\r\n        return this._itemPoly;\r\n      }\r\n    };\r\n\r\n    //Not a very proper way to do such deal\r\n    if(basic_item.layer_type()==0){\r\n      return;\r\n      basic_item.readData = function(){\r\n        if(basic_item.layer.getLatLngs())\r\n        basic_item.data=basic_item.layer._map.latLngToLayerPoint(basic_item.layer.getLatLngs()[0]); //so we adding only L.Point obj\r\n      }\r\n    }else{\r\n      if(basic_item.layer._parts.length==0)return;\r\n      basic_item.computed_lengths=[];\r\n      basic_item.totalLength=0;\r\n      //this give possibility to read all parts to separate items\r\n      basic_item.readData=function(partIndex){ //to read consequently\r\n        if(!partIndex){var partIndex=0;};\r\n        var nextPart = partIndex;\r\n        this.data = this.layer._parts[partIndex];\r\n        this.partIndex=partIndex; //store this to have ability to compute totalOffset, for example\r\n        //while(nextPart<this.layer._parts.length){\r\n        // NEEDS TO BE FINISHED\r\n        var nextPart=partIndex+1;\r\n        if(nextPart<this.layer._parts.length){\r\n          var notClonedNow=true;\r\n          while((this.layer._parts[partIndex][this.layer._parts[partIndex].length-1].distanceTo(this.layer._parts[nextPart][0])<5)\r\n                 &&(nextPart+1<this.layer._parts.length)){\r\n            if(notClonedNow)this.data = this.layer._parts[partIndex].slice(0);\r\n            Array.prototype.push.apply(this.data, this.layer._parts[nextPart].slice(0));\r\n            partIndex++;\r\n            nextPart++;\r\n          }\r\n          return nextPart;\r\n        }else return false;\r\n      }\r\n\r\n      basic_item.segCount = function(){return this.data.length -1};\r\n\r\n      /**\r\n      Get a segment from polyline part by it's offset\r\n      @param {Number} offset: na offset for the polyline\r\n      @returns {Array} : index of start point of segment and dist which is offset from start of the line to the end of found segment\r\n      */\r\n      basic_item.getSegmentIdxAndDistByOffset=function(offset){\r\n        return geomEssentials.getSegmentIdxAndDistByOffset(offset,this.data,this.computed_lengths);\r\n      }\r\n\r\n      basic_item._getBoundary = function(){\r\n        return geomEssentials.computeLineBoundaryPolygon(this.data,this.txSize.y);\r\n      }\r\n\r\n      /**\r\n      Calculates total length for this polyline on screen, and lengths of each segments with their angles\r\n      @param {labelItem} item: an item to get above data to\r\n      */\r\n      basic_item.applyFeatureData=function(){\r\n        this.totalLength=0;\r\n        this.computed_lengths = geomEssentials.computeSegmentsLengths(this.data);\r\n        for(var k=0;k<this.computed_lengths.length;k++){\r\n          this.totalLength+=this.computed_lengths[k];\r\n        }\r\n        this.ignoreWhileLabel=this.totalLength<this.txSize.x;\r\n      }\r\n\r\n    }\r\n\r\n    return basic_item;\r\n  },\r\n\r\n  candidatePosition:function(offset_or_origin,item){\r\n    return {\r\n      _item:item,\r\n      offset_or_origin:offset_or_origin,\r\n      _poly:false,\r\n      all_items_index:function(){\r\n        return this._item.index();\r\n      },\r\n\r\n      /**\r\n      Used for calculationg overlaps for text along path (textPath SVG).\r\n      TODO avoid or smooth sharp angles to keep text fully visible \r\n      @param {Number} start_offset: global offset for this polyline (item), same as used in rendering\r\n      @param {LabelItem} item:\r\n      @returns {Array} : a poly bounding curved text\r\n      */\r\n      _computePolyForLine:function(){\r\n        var subPolyline = geomEssentials.extractSubPolyline(\r\n          this.offset_or_origin,\r\n          this.offset_or_origin + this._item.txSize.x,\r\n          this._item.data,this._item.computed_lengths);\r\n        return geomEssentials.computeLineBoundaryPolygon(subPolyline,item.txSize.y);\r\n      },\r\n\r\n      /**\r\n      common function switch for computing poly for different layer_types\r\n\r\n      */\r\n      _computePoly:function(){\r\n        switch(item.layer_type()){\r\n          case 0:break;\r\n          case 1:{\r\n              this._poly = this._computePolyForLine();\r\n            }\r\n          case 2:break;\r\n        }\r\n      },\r\n\r\n      poly:function(){\r\n        if(!this._poly)this._computePoly();\r\n        return this._poly;\r\n      }\r\n    }\r\n  },\r\n\r\n}\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/LabelItem.js\n ** module id = 12\n ** module chunks = 0\n **/","/**\r\nModule to extract sufficient info to label data on the map\r\n*/\r\n\r\n\"use strict\";\r\n\r\nvar DOMEssentials = require(\"./DOMEssentials.js\");\r\nvar geomEssentials = require(\"./geomEssentials.js\");\r\nvar itemFactory = require('./LabelItem.js');\r\n\r\nvar dataReader = {\r\n  /**\r\n  creates an array of features's segments for each feature  of layers2label's layers on screen along with SVG text corresponding to\r\n  @returns [Array] returns an array with values : {t:{content_node:SVG textnode},parts:feature parts,layertype}, then, in next funcs we add apoly param to t object, ir, its bounding polygon, layertype = 0 marker, 1 polyline, 2 polygon\r\n  */\r\n  readDataToLabel:function(){\r\n    var pt  =[],count=0;\r\n    if(this._map){\r\n      for(var i in this._map.autoLabeler._layers2label)\r\n      if(this._map.getZoom()>this._map.autoLabeler._layers2label[i]._al_options.zoomToStartLabel)\r\n      {\r\n        var lg=this._map.autoLabeler._layers2label[i],\r\n            map_to_add = this._map;\r\n        lg.eachLayer(function(layer){\r\n          if(layer.feature)\r\n          if(layer.feature.properties[lg._al_options.propertyName]){\r\n            var text=layer.feature.properties[lg._al_options.propertyName],\r\n                style=lg._al_options.labelStyle,\r\n                node = DOMEssentials.createSVGTextNode(text,style),\r\n                size = DOMEssentials.getBoundingBox(map_to_add,node); //compute ortho aligned bbox for this text, only once, common for all cases\r\n            if(layer._path)if(layer._parts.length>0){\r\n              var id = 'pathautolabel-' + L.Util.stamp(layer);\r\n              layer._path.setAttribute('id',id);\r\n              layer.feature.properties.alabel_offset=\"\";\r\n              count++;\r\n            }\r\n            var firstItem = itemFactory.labelItem(text,style,size,layer,pt)\r\n            if(firstItem){\r\n              //TOOO [readData] if last point of prev part is equal to fisrt of next part -> use one item for these\r\n              var nextPartIndex=firstItem.readData();\r\n              pt.push(firstItem);\r\n              while(nextPartIndex){\r\n                var item = itemFactory.labelItem(text,style,size,layer,pt); //create node template\r\n                nextPartIndex=item.readData(nextPartIndex);\r\n                pt.push(item);\r\n              }\r\n            }\r\n          }\r\n        });\r\n      }\r\n    }\r\n    return pt;\r\n  },\r\n\r\n  /**\r\n  extracts good segments from available polyline parts and converts to use in next procedures of pos estimation\r\n  @param {Array} all_items:\r\n  @param {Set} options: options are:  {integer} maxlabelcount: if more labels in all_items, then do nothing\r\n  */\r\n  prepareCurSegments:function(all_items,options){\r\n    options = options || {};\r\n    options.maxlabelcount=options.maxlabelcount || 100;\r\n    if(all_items.length>options.maxlabelcount || all_items.length==0){\r\n      this._map.autoLabeler._dodebug('too much OR no labels to compute('+all_items.length+')');\r\n      return false;\r\n    }\r\n    var i=all_items.length-1;\r\n    while(i>=0)\r\n    {\r\n      all_items[i].applyFeatureData();\r\n      if(all_items[i].ignoreWhileLabel)all_items.splice(i,1); //remove if item does not suit it's label for some reason\r\n      i--;\r\n    }\r\n    return true;\r\n  },\r\n}\r\n\r\nmodule.exports = dataReader;\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/DataReader.js\n ** module id = 13\n ** module chunks = 0\n **/"],"sourceRoot":""}