{"version":3,"sources":["webpack:///webpack/bootstrap 315f361d865b95e5a31d","webpack:///./src/MapPart.js","webpack:///./src/autoLabeler.js","webpack:///./src/DOMEssentials.js","webpack:///./src/geomEssentials.js","webpack:///./src/third_party/GreinerHormann/src/greiner-hormann.js","webpack:///./src/third_party/GreinerHormann/src/clip.js","webpack:///./src/third_party/GreinerHormann/src/polygon.js","webpack:///./src/third_party/GreinerHormann/src/vertex.js","webpack:///./src/third_party/GreinerHormann/src/intersection.js","webpack:///./src/simulatedAnnealing.js","webpack:///./src/CandidateGenerator.js","webpack:///./src/DataReader.js","webpack:///./src/LabelItem.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;ACtCA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;;AAGL;AACA;AACA;AACA,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA,uEAAsE,iBAAiB,kBAAkB,EAAE;AAC3G;AACA,yDAAwD;AACxD;AACA;AACA,MAAK;;AAEL;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX,QAAO;;AAEP,EAAC;;;;;;;AClED;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,oCAAmC;AACnC,kDAAiD;AACjD,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA0C,sBAAsB;AAChE,yCAAwC,sBAAsB;AAC9D;AACA,MAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA8D,kBAAkB;AAChF;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;;AAGL;AACA;AACA;AACA;AACA,kCAAiC;AACjC;AACA;AACA;AACA,uDAAsD,iBAAiB;AACvE;AACA;AACA;AACA;AACA,gDAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,mBAAkB,cAAc;AAChC;AACA;AACA;AACA;AACA,8CAA6C,kBAAkB,eAAe;AAC9E;AACA,oDAAmD,kBAAkB,eAAe;AACpF;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,qDAAoD;AACpD,mBAAkB,qBAAqB,KAAK;AAC5C;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,wDAAuD;AACvD,0BAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAA+B;AAC/B;AACA;AACA;AACA;AACA,sCAAqC;AACrC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;AC3LA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAU,cAAc;AACxB,aAAY;AACZ;AACA;AACA;AACA;AACA,2CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,WAAU,OAAO;AACjB,WAAU,OAAO;AACjB,aAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,WAAU,OAAO;AACjB,WAAU,OAAO;AACjB,aAAY,SAAS;AACrB;AACA;AACA,yCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;;;;;;;ACnDA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAgD,SAAS;AACzD;AACA,sCAAqC,cAAc;AACnD;AACA,qBAAoB,UAAU;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,WAAU,MAAM;AAChB,WAAU,MAAM;AAChB,aAAY,MAAM;AAClB;AACA;AACA;AACA;AACA,iBAAgB,cAAc;AAC9B,4BAA2B;AAC3B;AACA;AACA,IAAG;;AAEH;AACA;AACA,WAAU,MAAM;AAChB,WAAU,MAAM;AAChB,aAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB,cAAc;AAC9B,4BAA2B;AAC3B;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB,OAAO;AAC5B;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA,iBAAgB,QAAQ;AACxB,iBAAgB,QAAQ;AACxB,mBAAkB,OAAO;AACzB;AACA;AACA;AACA;AACA,eAAc;AACd,IAAG;;AAEH;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,WAAU,MAAM;AAChB,WAAU,MAAM;AAChB,YAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,WAAU,MAAM;AAChB,WAAU,OAAO;AACjB,YAAW,MAAM;AACjB;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,WAAU,MAAM;AAChB,WAAU,MAAM;AAChB,aAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,wBAAuB;AACvB,IAAG;;AAEH;AACA;AACA;AACA,WAAU,MAAM;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA0C;AAC1C,qBAAoB,mBAAmB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA,WAAU,MAAM;AAChB,WAAU,MAAM;AAChB,WAAU,MAAM;AAChB,aAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA,iBAAgB,cAAc;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;;AAEA;;AAEA;;;;;;;AC3RA;;AAEA;AACA;AACA;AACA,iBAAgB,qCAAqC;AACrD,iBAAgB,qCAAqC;AACrD,iBAAgB;AAChB;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,iBAAgB,qCAAqC;AACrD,iBAAgB,qCAAqC;AACrD,iBAAgB;AAChB;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,iBAAgB,qCAAqC;AACrD,iBAAgB,qCAAqC;AACrD,iBAAgB;AAChB;AACA;AACA;AACA,MAAK;;AAEL;AACA;;;;;;;AClCA;;AAEA;AACA;AACA;AACA,aAAY,uBAAuB;AACnC,aAAY,uBAAuB;AACnC,aAAY,QAAQ;AACpB,aAAY,QAAQ;AACpB,aAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;ACjBA;AACA;;AAEA;AACA;AACA,YAAW,uBAAuB;AAClC,YAAW,SAAS;AACpB;AACA;AACA;AACA;;AAEA;AACA,eAAc;AACd;AACA;;AAEA;AACA,eAAc;AACd;AACA;;AAEA;AACA,eAAc;AACd;AACA;;AAEA;AACA,wDAAuD;AACvD,eAAc;AACd;AACA;AACA;AACA;;AAEA,oCAAmC,SAAS;AAC5C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAY,OAAO;AACnB,aAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA,aAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAS;AACT,MAAK;AACL;AACA;AACA;AACA;AACA,cAAa;AACb;AACA,UAAS;AACT;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,QAAQ;AACnB,YAAW,QAAQ;AACnB,YAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;;AAEA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;;AAEjB,cAAa;AACb;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA,UAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;AC/RA;AACA;AACA;AACA,YAAW,sBAAsB;AACjC,YAAW,QAAQ;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;AACA;;AAEA;AACA;AACA,aAAY,OAAO;AACnB,aAAY,OAAO;AACnB,aAAY,OAAO;AACnB,aAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAY,OAAO;AACnB,aAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,QAAQ;AACnB,aAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;;AAEA;;;;;;;AC1IA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB;AACA;AACA;;AAEA;AACA,eAAc;AACd;AACA;;AAEA;AACA,eAAc;AACd;AACA;;AAEA;AACA,eAAc;AACd;AACA;;AAEA;AACA,eAAc;AACd;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,eAAc;AACd;AACA;;AAEA;AACA,eAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAY;AACZ;AACA;AACA;AACA;;AAEA;;;;;;;AC3DA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,WAAU,MAAM,yBAAyB,OAAO;AAChD,aAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,YAAW;AACX,YAAW;AACX,aAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAiC,cAAc;AAC/C,IAAG;;AAEH;AACA;AACA,WAAU,MAAM;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,WAAU,MAAM;AAChB,aAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,yBAAwB;AACxB;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,WAAU,OAAO;AACjB,WAAU,MAAM;AAChB,WAAU,MAAM;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA,WAAU,MAAM;AAChB,WAAU,MAAM;AAChB,WAAU,OAAO;AACjB,aAAY,MAAM;AAClB;AACA;AACA;AACA,mBAAkB;AAClB;AACA;AACA,mBAAkB,gBAAgB;AAClC,qBAAoB,gBAAgB,KAAK,QAAQ;AACjD,4DAA2D;AAC3D,yHAAwH;AACxH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAoB;AACpB;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA,sEAAqE;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sIAAqI;AACrI,IAAG;;AAEH;AACA;AACA,WAAU,MAAM;AAChB,WAAU,OAAO;AACjB,WAAU,OAAO;AACjB,WAAU,OAAO;AACjB;AACA;AACA,8BAA6B,aAAa;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAwB,0DAA0D;AAClF,kDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAsD;AACtD;AACA;AACA;AACA;AACA,8DAA6D;AAC7D;AACA;AACA;AACA;AACA,2BAA0B;AAC1B;AACA,qCAAoC;AACpC;AACA;AACA;AACA,kBAAiB,MAAM;AACvB;AACA;AACA;AACA,gBAAe;AACf;AACA;AACA;AACA,oFAAmF;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;ACnQA;AACA;;AAEA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA,0BAAyB,qBAAqB,cAAc;AAC5D;AACA;AACA,qFAAoF;AACpF,aAAY;AACZ,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAwF;AACxF;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,sDAAqD;AACrD;AACA;AACA,iBAAgB,mBAAmB;AACnC;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,WAAU,OAAO;AACjB,WAAU,OAAO;AACjB,aAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB;AAChB;AACA;AACA,aAAY;AACZ,IAAG;;AAEH;AACA;AACA,WAAU,OAAO;AACjB,aAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,WAAU,OAAO;AACjB,WAAU,OAAO;AACjB,aAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wDAAuD;AACvD;AACA;AACA;AACA;AACA,eAAc;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAsC,oBAAoB;AAC1D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAiB;AACjB,wJAAuJ;AACvJ;AACA;AACA,iBAAgB,sBAAsB;AACtC;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,oBAAmB;AACnB,kCAAiC,sBAAsB;AACvD;AACA;AACA;AACA;;AAEA,iBAAgB;AAChB,IAAG;AACH;AACA;AACA,WAAU,OAAO;AACjB,aAAY,OAAO,mBAAmB,2BAA2B;AACjE;AACA;AACA,4BAA2B;AAC3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,+FAA8F;AAC9F;AACA,aAAY;AACZ,IAAG;AACH;;AAEA;;;;;;;ACrMA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,oDAAmD,GAAG,0BAA0B,+BAA+B;AAC/G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAqE;AACrE;AACA;AACA;AACA,iEAAgE;AAChE;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,WAAU,MAAM;AAChB,WAAU,IAAI,yBAAyB,QAAQ;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB,mBAAmB;AACnC;AACA,gCAA+B;AAC/B;AACA;AACA;AACA;AACA,0CAAyC;AACzC;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,WAAU,UAAU;AACpB;AACA,wCAAuC;AACvC;AACA,mBAAkB,mBAAmB;AACrC;AACA;AACA,6DAA4D;AAC5D,4BAA2B,2BAA2B;AACtD;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;;AAEA;;;;;;;AC5FA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAU,SAAS;AACnB,WAAU,QAAQ;AAClB,WAAU,QAAQ;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,4BAA2B;AAC3B,6BAA4B;AAC5B;AACA;AACA;AACA;AACA;;AAEA;AACA,oEAAmE;AACnE,MAAK;AACL;AACA,+CAA8C;AAC9C,wBAAuB;AACvB;AACA,kCAAiC;AACjC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH","file":"l.autolabelSA.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"./\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 315f361d865b95e5a31d\n **/","(function () {\r\n  \"use strict\";\r\n\r\n  var autoLabeler = require('./autoLabeler.js');\r\n\r\n  var __onRemove = L.LayerGroup.prototype.onRemove;\r\n  //to include in LabelGroup\r\n  var AutoLabelingSupport = {\r\n      /**\r\n      handle removing layer from the map\r\n      */\r\n      onRemove: function (map) {\r\n      this.disableAutoLabel();\r\n        __onRemove.call(this, map);\r\n    },\r\n\r\n\r\n    /**\r\n     enable autolabeling for this layerGroup, additionally set the current_map variable if it is undefined and hooks label painting on moveend /zoomend events\r\n     it adds this layerGroup to the _layers2label array, so _doAutoLabel function will know about this layerGroup\r\n     @param {Object} options: labelStyle - css string to describe labels look, for now one for all layers in group, propertyName - a property from layer.feature.properties which we label on map\r\n    */\r\n    enableAutoLabel:function(options){\r\n      if(!this._map)return;\r\n      if(!this._map.autoLabeler)return;\r\n      this._al_options = options || {};\r\n      this._al_options.labelStyle = options.labelStyle || \"fill: lime; stroke: #000000;  font-size: 20px;\"; //TODO [enableAutoLabel] add ability to set unique style for each feature\r\n      this._al_options.propertyName = options.propertyName || \"name\";\r\n      this._al_options.priority = options.priority || 0; //highest\r\n      this._al_options.zoomToStartLabel = options.zoomToStartLabel || this._map.autoLabeler.options.zoomToStartLabel;\r\n      this._map.autoLabeler.addLayer(this);\r\n    },\r\n\r\n    /**\r\n    Obtain autlabelling state for this layerGroup\r\n    @returns {Boolean}\r\n    */\r\n    autoLabelEnabled:function(){\r\n      if(!this._map.autoLabeler)return false;\r\n      return this._map.autoLabeler.hasLayer(this);\r\n    },\r\n\r\n    /**\r\n    disable autolabelling\r\n    */\r\n    disableAutoLabel:function(){\r\n      if(!this._map.autoLabeler){\r\n        delete this._al_options;\r\n        return;\r\n      }\r\n      if(this._map.autoLabeler.remLayer(this)){\r\n        delete this._al_options;\r\n      }\r\n    }\r\n  }\r\n\r\n  L.LayerGroup.include(AutoLabelingSupport);\r\n\r\n  L.Map.addInitHook(function () {\r\n          this.whenReady(function () {\r\n              if (this.options.autolabel) {\r\n                this.autoLabeler = L.autoLabeler(this,this.options.autolabelOptions)\r\n              }\r\n          });\r\n      });\r\n\r\n})();\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/MapPart.js\n ** module id = 0\n ** module chunks = 0\n **/","var DOMEssentials = require('./DOMEssentials.js');\r\nvar geomEssentials = require('./geomEssentials.js');\r\nvar simulatedAnnealing = require('./simulatedAnnealing.js');\r\nvar dataReader = require('./DataReader.js');\r\n\r\nL.AutoLabeler = L.Evented.extend(\r\n {\r\n    _nodes:[], //an array for storing SVG node to draw while autolabelling\r\n    _layers2label:[], //an array to know which layergroups are to label\r\n    options:{\r\n      showBBoxes:false, //display bounding boxes around texts\r\n      debug:true,//show debug info in hte cons\r\n      labelsDelay:1000,//a time after update event of renderer when labelling should start, if zero - errors while zooming\r\n      checkLabelsInside:true,//re-clip all segments to entirely fit map window without padding, disabling increases performance, but some labels maybe invisible due to padding of renderer\r\n      zoomToStartLabel:13,//if map zoom lev is below this, do not show labels\r\n      minimizeTotalOverlappingArea:false, //if true, minimize not the count of overlapping labels, but instead their total overlapping area\r\n      deleteIfNoSolution:false,//TODO [setAutoLabelOptions] if no solution can be achieivd, delete some of the labels, which are overlapping, based on their layer al_options.priority or random if equal\r\n      doNotShowIfSegIsTooSmall:false, //TODO [setAutoLabelOptions] if segment length is less then textlength of text, do not show this text\r\n      annealingOptions:{}\r\n    }, //autolabel options\r\n\r\n    _autoLabel:false, //to determine if autolabelling is set for this map\r\n\r\n    initialize: function (map, options) {\r\n      L.setOptions(this, options);\r\n      this._map=map;\r\n    },\r\n\r\n    hasLayer:function(layer){\r\n      return this._layers2label.indexOf(layer)!=-1;\r\n    },\r\n\r\n    addLayer:function(layer){\r\n      if(!this.hasLayer(layer))this._layers2label.push(layer);\r\n    },\r\n\r\n    remLayer:function(layer){\r\n      var ind=this._layers2label.indexOf(layer);\r\n      if(ind>=0){\r\n        this._layers2label.splice(ind,1);\r\n      }\r\n      return ind>=0;\r\n    },\r\n\r\n    /**\r\n    toggles autolabeling\r\n    */\r\n    toggleAutoLabelling:function(){ //this not tested yet\r\n      if(this._autoLabel)this.disableAutoLabel();else this.enableAutoLabel();\r\n    },\r\n\r\n    /**\r\n    enable autolabeling\r\n    */\r\n    enableAutoLabel:function(){\r\n      if(!this._map){\r\n        this._dodebug('no map attached');\r\n        return;\r\n      }\r\n      if(!this._map.options.renderer){\r\n        this._dodebug('renderer is invalid');\r\n        return;\r\n      }\r\n      //this.setAutoLabelOptions(this.options);\r\n      this._map.options.renderer.on(\"update\",this._apply_doAutoLabel);\r\n      this._map.on(\"zoomstart\",function(){this._zoomstarttrig=1});\r\n      this._map.on(\"zoomend\",function(){this._zoomstarttrig=0});\r\n      this._autoLabel = true;\r\n    },\r\n\r\n    //to check if zoomstart event is fired to prevent autolabeling BEFORE zoomend\r\n    _zoomstarttrig:0,\r\n\r\n    //id of timeout after which AutoLabeling should be done each time - used to stop timer in case of changed map state BEFORE autolabelling was performed\r\n    _ctimerID:-1,\r\n\r\n    /**\r\n    disable autolabeling for this map\r\n    */\r\n    disableAutoLabel:function(){\r\n      this._map.options.renderer.off(\"update\",this._apply_doAutoLabel);\r\n      this._autoLabel=false;\r\n    },\r\n\r\n    /*\r\n    beacuse we using update event of renderer, here we switching to map context and handling two-time update event of SVG renderer\r\n    */\r\n    _apply_doAutoLabel:function(){\r\n      if(this._map.autoLabeler._ctimerID!=-1)clearTimeout(this._map.autoLabeler._ctimerID);\r\n      if(this._map.autoLabeler._zoomstarttrig==0){\r\n        var al = this._map.autoLabeler;\r\n        var lDelay = this._map.autoLabeler.options.labelsDelay;\r\n        this._map.autoLabeler._ctimerID=setTimeout(function(){al._doAutoLabel()},lDelay);\r\n      }\r\n      this._map.autoLabeler._clearNodes();\r\n    },\r\n\r\n    _dodebug:function(message){\r\n      if(this.options.debug)console.log(message);\r\n    },\r\n\r\n\r\n    /**\r\n    this function obtains visible polyline segments from screen and computes optimal positions and draws labels on map\r\n    */\r\n    _doAutoLabel:function() {\r\n      if(!this._autoLabel)return; //nothing to do here\r\n      if(this._map.getZoom()>this.options.zoomToStartLabel){\r\n        dataReader._map=this._map;\r\n        var pt  =dataReader.readDataToLabel(this._map) //array for storing paths and values\r\n        var allsegs=dataReader.prepareCurSegments(pt,{maxlabelcount:80});\r\n        if(allsegs.length==0){\r\n          this._clearNodes();\r\n          return;\r\n        }\r\n        // simulatedAnnealing.processOptions({});\r\n        // var curset = simulatedAnnealing.getInitialRandomState(allsegs);\r\n        // var curvalues = simulatedAnnealing.evaluateCurSet(curset);\r\n        // simulatedAnnealing.markOveralppedLabels(curset,curvalues);\r\n        // this._renderNodes(curset);\r\n        simulatedAnnealing.perform(allsegs,this.options.annealingOptions,this._renderNodes,this);\r\n      }else{\r\n        this._clearNodes();\r\n      }\r\n    },\r\n\r\n    /**\r\n    for test purposes now, creates a polygon node useing poly Array of points\r\n    */\r\n    _createPolygonNode:function(poly,highlited){\r\n      var node = L.SVG.create('polygon');\r\n      var points='';\r\n      for(var i=0;i<poly.length;i++){\r\n        points+=poly[i][0]+','+poly[i][1]+' ';\r\n      }\r\n      node.setAttribute('points', points.trim());\r\n      if(highlited){\r\n        node.setAttribute('style','fill: red; fill-opacity:0.3; stroke: black;');\r\n      }\r\n      else node.setAttribute('style','fill: yellow; fill-opacity:0.1; stroke: black;');\r\n      return node;\r\n    },\r\n\r\n    /**\r\n    clears label on the screen\r\n    */\r\n    _clearNodes:function() {\r\n    var svg = this._map.options.renderer._container;  //to work with SVG\r\n      for(var i=0;i<this._nodes.length;i++){//clear _nodes on screen\r\n        svg.removeChild(this._nodes[i]);\r\n      }\r\n      this._nodes=[];\r\n      // this._dodebug(\"Cleared nodes\");\r\n    },\r\n\r\n    /**\r\n    renders computed labelset on the screen via svg\r\n    */\r\n    _renderNodes:function(labelset){\r\n      var svg =  this._map.options.renderer._container;  //to work with SVG\r\n      this._clearNodes(); //clearscreen\r\n      for(var m in labelset){\r\n        var node = labelset[m].t.content_node;\r\n        var x = labelset[m].pos.x;\r\n        var y = labelset[m].pos.y;\r\n        node.setAttribute('x', x);\r\n        node.setAttribute('y', y);\r\n        var transform ='rotate('+ Math.floor(labelset[m].a)+','+Math.floor(x)+','+Math.floor(y)+')';\r\n        transform = transform.replace(/ /g, '\\u00A0');\r\n        node.setAttribute('transform',transform);\r\n        svg.appendChild(node);\r\n        this._nodes.push(node);//add this labl to _nodes array, so we can erase it from the screen later\r\n        if(this.options.showBBoxes){\r\n          //here for testing purposes\r\n          var polynode = this._createPolygonNode(labelset[m].poly,labelset[m].overlaps);\r\n          svg.appendChild(polynode);\r\n          this._nodes.push(polynode); //add this polygon to _nodes array, so we can erase it from the screen later\r\n        }\r\n      }\r\n    }\r\n  }\r\n)\r\n\r\nL.autoLabeler = function(map,options){\r\n  return new L.AutoLabeler(map,options);\r\n}\r\n\r\n// module.exports = autoLabeler;\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/autoLabeler.js\n ** module id = 1\n ** module chunks = 0\n **/","//a class to compute pixel dimensions of texts\r\n/** @namespace DOMEssentials*/\r\n'use strict';\r\nvar geomEssentials = require(\"./geomEssentials.js\");\r\n\r\nmodule.exports = {\r\n  /**\r\n  converts TextRectangle object to clockwise array of 2d-arrays, representing rectangular poly\r\n  @param {TextRectangle} rect: a bbox for text\r\n  @returns {Array}\r\n  @memberof DOMEssentials#\r\n  */\r\n  convertClientRectToArrayOfArrays:function(rect) {\r\n    var res=[];\r\n    var height_correction=rect.height*0.2; //beacuse getBoundingClientRect give a bit false height info\r\n    res.push([0,0]);\r\n    res.push([0,-rect.height]);\r\n    res.push([rect.width,-rect.height]);\r\n    res.push([rect.width,0]);\r\n    res=geomEssentials.movePolyByAdding(res,[0,height_correction]);\r\n    return res;\r\n  },\r\n\r\n  /**\r\n  returns a bounding box for horizontal text with style as in t.content_node\r\n  @param {Object} map: current map\r\n  @param {Object} node: textNode\r\n  @returns {L.Point} : a bbox for node, as width and height\r\n  @memberof DOMEssentials#\r\n  */\r\n  getBoundingBox:function(map,node){\r\n    var svg = map.options.renderer._container;\r\n    svg.appendChild(node);\r\n    var rect = node.getBoundingClientRect();\r\n    svg.removeChild(node);\r\n    return L.point(rect.width,rect.height);\r\n  },\r\n\r\n  /**\r\n  creates SVG text node with specified style and handles some formatting issues\r\n  @param {String} text: text for node\r\n  @param {String} textstyle: CSS style String\r\n  @returns {TextNode} : SVG node\r\n  */\r\n  createSVGTextNode:function(text,textstyle){\r\n    text = text.replace(/ /g, '\\u00A0');  // Non breakable spaces\r\n    var node =L.SVG.create('text');\r\n    node.setAttribute('style',textstyle);\r\n    node.textContent = text;\r\n    return node;\r\n  }\r\n}\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/DOMEssentials.js\n ** module id = 2\n ** module chunks = 0\n **/","//a class to perfrom geometric stuff\r\n/** @namespace geomEssentials*/\r\n'use strict';\r\n\r\nvar greinerHormann = require('./third_party/GreinerHormann');\r\n\r\nvar geomEssentials = {\r\n\r\n  /**\r\n  code from leaflet src, without some lines\r\n  we assume here, that clipPoints was already invoked\r\n  */\r\n  clipClippedPoints: function (layer_parts,bounds) {\r\n    var parts = [], i, j, k=0,len, len2, segment,points;\r\n    for (i = 0, k = 0, len = layer_parts.length; i < len; i++) {\r\n\t\t\tpoints = layer_parts[i];\r\n  \t\tfor (j = 0, len2 = points.length; j < len2 - 1; j++) {\r\n  \t\t\tsegment = L.LineUtil.clipSegment(points[j], points[j + 1], bounds, j, true);\r\n  \t\t\tif (!segment) { continue; }\r\n  \t\t\tparts[k] = parts[k] || [];\r\n  \t\t\tparts[k].push(segment[0]);\r\n  \t\t\t// if segment goes out of screen, or it's the last one, it's the end of the line part\r\n  \t\t\tif ((segment[1] !== points[j + 1]) || (j === len2 - 2)) {\r\n  \t\t\t\tparts[k].push(segment[1]);\r\n  \t\t\t\tk++;\r\n  \t\t\t}\r\n  \t\t}\r\n    }\r\n    return parts;\r\n\t},\r\n\r\n  roundPoint:function(p){\r\n    var res= L.point(Math.round(p.x),Math.round(p.y));\r\n    return res;\r\n  },\r\n\r\n  /**\r\n  scales bounds by multiplying it's size with scalefactor, and keeping center\r\n  */\r\n  scaleBounds:function(bounds,scalefactor){\r\n    var origin = bounds.getCenter();\r\n    var newHalfSize = bounds.getSize().multiplyBy(scalefactor/2);\r\n    var newTopLeft = origin.subtract(newHalfSize);\r\n    var newBotRight = origin.add(newHalfSize);\r\n    return L.bounds(this.roundPoint(newTopLeft),this.roundPoint(newBotRight));\r\n  },\r\n\r\n  /**\r\n  the name is the description\r\n  */\r\n  getBoundsWithoutPadding(themap,scaleafter){\r\n    var bounds =themap.options.renderer._bounds;\r\n    //to get zero padding we should scale bounds by 1 / (1 + current_padding), and then we want to scale by scaleafter\r\n    //for example, default padding is 0.1, which means 110% of map container pixel bounds to render, so zise of basic ixels bounds is multiplied by 1.1getPixelBounds()\r\n    var current_padding = themap.options.renderer.padding || 0.1;\r\n    var scale_to_apply = scaleafter/(1+current_padding);\r\n    return this.scaleBounds(bounds,scaleafter);\r\n    //return bounds;\r\n  },\r\n  /**\r\n  moves a poly by adding pt2add point to all its vertices\r\n  @param {Array} poly: a poly to movePoly\r\n  @param {Array} pt2add: a point to add to all vertices\r\n  @returns {Array}: moved poly\r\n  @memberof geomEssentials#\r\n  */\r\n  movePolyByAdding:function(poly,pt2add) {\r\n    var res=poly.slice(0);\r\n    for(var i=0;i<poly.length;i++){\r\n      res[i][0]+=pt2add[0]; res[i][1]+=pt2add[1];\r\n    }\r\n    return res;\r\n  },\r\n\r\n  /**\r\n  moves a poly by translating all its vertices to moveto\r\n  @param {Array} poly: a poly to movePoly\r\n  @param {Array} moveto: where translate all vertices\r\n  @returns {Array}: moved poly\r\n  @memberof geomEssentials#\r\n  */\r\n  movePolyByMovingTo:function(poly,moveto){\r\n    var res=poly.slice(0);\r\n    moveto[0] = moveto[0]-poly[0][0];\r\n    moveto[1] = moveto[1]-poly[0][1];\r\n    for(var i=1;i<poly.length;i++){\r\n      res[i][0]+=moveto[0]; res[i][1]+=moveto[1];\r\n    }\r\n    return res;\r\n  },\r\n  /**\r\n  code from L.GeometryUtil plugin\r\n  @memberof geomEssentials#\r\n  */\r\n  computeAngle: function(a, b, check_left_to_right) {\r\n      var x1 = a.x, x2 = b.x;\r\n      if(check_left_to_right){\r\n        if(x1>x2){\r\n          var tmp=x1; x1=x2; x2=tmp;\r\n        }\r\n      }\r\n      return (Math.atan2(b.y - a.y, x2 - x1) * 180 / Math.PI);\r\n  },\r\n\r\n  /**\r\n  code from L.GeometryUtil plugin\r\n       Returns slope (Ax+B) between two points.\r\n        @param {L.Point} a\r\n        @param {L.Point} b\r\n        @returns {Object} with ``a`` and ``b`` properties.\r\n     */\r\n  computeSlope: function(a, b) {\r\n      var s = (b.y - a.y) / (b.x - a.x),\r\n          o = a.y - (s * a.x);\r\n      return {a: s, b: o};\r\n  },\r\n\r\n  getNormalOnSegment:function(segment){\r\n    var slope = this.computeSlope(segment.seg[0],segment.seg[1]);\r\n    return this.normalizePt(slope);\r\n  },\r\n\r\n  get2dVectorLength:function(pt){\r\n    return Math.sqrt(pt.x*pt.x + pt.y*pt.y);\r\n  },\r\n\r\n  normalizePt:function(pt){\r\n    return (pt.x===0&&pt.y===0)?0:pt.divideBy(this.get2dVectorLength(pt));\r\n  },\r\n  /**\r\n  code from L.GeometryUtil plugin\r\n  @memberof geomEssentials#\r\n  */\r\n  interpolateOnPointSegment: function (pA, pB, ratio) {\r\n      return L.point(\r\n          (pA.x * (1 - ratio)) + (ratio * pB.x),\r\n          (pA.y * (1 - ratio)) + (ratio * pB.y)\r\n      );\r\n  },\r\n\r\n  /**\r\n  computes a point where two lines intersection\r\n  @param {Array} seg1: a first line defined by two points\r\n  @param {Array} seg2: a second line defined by two points\r\n  @return {L.Point} :intersection point or null if lines are parallel to each other\r\n  */\r\n  lineIntersection:function(seg1,seg2){\r\n    var slope1=this.computeSlope(seg1[0],seg1[1]);\r\n    var slope2=this.computeSlope(seg2[0],seg2[1]);\r\n    if(slope1.x===slope2.x)return;\r\n    var x = (slope2.y - slope1.y) / (slope11.x - slope2.x);\r\n    var y = slope1.x*x + slope1.y;\r\n    return L.point(x,y);\r\n  },\r\n\r\n  /**\r\n  expangs a segment withing length in direction from seg[0] to seg[1]\r\n  @param {Array} segment: a segment defined by two points\r\n  @param {Number} length:how much increase segment len, should be positive\r\n  @return {Array} : expanded segment\r\n  */\r\n  expandSegment:function(segment,segment_length,length){\r\n    var res=segment.slice(0);\r\n    if(length<0)return res;\r\n    return this.interpolateOnPointSegment(segment[0],segment[1],(length + segment_length)/segment_length);\r\n  },\r\n\r\n  /**\r\n  function from https://rosettacode.org/wiki/Sutherland-Hodgman_polygon_clipping#JavaScript\r\n  @param {Array} subjectPolygon: first poly\r\n  @param {Array} clipPolygon: second poly\r\n  @returns {Array} : result poly\r\n  @memberof geomEssentials#\r\n  */\r\n  clipPoly2:function(subjectPolygon, clipPolygon) {\r\n    var cp1, cp2, s, e;\r\n    var inside = function (p) {\r\n        return (cp2[0]-cp1[0])*(p[1]-cp1[1]) > (cp2[1]-cp1[1])*(p[0]-cp1[0]);\r\n    };\r\n    var intersection = function () {\r\n        var dc = [ cp1[0] - cp2[0], cp1[1] - cp2[1] ],\r\n            dp = [ s[0] - e[0], s[1] - e[1] ],\r\n            n1 = cp1[0] * cp2[1] - cp1[1] * cp2[0],\r\n            n2 = s[0] * e[1] - s[1] * e[0],\r\n            n3 = 1.0 / (dc[0] * dp[1] - dc[1] * dp[0]);\r\n        return [(n1*dp[0] - n2*dc[0]) * n3, (n1*dp[1] - n2*dc[1]) * n3];\r\n    };\r\n    var outputList = subjectPolygon;\r\n    cp1 = clipPolygon[clipPolygon.length-1];\r\n    for (var j in clipPolygon) {\r\n        var cp2 = clipPolygon[j];\r\n        var inputList = outputList;\r\n        outputList = [];\r\n        s = inputList[inputList.length - 1]; //last on the input list\r\n        for (var i in inputList) {\r\n            var e = inputList[i];\r\n            if (inside(e)) {\r\n                if (!inside(s)) {\r\n                    outputList.push(intersection());\r\n                }\r\n                outputList.push(e);\r\n            }\r\n            else if (inside(s)) {\r\n                outputList.push(intersection());\r\n            }\r\n            s = e;\r\n        }\r\n        cp1 = cp2;\r\n    }\r\n    return outputList\r\n  },\r\n\r\n  clipPoly:function(poly1,poly2){\r\n    var intersection = greinerHormann.intersection(poly1, poly2);\r\n    if(!intersection)return [];\r\n    if(intersection.length>0)return intersection[0];\r\n  },\r\n\r\n  /**\r\n  returns a combined poly from two\r\n  */\r\n  addPoly:function(poly1,poly2){\r\n    var union = greinerHormann.union(poly1, poly2);\r\n    if(!union)return [];\r\n    if(union.length>0)return union[0];\r\n  },\r\n\r\n  subtractPoly:function(poly1,poly2){\r\n    var diff = greinerHormann.diff(poly1, poly2);\r\n    if(!diff)return [];else return diff;\r\n  },\r\n\r\n  /**\r\n  code from http://www.codeproject.com/Articles/13467/A-JavaScript-Implementation-of-the-Surveyor-s-Form\r\n  for single polygon only, and no holes in\r\n  @param {Array} poly: a poly to determine area of\r\n  @memberof geomEssentials#\r\n  */\r\n  polyArea:function(poly) {\r\n    // Calculate the area of a polygon\r\n    // using the data stored\r\n    // in the arrays x and y\r\n    var area = 0.0;\r\n    if(poly){\r\n      var poly=poly.slice(0);\r\n      if(poly.length>2)poly.push(poly[0]); //close the poly\r\n      for(var k = 0; k < poly.length-1; k++ ) {\r\n          var xDiff = poly[k+1][0] - poly[k][0];\r\n          var yDiff = poly[k+1][1] - poly[k][1];\r\n          area += + poly[k][0] * yDiff - poly[k][1] * xDiff;\r\n      }\r\n      area = 0.5 * area;\r\n    }\r\n    return area;\r\n  },\r\n\r\n  /**\r\n  rotates given polygon to a given angle around basepoint\r\n  code partialy from web, don't remember from...\r\n  @param {Array} poly: a polygon to rotate\r\n  @param {Array} basepoint: base point\r\n  @param {float} angle: an angle in degrees\r\n  @returns {Array}: rotated poly\r\n  @memberof geomEssentials#\r\n  */\r\n  rotatePoly:function(poly, basepoint,angle){\r\n    var res=[];\r\n    var angleRad = angle*Math.PI/180;\r\n    for(var i=0;i<poly.length;i++){\r\n      var pPoint = poly[i],\r\n      x_rotated = Math.cos(angleRad)*(pPoint[0]-basepoint[0]) - Math.sin(angleRad)*(pPoint[1]-basepoint[1]) + basepoint[0],\r\n      y_rotated = Math.sin(angleRad)*(pPoint[0]-basepoint[0]) + Math.cos(angleRad)*(pPoint[1]-basepoint[1]) + basepoint[1];\r\n      res.push([x_rotated,y_rotated]);\r\n    }\r\n    return res;\r\n  },\r\n\r\n  createPoly:function(width,height){\r\n    //TODO[createPoly]\r\n  }\r\n\r\n}\r\n\r\nmodule.exports = geomEssentials;\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/geomEssentials.js\n ** module id = 3\n ** module chunks = 0\n **/","var clip = require('./clip');\r\n\r\nmodule.exports = {\r\n    /**\r\n     * @api\r\n     * @param  {Array.<Array.<Number>|Array.<Object>} polygonA\r\n     * @param  {Array.<Array.<Number>|Array.<Object>} polygonB\r\n     * @return {Array.<Array.<Number>>|Array.<Array.<Object>|Null}\r\n     */\r\n    union: function(polygonA, polygonB) {\r\n        return clip(polygonA, polygonB, false, false);\r\n    },\r\n\r\n    /**\r\n     * @api\r\n     * @param  {Array.<Array.<Number>|Array.<Object>} polygonA\r\n     * @param  {Array.<Array.<Number>|Array.<Object>} polygonB\r\n     * @return {Array.<Array.<Number>>|Array.<Array.<Object>>|Null}\r\n     */\r\n    intersection: function(polygonA, polygonB) {\r\n        return clip(polygonA, polygonB, true, true);\r\n    },\r\n\r\n    /**\r\n     * @api\r\n     * @param  {Array.<Array.<Number>|Array.<Object>} polygonA\r\n     * @param  {Array.<Array.<Number>|Array.<Object>} polygonB\r\n     * @return {Array.<Array.<Number>>|Array.<Array.<Object>>|Null}\r\n     */\r\n    diff: function(polygonA, polygonB) {\r\n        return clip(polygonA, polygonB, false, true);\r\n    },\r\n\r\n    clip: clip\r\n};\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/third_party/GreinerHormann/src/greiner-hormann.js\n ** module id = 4\n ** module chunks = 0\n **/","var Polygon = require('./polygon');\r\n\r\n/**\r\n * Clip driver\r\n * @api\r\n * @param  {Array.<Array.<Number>>} polygonA\r\n * @param  {Array.<Array.<Number>>} polygonB\r\n * @param  {Boolean}                sourceForwards\r\n * @param  {Boolean}                clipForwards\r\n * @return {Array.<Array.<Number>>}\r\n */\r\nmodule.exports = function(polygonA, polygonB, eA, eB) {\r\n    var result, source = new Polygon(polygonA),\r\n        clip = new Polygon(polygonB),\r\n        result = source.clip(clip, eA, eB);\r\n\r\n    return result;\r\n};\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/third_party/GreinerHormann/src/clip.js\n ** module id = 5\n ** module chunks = 0\n **/","var Vertex = require('./vertex');\r\nvar Intersection = require('./intersection');\r\n\r\n/**\r\n * Polygon representation\r\n * @param {Array.<Array.<Number>>} p\r\n * @param {Boolean=}               arrayVertices\r\n *\r\n * @constructor\r\n */\r\nvar Polygon = function(p, arrayVertices) {\r\n\r\n    /**\r\n     * @type {Vertex}\r\n     */\r\n    this.first = null;\r\n\r\n    /**\r\n     * @type {Number}\r\n     */\r\n    this.vertices = 0;\r\n\r\n    /**\r\n     * @type {Vertex}\r\n     */\r\n    this._lastUnprocessed = null;\r\n\r\n    /**\r\n     * Whether to handle input and output as [x,y] or {x:x,y:y}\r\n     * @type {Boolean}\r\n     */\r\n    this._arrayVertices = (typeof arrayVertices === \"undefined\") ?\r\n        Array.isArray(p[0]) :\r\n        arrayVertices;\r\n\r\n    for (var i = 0, len = p.length; i < len; i++) {\r\n        this.addVertex(new Vertex(p[i]));\r\n    }\r\n};\r\n\r\n/**\r\n * Add a vertex object to the polygon\r\n * (vertex is added at the 'end' of the list')\r\n *\r\n * @param vertex\r\n */\r\nPolygon.prototype.addVertex = function(vertex) {\r\n    if (this.first == null) {\r\n        this.first = vertex;\r\n        this.first.next = vertex;\r\n        this.first.prev = vertex;\r\n    } else {\r\n        var next = this.first,\r\n            prev = next.prev;\r\n\r\n        next.prev = vertex;\r\n        vertex.next = next;\r\n        vertex.prev = prev;\r\n        prev.next = vertex;\r\n    }\r\n    this.vertices++;\r\n};\r\n\r\n/**\r\n * Inserts a vertex inbetween start and end\r\n *\r\n * @param {Vertex} vertex\r\n * @param {Vertex} start\r\n * @param {Vertex} end\r\n */\r\nPolygon.prototype.insertVertex = function(vertex, start, end) {\r\n    var prev, curr = start;\r\n\r\n    while (!curr.equals(end) && curr._distance < vertex._distance) {\r\n        curr = curr.next;\r\n    }\r\n\r\n    vertex.next = curr;\r\n    prev = curr.prev;\r\n\r\n    vertex.prev = prev;\r\n    prev.next = vertex;\r\n    curr.prev = vertex;\r\n\r\n    this.vertices++;\r\n};\r\n\r\n/**\r\n * Get next non-intersection point\r\n * @param  {Vertex} v\r\n * @return {Vertex}\r\n */\r\nPolygon.prototype.getNext = function(v) {\r\n    var c = v;\r\n    while (c._isIntersection) {\r\n        c = c.next;\r\n    }\r\n    return c;\r\n};\r\n\r\n/**\r\n * Unvisited intersection\r\n * @return {Vertex}\r\n */\r\nPolygon.prototype.getFirstIntersect = function() {\r\n    var v = this._firstIntersect || this.first;\r\n\r\n    do {\r\n        if (v._isIntersection && !v._visited) {\r\n            break;\r\n        }\r\n\r\n        v = v.next;\r\n    } while (!v.equals(this.first));\r\n\r\n    this._firstIntersect = v;\r\n    return v;\r\n};\r\n\r\n/**\r\n * Does the polygon have unvisited vertices\r\n * @return {Boolean} [description]\r\n */\r\nPolygon.prototype.hasUnprocessed = function() {\r\n    var v = this._lastUnprocessed || this.first;\r\n    do {\r\n        if (v._isIntersection && !v._visited) {\r\n            this._lastUnprocessed = v;\r\n            return true;\r\n        }\r\n\r\n        v = v.next;\r\n    } while (!v.equals(this.first));\r\n\r\n    this._lastUnprocessed = null;\r\n    return false;\r\n};\r\n\r\n/**\r\n * The output depends on what you put in, arrays or objects\r\n * @return {Array.<Array<Number>|Array.<Object>}\r\n */\r\nPolygon.prototype.getPoints = function() {\r\n    var points = [],\r\n        v = this.first;\r\n\r\n    if (this._arrayVertices) {\r\n        do {\r\n            points.push([v.x, v.y]);\r\n            v = v.next;\r\n        } while (v !== this.first);\r\n    } else {\r\n        do {\r\n            points.push({\r\n                x: v.x,\r\n                y: v.y\r\n            });\r\n            v = v.next;\r\n        } while (v !== this.first);\r\n    }\r\n\r\n    return points;\r\n};\r\n\r\n/**\r\n * Clip polygon against another one.\r\n * Result depends on algorithm direction:\r\n *\r\n * Intersection: forwards forwards\r\n * Union:        backwars backwards\r\n * Diff:         backwards forwards\r\n *\r\n * @param {Polygon} clip\r\n * @param {Boolean} sourceForwards\r\n * @param {Boolean} clipForwards\r\n */\r\nPolygon.prototype.clip = function(clip, sourceForwards, clipForwards) {\r\n    var sourceVertex = this.first,\r\n        clipVertex = clip.first,\r\n        sourceInClip, clipInSource;\r\n\r\n    // calculate and mark intersections\r\n    do {\r\n        if (!sourceVertex._isIntersection) {\r\n            do {\r\n                if (!clipVertex._isIntersection) {\r\n                    var i = new Intersection(\r\n                        sourceVertex,\r\n                        this.getNext(sourceVertex.next),\r\n                        clipVertex, clip.getNext(clipVertex.next));\r\n\r\n                    if (i.valid()) {\r\n                        var sourceIntersection =\r\n                            Vertex.createIntersection(i.x, i.y, i.toSource),\r\n                            clipIntersection =\r\n                            Vertex.createIntersection(i.x, i.y, i.toClip);\r\n\r\n                        sourceIntersection._corresponding = clipIntersection;\r\n                        clipIntersection._corresponding = sourceIntersection;\r\n\r\n                        this.insertVertex(\r\n                            sourceIntersection,\r\n                            sourceVertex,\r\n                            this.getNext(sourceVertex.next));\r\n                        clip.insertVertex(\r\n                            clipIntersection,\r\n                            clipVertex,\r\n                            clip.getNext(clipVertex.next));\r\n                    }\r\n                }\r\n                clipVertex = clipVertex.next;\r\n            } while (!clipVertex.equals(clip.first));\r\n        }\r\n\r\n        sourceVertex = sourceVertex.next;\r\n    } while (!sourceVertex.equals(this.first));\r\n\r\n    // phase two - identify entry/exit points\r\n    sourceVertex = this.first;\r\n    clipVertex = clip.first;\r\n\r\n    sourceInClip = sourceVertex.isInside(clip);\r\n    clipInSource = clipVertex.isInside(this);\r\n\r\n    sourceForwards ^= sourceInClip;\r\n    clipForwards ^= clipInSource;\r\n\r\n    do {\r\n        if (sourceVertex._isIntersection) {\r\n            sourceVertex._isEntry = sourceForwards;\r\n            sourceForwards = !sourceForwards;\r\n        }\r\n        sourceVertex = sourceVertex.next;\r\n    } while (!sourceVertex.equals(this.first));\r\n\r\n    do {\r\n        if (clipVertex._isIntersection) {\r\n            clipVertex._isEntry = clipForwards;\r\n            clipForwards = !clipForwards;\r\n        }\r\n        clipVertex = clipVertex.next;\r\n    } while (!clipVertex.equals(clip.first));\r\n\r\n    // phase three - construct a list of clipped polygons\r\n    var list = [];\r\n\r\n    while (this.hasUnprocessed()) {\r\n        var current = this.getFirstIntersect(),\r\n            // keep format\r\n            clipped = new Polygon([], this._arrayVertices);\r\n\r\n        clipped.addVertex(new Vertex(current.x, current.y));\r\n        do {\r\n            current.visit();\r\n            if (current._isEntry) {\r\n                do {\r\n                    current = current.next;\r\n                    clipped.addVertex(new Vertex(current.x, current.y));\r\n                } while (!current._isIntersection);\r\n\r\n            } else {\r\n                do {\r\n                    current = current.prev;\r\n                    clipped.addVertex(new Vertex(current.x, current.y));\r\n                } while (!current._isIntersection);\r\n            }\r\n            current = current._corresponding;\r\n        } while (!current._visited);\r\n\r\n        list.push(clipped.getPoints());\r\n    }\r\n\r\n    if (list.length === 0) {\r\n        if (sourceInClip) {\r\n            list.push(this.getPoints());\r\n        }\r\n        if (clipInSource) {\r\n            list.push(clip.getPoints());\r\n        }\r\n        if (list.length === 0) {\r\n            list = null;\r\n        }\r\n    }\r\n\r\n    return list;\r\n};\r\n\r\nmodule.exports = Polygon;\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/third_party/GreinerHormann/src/polygon.js\n ** module id = 6\n ** module chunks = 0\n **/","/**\r\n * Vertex representation\r\n *\r\n * @param {Number|Array.<Number>} x\r\n * @param {Number=}               y\r\n *\r\n * @constructor\r\n */\r\nvar Vertex = function(x, y) {\r\n\r\n    if (arguments.length === 1) {\r\n        // Coords\r\n        if (Array.isArray(x)) {\r\n            y = x[1];\r\n            x = x[0];\r\n        } else {\r\n            y = x.y;\r\n            x = x.x;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * X coordinate\r\n     * @type {Number}\r\n     */\r\n    this.x = x;\r\n\r\n    /**\r\n     * Y coordinate\r\n     * @type {Number}\r\n     */\r\n    this.y = y;\r\n\r\n    /**\r\n     * Next node\r\n     * @type {Vertex}\r\n     */\r\n    this.next = null;\r\n\r\n    /**\r\n     * Previous vertex\r\n     * @type {Vertex}\r\n     */\r\n    this.prev = null;\r\n\r\n    /**\r\n     * Corresponding intersection in other polygon\r\n     */\r\n    this._corresponding = null;\r\n\r\n    /**\r\n     * Distance from previous\r\n     */\r\n    this._distance = 0.0;\r\n\r\n    /**\r\n     * Entry/exit point in another polygon\r\n     * @type {Boolean}\r\n     */\r\n    this._isEntry = true;\r\n\r\n    /**\r\n     * Intersection vertex flag\r\n     * @type {Boolean}\r\n     */\r\n    this._isIntersection = false;\r\n\r\n    /**\r\n     * Loop check\r\n     * @type {Boolean}\r\n     */\r\n    this._visited = false;\r\n};\r\n\r\n/**\r\n * Creates intersection vertex\r\n * @param  {Number} x\r\n * @param  {Number} y\r\n * @param  {Number} distance\r\n * @return {Vertex}\r\n */\r\nVertex.createIntersection = function(x, y, distance) {\r\n    var vertex = new Vertex(x, y);\r\n    vertex._distance = distance;\r\n    vertex._isIntersection = true;\r\n    vertex._isEntry = false;\r\n    return vertex;\r\n};\r\n\r\n/**\r\n * Mark as visited\r\n */\r\nVertex.prototype.visit = function() {\r\n    this._visited = true;\r\n    if (this._corresponding !== null && !this._corresponding._visited) {\r\n        this._corresponding.visit();\r\n    }\r\n};\r\n\r\n/**\r\n * Convenience\r\n * @param  {Vertex}  v\r\n * @return {Boolean}\r\n */\r\nVertex.prototype.equals = function(v) {\r\n    return this.x === v.x && this.y === v.y;\r\n};\r\n\r\n/**\r\n * Check if vertex is inside a polygon by odd-even rule:\r\n * If the number of intersections of a ray out of the point and polygon\r\n * segments is odd - the point is inside.\r\n * @param {Polygon} poly\r\n * @return {Boolean}\r\n */\r\nVertex.prototype.isInside = function(poly) {\r\n    var oddNodes = false,\r\n        vertex = poly.first,\r\n        next = vertex.next,\r\n        x = this.x,\r\n        y = this.y;\r\n\r\n    do {\r\n        if ((vertex.y < y && next.y >= y ||\r\n                next.y < y && vertex.y >= y) &&\r\n            (vertex.x <= x || next.x <= x)) {\r\n\r\n            oddNodes ^= (vertex.x + (y - vertex.y) /\r\n                (next.y - vertex.y) * (next.x - vertex.x) < x);\r\n        }\r\n\r\n        vertex = vertex.next;\r\n        next = vertex.next || poly.first;\r\n    } while (!vertex.equals(poly.first));\r\n\r\n    return oddNodes;\r\n};\r\n\r\nmodule.exports = Vertex;\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/third_party/GreinerHormann/src/vertex.js\n ** module id = 7\n ** module chunks = 0\n **/","/**\r\n * Intersection\r\n * @param {Vertex} s1\r\n * @param {Vertex} s2\r\n * @param {Vertex} c1\r\n * @param {Vertex} c2\r\n * @constructor\r\n */\r\nvar Intersection = function(s1, s2, c1, c2) {\r\n\r\n    /**\r\n     * @type {Number}\r\n     */\r\n    this.x = 0.0;\r\n\r\n    /**\r\n     * @type {Number}\r\n     */\r\n    this.y = 0.0;\r\n\r\n    /**\r\n     * @type {Number}\r\n     */\r\n    this.toSource = 0.0;\r\n\r\n    /**\r\n     * @type {Number}\r\n     */\r\n    this.toClip = 0.0;\r\n\r\n    var d = (c2.y - c1.y) * (s2.x - s1.x) - (c2.x - c1.x) * (s2.y - s1.y);\r\n\r\n    if (d === 0) {\r\n        return;\r\n    }\r\n\r\n    /**\r\n     * @type {Number}\r\n     */\r\n    this.toSource = ((c2.x - c1.x) * (s1.y - c1.y) - (c2.y - c1.y) * (s1.x - c1.x)) / d;\r\n\r\n    /**\r\n     * @type {Number}\r\n     */\r\n    this.toClip = ((s2.x - s1.x) * (s1.y - c1.y) - (s2.y - s1.y) * (s1.x - c1.x)) / d;\r\n\r\n    if (this.valid()) {\r\n        this.x = s1.x + this.toSource * (s2.x - s1.x);\r\n        this.y = s1.y + this.toSource * (s2.y - s1.y);\r\n    }\r\n};\r\n\r\n/**\r\n * @return {Boolean}\r\n */\r\nIntersection.prototype.valid = function() {\r\n    return (0 < this.toSource && this.toSource < 1) && (0 < this.toClip && this.toClip < 1);\r\n};\r\n\r\nmodule.exports = Intersection;\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/third_party/GreinerHormann/src/intersection.js\n ** module id = 8\n ** module chunks = 0\n **/","'use strict';\r\n\r\nvar geomEssentials = require(\"./geomEssentials.js\");\r\nvar candidateGenerator = require(\"./CandidateGenerator.js\");\r\n\r\nvar simulatedAnnealing = {\r\n\r\n  /**\r\n  computes the random set of positions for text placement with angles and text values\r\n  @param {Array} allsegs: an array with {t,segs} elements, according to t -text of the polyline, segs - its accepted segments to label on. Result array is generated from items of this array\r\n  @returns {Array} : an array with elements such as return values of computeLabelCandidate function\r\n  */\r\n  getInitialRandomState:function(allsegs){\r\n    var res=[];\r\n    for(var i in allsegs){\r\n      var candidate = candidateGenerator.computeLabelCandidate(i,allsegs);\r\n      res.push(candidate);\r\n    }\r\n    return res;\r\n  },\r\n\r\n  /**\r\n  check if two labels overlab, if no returns false, if yes returns ???area OR polygon??? of averlap\r\n  @param {} poly1:a first polygon to check overlap with second\r\n  @param {} poly2:a second polygon to check overlap with first\r\n  @returns {float}: an area of overlapping, zero if no overlapping\r\n  */\r\n  checkOverLappingArea:function(poly1,poly2,calculateAreaNotOnlyFactOfOverlapping) {\r\n    var clipped = geomEssentials.clipPoly(poly1,poly2);\r\n    if(calculateAreaNotOnlyFactOfOverlapping){\r\n      var area =geomEssentials.polyArea(clipped);\r\n      return area;\r\n    };\r\n    if(clipped.length>0)return 1;else return 0; //for performance, skip area calculation\r\n  },\r\n\r\n  /**\r\n  may be a custom function, must add result as last value of input array\r\n  @param {Array} overlapping_values: input array of areas\r\n  */\r\n  assignCostFunctionValuesToLastEl:function(overlapping_values){\r\n    var res=0;\r\n    for(var i in overlapping_values){\r\n      res+=overlapping_values[i];\r\n    }\r\n    overlapping_values.push(res);\r\n  },\r\n\r\n  /**\r\n  summarizing ovelapping of all layers. We store for each label it's total overlapping area with others, the sum values for all labels\r\n  @param {Array}:curset:\r\n  @returns {Array}: values of areas, last is sum\r\n  @memberof MapAutoLabelSupport#\r\n  */\r\n  evaluateCurSet:function(curset){\r\n    var overlap_values=[];\r\n    for(var i in curset){\r\n      for(var j in curset){\r\n        if(i>j){ //to exclude variants like compare (1,3) and then (3,1)\r\n        var curlabel_value=this.checkOverLappingArea(curset[i].poly,curset[j].poly,this.options.minimizeTotalOverlappingArea);\r\n        //for each pair(i,j) push it's value into overlap_values array\r\n        //we know that we iterate through only lower triangle of matrix (i,j), so we can reconstruct i and j from overlap_values index and vice versa\r\n        //we do it to improve speed when recomputing ovelaps in each annealing iteration in order not to compute all overlaps (with high performance cost)\r\n        //istead we recompute areas only for changed label\r\n        overlap_values.push(curlabel_value);\r\n        }\r\n      }\r\n    }\r\n    this.assignCostFunctionValuesToLastEl(overlap_values);\r\n    return overlap_values;\r\n  },\r\n\r\n  markOveralppedLabels:function(curset,overlappedvalues){\r\n    var counter=0;\r\n    for(var i in curset){\r\n      for(var j in curset){\r\n        if(i>j){\r\n          if(overlappedvalues[counter]>0){\r\n            curset[i].overlaps = true;\r\n            curset[j].overlaps = true;\r\n            this.dodebug(curset[i].t.content_node.textContent +' /// '+curset[j].t.content_node.textContent  )\r\n          }\r\n          counter++;\r\n        }\r\n      }\r\n    }\r\n  },\r\n\r\n  getOverlappingLabelsIndexes:function(curvalues,curset){\r\n    var counter=0, result=[];\r\n    for(var i in curset)\r\n     for(var j in curset)if(i>j){\r\n       if(curvalues[counter]>0){\r\n         result.push(i); result.push(j);\r\n       }\r\n       counter++;\r\n     }\r\n    return result;\r\n  },\r\n\r\n  /**\r\n  swaps position for a random label with another from this label's positions pool\r\n  @param {Number} index : index of label in allsegs to select new random position from availavle choices.\r\n  @param {Array} curset: currently selected label postions\r\n  @param {Array} allsegs: all available postions\r\n  @memberof MapAutoLabelSupport#\r\n  */\r\n  swapCandidateInLabelSetToNew:function(idx,curset,allsegs){\r\n    var label_index = curset[idx].allsegs_index;\r\n    var new_candidate = candidateGenerator.computeLabelCandidate(label_index,allsegs);\r\n    curset[idx]=new_candidate;\r\n  },\r\n\r\n  applyNewPositionsForLabelsInArray:function(idx_array,curset,allsegs){\r\n    for(var i in idx_array)this.swapCandidateInLabelSetToNew(idx_array[i],curset,allsegs);\r\n  },\r\n\r\n  /**\r\n  calculates total overlapping area with knowlesge of previous value and what label was moved\r\n  @param {Array} curvalue: array of float computed at previous step or initital step, consist of elements of lower-triangluar matrix (i,j) of values of overlapping areas for (i,j) els of curset\r\n  @param {Array} curset: current set of label with positions\r\n  @param {Number} changedLabelIndex: an index of label which position we changed\r\n  @returns {Array} : curvalues, recalculated\r\n  @memberof MapAutoLabelSupport#\r\n  */\r\n  evaluateAfterSeveralChanged:function(curvalues,curset,changedLabels) {\r\n    var counter=0; //index to iterate through curvalue array\r\n    while(changedLabels.length>0){\r\n      var changedLabelIndex=changedLabels.pop();\r\n      for(var i=0;i<curset.length;i++){\r\n        for(var j=0;j<curset.length;j++){if(i>j){ //i,j like we used them in the evaluateCurSet function, so we get similar counter values\r\n          if(i===changedLabelIndex||j===changedLabelIndex){ //here we obtain all indexes of curvales array corresponding to changedLabelIndex\r\n            var area=this.checkOverLappingArea(curset[i].poly,curset[j].poly,this.options.minimizeTotalOverlappingArea); //and recalculate areas\r\n            curvalues[counter]=area;\r\n            }\r\n            counter++;\r\n          }\r\n        }\r\n      }\r\n    }\r\n    curvalues.pop(); //remove prev sum\r\n    this.assignCostFunctionValuesToLastEl(curvalues);\r\n    return curvalues;\r\n  },\r\n\r\n  dodebug:function(message){\r\n    if(this.options.debug)console.log(message);\r\n  },\r\n\r\n  processOptions:function(options){\r\n    this.options=options || {};\r\n    this.options.t0 = this.options.t0 || 2.5;\r\n    this.options.decrease_value = this.options.decrease_value || 0.9; //decrease by ten percent each decrease step\r\n    this.options.tmin = this.options.tmin || 0.0;\r\n    this.options.constant_temp_repositionings = this.options.constant_temp_repositionings || 10;\r\n    this.options.max_improvments_count = this.options.max_improvments_count || 10;\r\n    this.options.max_noimprove_count = this.options.max_noimprove_count || 20;\r\n    this.options.maxsteps = this.options.maxsteps || 100;\r\n    this.options.maxtotaliterations = this.options.maxtotaliterations || 100000;\r\n    this.options.minimizeTotalOverlappingArea=this.options.minimizeTotalOverlappingArea || false;\r\n    this.options.debug=this.options.debug || true;\r\n    this.options.allowBothSidesOfLine=this.options.allowBothSidesOfLine || true;\r\n    candidateGenerator.options.lineDiscreteStepPx = this.options.lineDiscreteStepPx || candidateGenerator.options.lineDiscreteStepPx; //pixels\r\n  },\r\n\r\n  /**\r\n  find optimal label placement based on simulated annealing approach, relies on paper https://www.eecs.harvard.edu/shieber/Biblio/Papers/jc.label.pdf\r\n  @param {Array} allsegs: an arr with labels and their available line segments to place\r\n  @param {Object} options: TODO [simulatedAnnealing] add options description\r\n  @param {Object} callback: a function to gather results and use them to render\r\n  @param {Object} context: a parent conext of the function  above (arguments.callee - but deprecated)\r\n  */\r\n  perform:function(allsegs,options,callback,context) {\r\n        if(allsegs.length<1){callback([])} //do nothing if no segments\r\n        else{\r\n          var t0 = performance.now();\r\n          this.processOptions(options);\r\n          //init\r\n          var curset=this.getInitialRandomState(allsegs), //current label postions\r\n           curvalues = this.evaluateCurSet(curset), //current overlaping matrix (conflict graph)\r\n           t=this.options.t0, stepcount=0, doexit=curvalues[curvalues.length-1] === 0,//if no overlaping at init state, do nothing and return curretn state\r\n           iterations=0, This=this;\r\n\r\n          var doReturn = function(dorender){\r\n            This.dodebug('-----');\r\n            if(dorender){\r\n              This.dodebug('overlapping labels count = '+curvalues.pop()+', total labels count = '+curset.length+', iterations = '+iterations);\r\n              This.dodebug('time to annealing = '+(performance.now()-t0));\r\n              This.markOveralppedLabels(curset,curvalues);\r\n              callback.call(context,curset);\r\n            }else{\r\n              This.dodebug('Map state has been changed. Terminated.');\r\n            }\r\n          }\r\n\r\n          //step\r\n          while(true){\r\n            var dorender=true;\r\n             //let know map which timer we are using\r\n            //while constant temperature, do some replacments:\r\n            //  while(t>options.tmin && stepcount<options.maxsteps && !doexit\r\n            if(t<=this.options.tmin || stepcount>=this.options.maxsteps){\r\n              doReturn(dorender);\r\n              return;\r\n            }\r\n            stepcount++;\r\n            var improvements_count=0, no_improve_count=0;\r\n            for(var i=0;i<this.options.constant_temp_repositionings*curset.length;i++){\r\n              var oldvalues = curvalues.slice(0); //clone curvalues in order to return to ld ones\r\n              var oldset = curset.slice(0);\r\n              //now replace randomly all positions, not a sim ann actually\r\n              //TODO [simulatedAnnealing] do actual sim ann - move only overlapping now labels to new random position, for example\r\n              var overlapped_indexes = this.getOverlappingLabelsIndexes(curvalues,curset);\r\n              this.applyNewPositionsForLabelsInArray(overlapped_indexes,curset,allsegs);\r\n              // this.evaluateAfterSeveralChanged(curvalues,curset,overlapped_indexes);\r\n              curvalues=this.evaluateCurSet(curset);\r\n              iterations++;\r\n              if(curvalues[curvalues.length-1] === 0){ //no overlaps already\r\n                This.dodebug('strict solution');\r\n                doReturn(dorender);\r\n                return;\r\n              }\r\n              if(iterations>this.options.maxtotaliterations){ //not to hang too long\r\n                doReturn(dorender);\r\n                return;\r\n              }\r\n              var delta = (oldvalues[oldvalues.length-1]-curvalues[curvalues.length-1]);\r\n              if(delta<0){//ie, new labeling is worse!\r\n                var P=1 - Math.exp(delta/t);\r\n                if(P>Math.random()){ //undo label reposition with probability of P\r\n                  curvalues = oldvalues;\r\n                  curset=oldset;\r\n                  no_improve_count++;\r\n                }else { //approve new repositioning\r\n                  improvements_count++;\r\n                  no_improve_count=0;\r\n                }\r\n              }else{\r\n                 improvements_count++;\r\n                 no_improve_count=0;\r\n               }\r\n              if(no_improve_count>=this.options.max_noimprove_count*curset.length){ //it is already optimal\r\n                This.dodebug('stable state, finish on it');\r\n                doReturn(dorender);\r\n                return;\r\n              }\r\n              if(improvements_count>=this.options.max_improvments_count*curset.length){\r\n                //immediately exit cycle and decrease current t\r\n                doReturn(dorender);\r\n                return;\r\n              }\r\n            }\r\n            //decrease t\r\n            t*=this.options.decrease_value;\r\n          };\r\n      }\r\n  }\r\n}\r\n\r\nmodule.exports = simulatedAnnealing;\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/simulatedAnnealing.js\n ** module id = 9\n ** module chunks = 0\n **/","var geomEssentials = require('./geomEssentials.js');\r\nvar itemFactory = require('./LabelItem.js');\r\n\r\nvar candidateGenerator = {\r\n  options:{\r\n    lineDiscreteStepPx:3\r\n  },\r\n\r\n  _aquireCandidateDataLine:function(segobj,position_on_seg){\r\n    var seg = segobj.seg.slice(0);\r\n    var segStartPt = seg[0],segEndPt=seg[1];\r\n    if(segStartPt.x>segEndPt.x){\r\n      var tmp=segStartPt; segStartPt=segEndPt; segEndPt=tmp; //be sure that text is always left-to-right\r\n    }\r\n    var ratio = position_on_seg / segobj.seglen;\r\n    var p2add = geomEssentials.interpolateOnPointSegment(segStartPt,segEndPt,ratio); //get actual insertion point for label\r\n    return {p2add:p2add,angle:segobj.angle};\r\n  },\r\n\r\n  obtainCandidateForPolyLineBySegmentIndex:function(seg_w_len,labelLength){\r\n    if(!seg_w_len){\r\n      return;\r\n    }\r\n    var seg = seg_w_len.seg, seglen = seg_w_len.seglen, pos = 0;\r\n    //now we need not let label exceed segment length. If seg is too small, the ratio shoud be zero\r\n    //so, calculate ratio as following:\r\n    if(labelLength<seglen){\r\n      var discrete_seg_len = ((seglen-labelLength) / this.options.lineDiscreteStepPx);\r\n      pos =(Math.floor(Math.random()*discrete_seg_len)*this.options.lineDiscreteStepPx);//index of selected part of segemnt to place label\r\n    }\r\n    return this._aquireCandidateDataLine(seg_w_len,pos);\r\n  },\r\n\r\n  obtainCandidateForPoint(point){\r\n    //TODO[obtainCandidateForPoint]\r\n  },\r\n\r\n  obtainCandidateForPoly(polygon){\r\n    //TODO[obtainCandidateForPoly]\r\n  },\r\n\r\n  /**\r\n  based on https://blog.dotzero.ru/weighted-random-simple/\r\n  get a random element from segments array of the item, assuming it is sorted lengths ascending order\r\n  probability is higher for longer segment\r\n  */\r\n  getIndexBasedOnTotalLengthRandom:function(item){\r\n    var random_pos = Math.random()*item.total_length; //get a position random for all segments of this polyline visible on the screen\r\n    //obtain and index of segment, to which belongs this position, it is assumed tha segments are sorted by length\r\n    var clen=0;\r\n    for(var i=0;i<item.segs.length;i++){\r\n      clen+=item.segs[i].seglen;\r\n      if(clen>random_pos)break;\r\n    }\r\n    return i;\r\n  },\r\n\r\n  /**\r\n  Get a segment from polyline part by it's offset\r\n  @param {Number} offset: na offset for the polyline\r\n  @param {Object} item: item from prepareCurSegments's allsegs\r\n  @returns {Object} : index of segment and dist which is offset from start of the line to the end of found segment\r\n  */\r\n  _getSegmentIdxAndDistByOffset:function(offset,item){\r\n    cdist=0;\r\n    for(var i in item.segs){\r\n      cdist+=item.segs[i].seglen;\r\n      if(offset<cdist){\r\n        return {index:i,dist:cdist};\r\n      }\r\n    }\r\n    return {index:i,dist:cdist};\r\n  },\r\n\r\n  /**\r\n  Get a poly (simple with no text along path)for random offset on the polyline\r\n  @param {Object} item: item from prepareCurSegments's allsegs\r\n  @returns {Array} : a poly bounding text, placed on corresponding point for offset on poluline and rotated to match segment's skew\r\n  */\r\n  obtainCandidateForPolyLineByRandomStartOffset:function(item){\r\n    var random_offset = item.total_length*Math.random(),\r\n        idxNdist = this._getSegmentIdxAndDistByOffset(random_offset,item),\r\n        seg = item.segs[idxNdist.index],\r\n        pos = seg.seglen - (idxNdist.dist - random_offset);\r\n    return this._aquireCandidateDataLine(seg,pos);\r\n  },\r\n\r\n  /**\r\n  Used for calculationg overlaps for text along path (textPath SVG).\r\n  @param {Number} start_offset: global offset for this polyline (item), same as used in rendering\r\n  @param {Object} item: item from prepareCurSegments's allsegs\r\n  @returns {Array} : a poly bounding curved text\r\n  */\r\n  computeComplexPolyForLine:function(start_offset,item){\r\n    var idxNdistStart = this._getSegmentIdxAndDistByOffset(start_offset,item);\r\n    var labelLength = item.t.poly[2][0], labelHeight = Math.abs(item.t.poly[1][1]),\r\n        segStart = item.segs[idxNdistStart.index],\r\n        labelSpaceOnFirstSegment = (idxNdistStart.dist - start_offset);\r\n\r\n    //TODO [computeComplexPolyForLine] check left-to-right text orientation on final polygone!\r\n    var getAboveLine = function(seg,offset,len,height){ //compute above line according to remained length on this segment\r\n      var actual_len = Math.min(len,seg.seglen-offset);\r\n      var normal = geomEssentials.getNormalOnSegment(seg).multiplyBy(height);\r\n      var firstPt = geomEssentials.interpolateOnPointSegment(seg.seg[0],seg.seg[1],offset/seg.seglen).add(normal);\r\n      var endPt = geomEssentials.interpolateOnPointSegment(seg.seg[0],seg.seg[1],(offset+actual_len)/seg.seglen).add(normal);\r\n      return {line:[firstPt,endPt],minusLen:actual_len};\r\n    }\r\n\r\n    //in the next lines we construct upper boundary of total polygone - lower is polyline actually =)\r\n    //now fill above lines\r\n    var above_line = [getAboveLine(segStart,segStart.seglen -  labelSpaceOnFirstSegment,labelLength,labelHeight)];\r\n    var above_lines = [above_line.line];\r\n    var finishOnLineBelow = above_line.line[1];\r\n    var remaining_length = labelLength-above_line.minusLen;\r\n    //if we have more than 1 segment to cover:\r\n    if(labelSpaceOnFirstSegment < labelLength && idxNdistStart.index<(item.segs.length-1)){\r\n      var idxNdisEnd = this._getSegmentIdxAndDistByOffset(start_offset+labelLength,item);\r\n      for(var i=idxNdistStart.index+1;i<=idxNdisEnd.index;i++)if(remaining_length>0){\r\n        var temp_line = [getAboveLine(item.segs[i],0,remaining_length,labelHeight)];\r\n        above_lines.push(temp_line.line);\r\n        remaining_length-=temp_line.minusLen;\r\n        finishOnLineBelow=temp_line.line[1];\r\n      }\r\n    }\r\n\r\n    //if we have some unsused length\r\n    //TODO [computeComplexPolyForLine] check if it is draw actually, so no add to polyline part (below)\r\n    if(remaining_length>0){\r\n      var last_segment_expanded = geomEssentials.expandSegment(above_lines.pop(),remaining_length);\r\n      above_lines.push(last_segment_expanded);\r\n    }\r\n\r\n    var TINY = 1; //beacouse 1px is tiny on screen\r\n    var poly=[geomEssentials.interpolateOnPointSegment(segStart.seg[0],segStart.seg[1],(segStart.seglen -  labelSpaceOnFirstSegment)/segStart.seglen)]; // a result! init with first point on polyline\r\n    poly.push(above_lines[0][0]);\r\n    //expand / slice lines to have a continius boundary above\r\n    for(var j=1;j< above_lines.length;j++){\r\n      var endOfPrev = above_lines[j-1][1];\r\n      var startOfThis =  above_lines[j][0];\r\n      if(startOfThis.distanceTo(endOfPrev)>TINY){\r\n        //add middle line\r\n      }else{\r\n        poly.push(endOfPrev);\r\n      }\r\n    }\r\n\r\n    //push last vertex of above;\r\n    poly.push(above_lines[j][1]);\r\n\r\n    //now add polyline pts, in reverse order\r\n    poly.push(finishOnLineBelow);\r\n    if(idxNdisEnd){ //more than 1 seg\r\n      for(var k=idxNdisEnd.index;k>idxNdistStart.index;k--){\r\n        poly.push(item.segs[k].seg[0]);\r\n      }\r\n    }\r\n    //now compute poly from below and above boundary\r\n\r\n    return poly; //starting with insertion point on the line\r\n  },\r\n  /**\r\n  computes label candidate object to place on map\r\n  @param {Number} i: an index in allsegs array to obtain label for candidate and segments array wuth segments to choose\r\n  @returns {Object} : an object with {t,poly,pos,a,allsegs_index} elements, such as t - text to label,poly - bounding rect of label, pos - pos to place label, a - angle to rotate label,allsegs_index - index in segments array\r\n  */\r\n  computeLabelCandidate:function(i,all_items) {\r\n    var t = all_items[i].t; //label part\r\n    var segs = all_items[i].segs;\r\n\r\n    //choose the segment index from parts visible on screeen\r\n    //here we should prioritize segments with bigger length\r\n    //assuming segs array is sorted ascending using segment length\r\n    //var idx =this.getIndexBasedOnTotalLengthRandom(all_items[i]);\r\n    var idx = Math.floor(Math.random()*segs.length);\r\n    var poly,point_and_angle;\r\n    poly = all_items[i].t.poly;\r\n\r\n    switch (all_items[i].layertype) {\r\n      case 0:\r\n        break;\r\n      case 1:\r\n        point_and_angle=this.obtainCandidateForPolyLineByRandomStartOffset(all_items[i]);\r\n        // point_and_angle=this.obtainCandidateForPolyLineBySegmentIndex(segs[idx],t.poly[2][0]);\r\n        break;\r\n      case 2:\r\n        break;\r\n    }\r\n\r\n    if(!point_and_angle){\r\n      this.dodebug('error is here');\r\n    }\r\n    if(point_and_angle.angle)poly=geomEssentials.rotatePoly(poly,[0,0],point_and_angle.angle); //rotate if we need this\r\n    poly=geomEssentials.movePolyByAdding(poly,[point_and_angle.p2add.x,point_and_angle.p2add.y]);\r\n    return {t:t,poly:poly,pos:point_and_angle.p2add,a:point_and_angle.angle,all_items_index:i};;\r\n  },\r\n}\r\n\r\nmodule.exports = candidateGenerator;\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/CandidateGenerator.js\n ** module id = 10\n ** module chunks = 0\n **/","/**\r\nModule to extract sufficient info to label data on the map\r\n*/\r\n\r\n\"use strict\";\r\n\r\nvar DOMEssentials = require(\"./DOMEssentials.js\");\r\nvar geomEssentials = require(\"./geomEssentials.js\");\r\nvar itemFactory = require('./LabelItem.js');\r\n\r\nvar dataReader = {\r\n  /**\r\n  creates an array of features's segments for each feature  of layers2label's layers on screen along with SVG text corresponding to\r\n  @returns [Array] returns an array with values : {t:{content_node:SVG textnode},parts:feature parts,layertype}, then, in next funcs we add apoly param to t object, ir, its bounding polygon, layertype = 0 marker, 1 polyline, 2 polygon\r\n  */\r\n  readDataToLabel:function(){\r\n    var pt  =[];\r\n    if(this._map){\r\n      for(var i in this._map.autoLabeler._layers2label)\r\n      if(this._map.getZoom()>this._map.autoLabeler._layers2label[i]._al_options.zoomToStartLabel)\r\n      {\r\n        var lg=this._map.autoLabeler._layers2label[i],\r\n            map_to_add = this._map;\r\n        lg.eachLayer(function(layer){\r\n          if(layer.feature)\r\n          if(layer.feature.properties[lg._al_options.propertyName]){\r\n            var node = DOMEssentials.createSVGTextNode(layer.feature.properties[lg._al_options.propertyName],lg._al_options.labelStyle),\r\n                size = DOMEssentials.getBoundingBox(map_to_add,node); //compute ortho aligned bbox for this text, only once, common for all cases\r\n            var firstItem = itemFactory.LabelItem(node,size,layer), nextPartIndex=firstItem.readData();\r\n            pt.push(firstItem);\r\n            while(nextPartIndex){\r\n              var item = itemFactory.LabelItem(node,size,layer); //create node template\r\n              nextPartIndex=item.readData(nextPartIndex);\r\n              pt.push(item);\r\n            }\r\n          }\r\n        });\r\n      }\r\n    }\r\n    return pt;\r\n  },\r\n\r\n  /**\r\n  extracts good segments from available polyline parts and converts to use in next procedures of pos estimation\r\n  @param {Array} all_items:\r\n  @param {Set} options: options are:  {integer} maxlabelcount: if more labels in all_items, then do nothing\r\n  */\r\n  prepareCurSegments:function(all_items,options){\r\n    options = options || {};\r\n    options.maxlabelcount=options.maxlabelcount || 100;\r\n    if(all_items.length>options.maxlabelcount || all_items.length==0){\r\n      this._map._dodebug('too much OR no labels to compute('+all_items.length+')');\r\n      return false;\r\n    }\r\n    for(var i=0;i<all_items.length;i++){\r\n      var item = all_items[i];\r\n      if(item.layer_type()==0){//if point -> do nothing.\r\n        continue;\r\n      }\r\n      //else compute for lines and polygons, now it is only fo lines\r\n      if(item.layertype==1){\r\n        this._applyLineFeatureData(item); //in case where two or move separate polylines generated for original polyline while rendering (imagine big W cutted by screen iwndow)\r\n      }\r\n    }\r\n    return true;\r\n  },\r\n\r\n  /**\r\n  Calculates total length for this polyline on screen, and lengths of each segments with their angles\r\n  @param {labelItem} item: an item to get above data to\r\n  */\r\n  _applyLineFeatureData:function(item){ //calculate some data once to increase performance\r\n      item.totalLength=0;\r\n      for(var k=1;k<item.data.length;k++){\r\n        var a = item.data[k-1], b = item.data[k],\r\n            ablen = a.distanceTo(b), //compute segment length only once\r\n            abangle = geomEssentials.computeAngle(a,b,true); //same for angles\r\n        item.segdata.push({seglen:ablen,angle:abangle});\r\n        item.totalLength+=ablen;\r\n      }\r\n  },\r\n\r\n  _getLineSegmentBoundaryPoly:function(item){\r\n    //TODO [_getLineSegmentBoundaryPoly]\r\n    // var labelLength = item.t.poly[2][0];\r\n  },\r\n\r\n  prepareGeneralConflictGraph:function(all_segs){\r\n    //TODO[prepareGeneralConflictGraph]\r\n  }\r\n}\r\n\r\nmodule.exports = dataReader;\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/DataReader.js\n ** module id = 11\n ** module chunks = 0\n **/","/*\r\nmodlue to create labelItems convenient for labelling and calculation\r\n*/\r\n\r\nmodule.exports = {\r\n  /**\r\n  a factory function for label items\r\n  @param {TextNode} txNode: SVG TextNode\r\n  @param {L.Point} txSize: size of bounding box for txNode\r\n  @param {L.Layer} layer: a feature (Marker, Polyline, Path) to aquire data\r\n  */\r\n  labelItem:function(txNode,txSize,layer){\r\n    var basic_item= {\r\n      txNode:txNode,\r\n      txSize:txSize,\r\n      layer:layer,\r\n      readData:function(){}, //a method stub\r\n      layer_type:function(){ //return a layer type, where 0 is point, 1 is line, 2 is poly\r\n        if(layer instanceof  L.CircleMarker || L.Marker)return 0;\r\n        if(layer instanceof L.Polyline)return 1;\r\n        if(layer instanceof L.Polygon)return 2;\r\n      }\r\n    };\r\n\r\n    if(basic_item.layer_type()==0){\r\n      basic_item.data=L.Map.latLngToLayerPoint(layer.getLatLngs()); //so we adding only L.Point obj\r\n    }else{\r\n      //this give possibility to read all parts to separate items\r\n      basic_item.readData=function(partIndex){ //to read consequently\r\n        if(!partIndex){var partIndex=0;};\r\n        this.data = this.layer._parts[partIndex];\r\n        this.partIndex=partIndex; //store this to have ability to compute totalOffset, for example\r\n        var nextPart=partIndex++;\r\n        if(nextPart<this.layer._parts.length)return nextPart;\r\n      }\r\n    }\r\n\r\n    if(basic_item.layer_type()==1){\r\n      basic_item.segdata=[];\r\n      basic_item.totalLength=0;\r\n      basic_item.getSegment = function(index){\r\n        var a = this.data[index-1], b = this.data[index];\r\n        return [a,b,this.segdata[index-1]];\r\n      }\r\n    }\r\n    return basic_item;\r\n  },\r\n  resItem:function(item_ind,offset_or_origin){\r\n    return {\r\n      item_ind:item_ind,\r\n      offset_or_origin:offset_or_origin\r\n    }\r\n  },\r\n\r\n}\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/LabelItem.js\n ** module id = 12\n ** module chunks = 0\n **/"],"sourceRoot":""}