{"version":3,"sources":["webpack:///webpack/bootstrap 35ff59f00604ef0d81d9","webpack:///./src/MapPart.js","webpack:///./src/autoLabeler.js","webpack:///./src/DOMEssentials.js","webpack:///./src/simulatedAnnealing.js","webpack:///./src/CandidateGenerator.js","webpack:///./src/LabelItem.js","webpack:///./src/DataReader.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;ACtCA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;;AAGL;AACA;AACA;AACA,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA,uEAAsE,iBAAiB,kBAAkB,EAAE;AAC3G;AACA,yDAAwD;AACxD;AACA;AACA,MAAK;;AAEL;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX,QAAO;;AAEP,EAAC;;;;;;;AClED;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,oCAAmC;AACnC,kDAAiD;AACjD,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA0C,sBAAsB;AAChE,yCAAwC,sBAAsB;AAC9D;AACA,MAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA8D,kBAAkB;AAChF;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,kCAAiC;AACjC;AACA;AACA;AACA,kDAAiD,iBAAiB;AAClE;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,mBAAkB,cAAc;AAChC;AACA;AACA;AACA;AACA,8CAA6C,kBAAkB,eAAe;AAC9E;AACA,oDAAmD,kBAAkB,eAAe;AACpF;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,qDAAoD;AACpD,mBAAkB,qBAAqB,KAAK;AAC5C;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,wDAAuD;AACvD,0BAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAkC;AAClC;AACA;AACA;AACA;AACA,sCAAqC;AACrC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;ACrLA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAU,cAAc;AACxB,aAAY;AACZ;AACA;AACA;AACA;AACA,2CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,WAAU,OAAO;AACjB,WAAU,OAAO;AACjB,aAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,WAAU,OAAO;AACjB,WAAU,OAAO;AACjB,aAAY,SAAS;AACrB;AACA;AACA,yCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACnDA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,WAAU,MAAM,2BAA2B,OAAO;AAClD,aAAY,MAAM;AAClB;AACA;AACA;AACA,iBAAgB,mBAAmB;AACnC;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,WAAU,MAAM;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,WAAU,MAAM;AAChB,aAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,yBAAwB;AACxB;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,WAAU,OAAO;AACjB,WAAU,MAAM;AAChB,WAAU,MAAM;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA,WAAU,MAAM;AAChB,WAAU,MAAM;AAChB,WAAU,OAAO;AACjB;AACA;AACA,mBAAkB;AAClB;AACA;AACA,mBAAkB,gBAAgB;AAClC,qBAAoB,gBAAgB,KAAK,QAAQ;AACjD,4DAA2D;AAC3D,6HAA4H;AAC5H;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAoB;AACpB;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA,sEAAqE;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sIAAqI;AACrI,IAAG;;AAEH;AACA;AACA,WAAU,MAAM;AAChB,WAAU,OAAO;AACjB,WAAU,OAAO;AACjB,WAAU,OAAO;AACjB;AACA;AACA,gCAA+B,aAAa;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAwB,0DAA0D,KAAK;AACvF;AACA;AACA;AACA;AACA;AACA;AACA,uDAAsD;AACtD;AACA;AACA;AACA;AACA,8DAA6D;AAC7D;AACA;AACA;AACA;AACA,2BAA0B;AAC1B;AACA,qCAAoC;AACpC;AACA;AACA;AACA,kBAAiB,MAAM;AACvB;AACA;AACA;AACA,gBAAe;AACf;AACA;AACA;AACA,oFAAmF;AACnF;AACA;AACA;AACA;AACA;AACA,uBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;;;;;;ACrOA;AACA;;AAEA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA,WAAU,OAAO;AACjB,aAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,WAAU,OAAO;AACjB,aAAY,kBAAkB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;;;;;;;AChDA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,WAAU,SAAS;AACnB,WAAU,QAAQ;AAClB,WAAU,QAAQ;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP,2BAA0B,aAAa;AACvC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oGAAmG;AACnG;AACA,MAAK;AACL;AACA,+CAA8C;AAC9C,wBAAuB;AACvB;AACA,kCAAiC;AACjC;AACA,8DAA6D;AAC7D;AACA;;AAEA;AACA;AACA;AACA;;AAEA,wCAAuC;;AAEvC;AACA;AACA,eAAc,OAAO;AACrB,iBAAgB,MAAM;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA;AACA,eAAc,OAAO;AACrB,eAAc,UAAU;AACxB,iBAAgB,MAAM;AACtB;AACA;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;;;;;;;ACpHA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,oDAAmD,GAAG,0BAA0B,+BAA+B;AAC/G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAqE;AACrE;AACA;AACA;AACA;AACA;AACA,sEAAqE;AACrE;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,WAAU,MAAM;AAChB,WAAU,IAAI,yBAAyB,QAAQ;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB,mBAAmB;AACnC;AACA,gCAA+B;AAC/B;AACA;AACA;AACA;AACA,0CAAyC;AACzC;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,WAAU,UAAU;AACpB;AACA,wCAAuC;AACvC;AACA;AACA,mBAAkB,+BAA+B;AACjD;AACA;AACA;AACA;;AAEA","file":"l.autolabelSA.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"./\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 35ff59f00604ef0d81d9\n **/","(function () {\r\n  \"use strict\";\r\n\r\n  var autoLabeler = require('./autoLabeler.js');\r\n\r\n  var __onRemove = L.LayerGroup.prototype.onRemove;\r\n  //to include in LabelGroup\r\n  var AutoLabelingSupport = {\r\n      /**\r\n      handle removing layer from the map\r\n      */\r\n      onRemove: function (map) {\r\n      this.disableAutoLabel();\r\n        __onRemove.call(this, map);\r\n    },\r\n\r\n\r\n    /**\r\n     enable autolabeling for this layerGroup, additionally set the current_map variable if it is undefined and hooks label painting on moveend /zoomend events\r\n     it adds this layerGroup to the _layers2label array, so _doAutoLabel function will know about this layerGroup\r\n     @param {Object} options: labelStyle - css string to describe labels look, for now one for all layers in group, propertyName - a property from layer.feature.properties which we label on map\r\n    */\r\n    enableAutoLabel:function(options){\r\n      if(!this._map)return;\r\n      if(!this._map.autoLabeler)return;\r\n      this._al_options = options || {};\r\n      this._al_options.labelStyle = options.labelStyle || \"fill: lime; stroke: #000000;  font-size: 20px;\"; //TODO [enableAutoLabel] add ability to set unique style for each feature\r\n      this._al_options.propertyName = options.propertyName || \"name\";\r\n      this._al_options.priority = options.priority || 0; //highest\r\n      this._al_options.zoomToStartLabel = options.zoomToStartLabel || this._map.autoLabeler.options.zoomToStartLabel;\r\n      this._map.autoLabeler.addLayer(this);\r\n    },\r\n\r\n    /**\r\n    Obtain autlabelling state for this layerGroup\r\n    @returns {Boolean}\r\n    */\r\n    autoLabelEnabled:function(){\r\n      if(!this._map.autoLabeler)return false;\r\n      return this._map.autoLabeler.hasLayer(this);\r\n    },\r\n\r\n    /**\r\n    disable autolabelling\r\n    */\r\n    disableAutoLabel:function(){\r\n      if(!this._map.autoLabeler){\r\n        delete this._al_options;\r\n        return;\r\n      }\r\n      if(this._map.autoLabeler.remLayer(this)){\r\n        delete this._al_options;\r\n      }\r\n    }\r\n  }\r\n\r\n  L.LayerGroup.include(AutoLabelingSupport);\r\n\r\n  L.Map.addInitHook(function () {\r\n          this.whenReady(function () {\r\n              if (this.options.autolabel) {\r\n                this.autoLabeler = L.autoLabeler(this,this.options.autolabelOptions)\r\n              }\r\n          });\r\n      });\r\n\r\n})();\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/MapPart.js\n ** module id = 0\n ** module chunks = 0\n **/","var DOMEssentials = require('./DOMEssentials.js');\r\nvar geomEssentials = require('./geomEssentials.js');\r\nvar simulatedAnnealing = require('./simulatedAnnealing.js');\r\nvar dataReader = require('./DataReader.js');\r\n\r\nL.AutoLabeler = L.Evented.extend(\r\n {\r\n    _nodes:[], //an array for storing SVG node to draw while autolabelling\r\n    _layers2label:[], //an array to know which layergroups are to label\r\n    options:{\r\n      showBBoxes:false, //display bounding boxes around texts\r\n      debug:true,//show debug info in hte cons\r\n      labelsDelay:1000,//a time after update event of renderer when labelling should start, if zero - errors while zooming\r\n      checkLabelsInside:true,//re-clip all segments to entirely fit map window without padding, disabling increases performance, but some labels maybe invisible due to padding of renderer\r\n      zoomToStartLabel:13,//if map zoom lev is below this, do not show labels\r\n      minimizeTotalOverlappingArea:false, //if true, minimize not the count of overlapping labels, but instead their total overlapping area\r\n      deleteIfNoSolution:false,//TODO [setAutoLabelOptions] if no solution can be achieivd, delete some of the labels, which are overlapping, based on their layer al_options.priority or random if equal\r\n      doNotShowIfSegIsTooSmall:false, //TODO [setAutoLabelOptions] if segment length is less then textlength of text, do not show this text\r\n      annealingOptions:{}\r\n    }, //autolabel options\r\n\r\n    _autoLabel:false, //to determine if autolabelling is set for this map\r\n\r\n    initialize: function (map, options) {\r\n      L.setOptions(this, options);\r\n      this._map=map;\r\n    },\r\n\r\n    hasLayer:function(layer){\r\n      return this._layers2label.indexOf(layer)!=-1;\r\n    },\r\n\r\n    addLayer:function(layer){\r\n      if(!this.hasLayer(layer))this._layers2label.push(layer);\r\n    },\r\n\r\n    remLayer:function(layer){\r\n      var ind=this._layers2label.indexOf(layer);\r\n      if(ind>=0){\r\n        this._layers2label.splice(ind,1);\r\n      }\r\n      return ind>=0;\r\n    },\r\n\r\n    /**\r\n    toggles autolabeling\r\n    */\r\n    toggleAutoLabelling:function(){ //this not tested yet\r\n      if(this._autoLabel)this.disableAutoLabel();else this.enableAutoLabel();\r\n    },\r\n\r\n    /**\r\n    enable autolabeling\r\n    */\r\n    enableAutoLabel:function(){\r\n      if(!this._map){\r\n        this._dodebug('no map attached');\r\n        return;\r\n      }\r\n      if(!this._map.options.renderer){\r\n        this._dodebug('renderer is invalid');\r\n        return;\r\n      }\r\n      this._map.options.renderer.on(\"update\",this._apply_doAutoLabel);\r\n      this._map.on(\"zoomstart\",function(){this._zoomstarttrig=1});\r\n      this._map.on(\"zoomend\",function(){this._zoomstarttrig=0});\r\n      this._autoLabel = true;\r\n    },\r\n\r\n    //to check if zoomstart event is fired to prevent autolabeling BEFORE zoomend\r\n    _zoomstarttrig:0,\r\n\r\n    //id of timeout after which AutoLabeling should be done each time - used to stop timer in case of changed map state BEFORE autolabelling was performed\r\n    _ctimerID:-1,\r\n\r\n    /**\r\n    disable autolabeling for this map\r\n    */\r\n    disableAutoLabel:function(){\r\n      this._map.options.renderer.off(\"update\",this._apply_doAutoLabel);\r\n      this._autoLabel=false;\r\n    },\r\n\r\n    /*\r\n    beacuse we using update event of renderer, here we switching to map context and handling two-time update event of SVG renderer\r\n    */\r\n    _apply_doAutoLabel:function(){\r\n      if(this._map.autoLabeler._ctimerID!=-1)clearTimeout(this._map.autoLabeler._ctimerID);\r\n      if(this._map.autoLabeler._zoomstarttrig==0){\r\n        var al = this._map.autoLabeler;\r\n        var lDelay = this._map.autoLabeler.options.labelsDelay;\r\n        this._map.autoLabeler._ctimerID=setTimeout(function(){al._doAutoLabel()},lDelay);\r\n      }\r\n      this._map.autoLabeler._clearNodes();\r\n    },\r\n\r\n    _dodebug:function(message){\r\n      if(this.options.debug)console.log(message);\r\n    },\r\n\r\n    /**\r\n    this function obtains visible polyline segments from screen and computes optimal positions and draws labels on map\r\n    */\r\n    _doAutoLabel:function() {\r\n      if(!this._autoLabel)return; //nothing to do here\r\n      if(this._map.getZoom()>this.options.zoomToStartLabel){\r\n        dataReader._map=this._map;\r\n        var all_items  =dataReader.readDataToLabel(this._map) //array for storing paths and values\r\n        dataReader.prepareCurSegments(all_items,{maxlabelcount:80});\r\n        if(all_items.length==0){\r\n          this._clearNodes();\r\n          return;\r\n        }\r\n        simulatedAnnealing.perform(all_items,this.options.annealingOptions,this._renderNodes,this);\r\n      }else{\r\n        this._clearNodes();\r\n      }\r\n    },\r\n\r\n    /**\r\n    for test purposes now, creates a polygon node useing poly Array of points\r\n    */\r\n    _createPolygonNode:function(poly,highlited){\r\n      var node = L.SVG.create('polygon');\r\n      var points='';\r\n      for(var i=0;i<poly.length;i++){\r\n        points+=poly[i].x+','+poly[i].y+' ';\r\n      }\r\n      node.setAttribute('points', points.trim());\r\n      if(highlited){\r\n        node.setAttribute('style','fill: red; fill-opacity:0.3; stroke: black;');\r\n      }\r\n      else node.setAttribute('style','fill: yellow; fill-opacity:0.1; stroke: black;');\r\n      return node;\r\n    },\r\n\r\n    /**\r\n    clears label on the screen\r\n    */\r\n    _clearNodes:function() {\r\n    var svg = this._map.options.renderer._container;  //to work with SVG\r\n      for(var i=0;i<this._nodes.length;i++){//clear _nodes on screen\r\n        svg.removeChild(this._nodes[i]);\r\n      }\r\n      this._nodes=[];\r\n      // this._dodebug(\"Cleared nodes\");\r\n    },\r\n\r\n    /**\r\n    renders computed labelset on the screen via svg\r\n    TODO [_renderNodes] place textOnPath\r\n    */\r\n    _renderNodes:function(labelset){\r\n      var svg =  this._map.options.renderer._container;  //to work with SVG\r\n      this._clearNodes(); //clearscreen\r\n      for(var m in labelset){\r\n        // var node = labelset[m].t.content_node;\r\n        // var x = labelset[m].pos.x;\r\n        // var y = labelset[m].pos.y;\r\n        // node.setAttribute('x', x);\r\n        // node.setAttribute('y', y);\r\n        // var transform ='rotate('+ Math.floor(labelset[m].a)+','+Math.floor(x)+','+Math.floor(y)+')';\r\n        // transform = transform.replace(/ /g, '\\u00A0');\r\n        // node.setAttribute('transform',transform);\r\n        // svg.appendChild(node);\r\n        // this._nodes.push(node);//add this labl to _nodes array, so we can erase it from the screen later\r\n        if(this.options.showBBoxes){\r\n          //here for testing purposes\r\n          var polynode = this._createPolygonNode(labelset[m].poly(),labelset[m].overlaps);\r\n          svg.appendChild(polynode);\r\n          this._nodes.push(polynode); //add this polygon to _nodes array, so we can erase it from the screen later\r\n        }\r\n      }\r\n    }\r\n  }\r\n)\r\n\r\nL.autoLabeler = function(map,options){\r\n  return new L.AutoLabeler(map,options);\r\n}\r\n\r\n// module.exports = autoLabeler;\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/autoLabeler.js\n ** module id = 1\n ** module chunks = 0\n **/","//a class to compute pixel dimensions of texts\r\n/** @namespace DOMEssentials*/\r\n'use strict';\r\nvar geomEssentials = require(\"./geomEssentials.js\");\r\n\r\nmodule.exports = {\r\n  /**\r\n  converts TextRectangle object to clockwise array of 2d-arrays, representing rectangular poly\r\n  @param {TextRectangle} rect: a bbox for text\r\n  @returns {Array}\r\n  @memberof DOMEssentials#\r\n  */\r\n  convertClientRectToArrayOfArrays:function(rect) {\r\n    var res=[];\r\n    var height_correction=rect.height*0.2; //beacuse getBoundingClientRect give a bit false height info\r\n    res.push([0,0]);\r\n    res.push([0,-rect.height]);\r\n    res.push([rect.width,-rect.height]);\r\n    res.push([rect.width,0]);\r\n    res=geomEssentials.movePolyByAdding(res,[0,height_correction]);\r\n    return res;\r\n  },\r\n\r\n  /**\r\n  returns a bounding box for horizontal text with style as in t.content_node\r\n  @param {Object} map: current map\r\n  @param {Object} node: textNode\r\n  @returns {L.Point} : a bbox for node, as width and height\r\n  @memberof DOMEssentials#\r\n  */\r\n  getBoundingBox:function(map,node){\r\n    var svg = map.options.renderer._container;\r\n    svg.appendChild(node);\r\n    var rect = node.getBoundingClientRect();\r\n    svg.removeChild(node);\r\n    return L.point(rect.width,rect.height);\r\n  },\r\n\r\n  /**\r\n  creates SVG text node with specified style and handles some formatting issues\r\n  @param {String} text: text for node\r\n  @param {String} textstyle: CSS style String\r\n  @returns {TextNode} : SVG node\r\n  */\r\n  createSVGTextNode:function(text,textstyle){\r\n    text = text.replace(/ /g, '\\u00A0');  // Non breakable spaces\r\n    var node =L.SVG.create('text');\r\n    node.setAttribute('style',textstyle);\r\n    node.textContent = text;\r\n    return node;\r\n  }\r\n}\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/DOMEssentials.js\n ** module id = 2\n ** module chunks = 0\n **/","'use strict';\r\n\r\nvar geomEssentials = require(\"./geomEssentials.js\");\r\nvar candidateGenerator = require(\"./CandidateGenerator.js\");\r\n\r\nvar simulatedAnnealing = {\r\n\r\n  /**\r\n  computes the random set of positions for text placement with angles and text values\r\n  @param {Array} all_items: an array with {t,segs} elements, according to t -text of the polyline, segs - its accepted segments to label on. Result array is generated from items of this array\r\n  @returns {Array} : an array with elements such as return values of computeLabelCandidate function\r\n  */\r\n  getInitialRandomState:function(all_items){\r\n    var res=[];\r\n    for(var i=0;i<all_items.length;i++){\r\n      var candidate = candidateGenerator.computeLabelCandidate(i,all_items);\r\n      res.push(candidate);\r\n    }\r\n    return res;\r\n  },\r\n\r\n  /**\r\n  may be a custom function, must add result as last value of input array\r\n  @param {Array} overlapping_values: input array of areas\r\n  */\r\n  assignCostFunctionValuesToLastEl:function(overlapping_values){\r\n    var res=0;\r\n    for(var i in overlapping_values){\r\n      res+=overlapping_values[i];\r\n    }\r\n    overlapping_values.push(res);\r\n  },\r\n\r\n  /**\r\n  summarizing ovelapping of all layers. We store for each label it's total overlapping area with others, the sum values for all labels\r\n  @param {Array}:curset:\r\n  @returns {Array}: values of areas, last is sum\r\n  @memberof MapAutoLabelSupport#\r\n  */\r\n  evaluateCurSet:function(curset){\r\n    var overlap_values=[];\r\n    for(var i in curset){\r\n      for(var j in curset){\r\n        if(i>j){ //to exclude variants like compare (1,3) and then (3,1)\r\n        var curlabel_value=geomEssentials.checkOverLappingArea(curset[i].poly(),curset[j].poly(),this.options.minimizeTotalOverlappingArea);\r\n        //for each pair(i,j) push it's value into overlap_values array\r\n        //we know that we iterate through only lower triangle of matrix (i,j), so we can reconstruct i and j from overlap_values index and vice versa\r\n        //we do it to improve speed when recomputing ovelaps in each annealing iteration in order not to compute all overlaps (with high performance cost)\r\n        //istead we recompute areas only for changed label\r\n        overlap_values.push(curlabel_value);\r\n        }\r\n      }\r\n    }\r\n    this.assignCostFunctionValuesToLastEl(overlap_values);\r\n    return overlap_values;\r\n  },\r\n\r\n  markOveralppedLabels:function(curset,overlappedvalues){\r\n    var counter=0;\r\n    for(var i in curset){\r\n      for(var j in curset){\r\n        if(i>j){\r\n          if(overlappedvalues[counter]>0){\r\n            curset[i].overlaps = true;\r\n            curset[j].overlaps = true;\r\n            // this.dodebug(curset[i].t.content_node.textContent +' /// '+curset[j].t.content_node.textContent  )\r\n          }\r\n          counter++;\r\n        }\r\n      }\r\n    }\r\n  },\r\n\r\n  getOverlappingLabelsIndexes:function(curvalues,curset){\r\n    var counter=0, result=[];\r\n    for(var i in curset)\r\n     for(var j in curset)if(i>j){\r\n       if(curvalues[counter]>0){\r\n         result.push(i); result.push(j);\r\n       }\r\n       counter++;\r\n     }\r\n    return result;\r\n  },\r\n\r\n  /**\r\n  swaps position for a random label with another from this label's positions pool\r\n  @param {Number} index : index of label in all_items to select new random position from availavle choices.\r\n  @param {Array} curset: currently selected label postions\r\n  @param {Array} all_items: all available postions\r\n  @memberof MapAutoLabelSupport#\r\n  */\r\n  swapCandidateInLabelSetToNew:function(idx,curset,all_items){\r\n    var label_index = curset[idx].all_items_index();\r\n    var new_candidate = candidateGenerator.computeLabelCandidate(label_index,all_items);\r\n    curset[idx]=new_candidate;\r\n  },\r\n\r\n  applyNewPositionsForLabelsInArray:function(idx_array,curset,all_items){\r\n    for(var i in idx_array)this.swapCandidateInLabelSetToNew(idx_array[i],curset,all_items);\r\n  },\r\n\r\n  /**\r\n  calculates total overlapping area with knowlesge of previous value and what label was moved, affects curvalues\r\n  @param {Array} curvalue: array of float computed at previous step or initital step, consist of elements of lower-triangluar matrix (i,j) of values of overlapping areas for (i,j) els of curset\r\n  @param {Array} curset: current set of label with positions\r\n  @param {Number} changedLabelIndex: an index of label which position we changed\r\n  */\r\n  evaluateAfterSeveralChanged:function(curvalues,curset,changedLabels) {\r\n    var counter=0; //index to iterate through curvalue array\r\n    while(changedLabels.length>0){\r\n      var changedLabelIndex=changedLabels.pop();\r\n      for(var i=0;i<curset.length;i++){\r\n        for(var j=0;j<curset.length;j++){if(i>j){ //i,j like we used them in the evaluateCurSet function, so we get similar counter values\r\n          if(i===changedLabelIndex||j===changedLabelIndex){ //here we obtain all indexes of curvales array corresponding to changedLabelIndex\r\n            var area=this.checkOverLappingArea(curset[i].poly(),curset[j].poly(),this.options.minimizeTotalOverlappingArea); //and recalculate areas\r\n            curvalues[counter]=area;\r\n            }\r\n            counter++;\r\n          }\r\n        }\r\n      }\r\n    }\r\n    curvalues.pop(); //remove prev sum\r\n    this.assignCostFunctionValuesToLastEl(curvalues);\r\n  },\r\n\r\n  dodebug:function(message){\r\n    if(this.options.debug)console.log(message);\r\n  },\r\n\r\n  processOptions:function(options){\r\n    this.options=options || {};\r\n    this.options.t0 = this.options.t0 || 2.5;\r\n    this.options.decrease_value = this.options.decrease_value || 0.9; //decrease by ten percent each decrease step\r\n    this.options.tmin = this.options.tmin || 0.0;\r\n    this.options.constant_temp_repositionings = this.options.constant_temp_repositionings || 10;\r\n    this.options.max_improvments_count = this.options.max_improvments_count || 10;\r\n    this.options.max_noimprove_count = this.options.max_noimprove_count || 20;\r\n    this.options.maxsteps = this.options.maxsteps || 100;\r\n    this.options.maxtotaliterations = this.options.maxtotaliterations || 100000;\r\n    this.options.minimizeTotalOverlappingArea=this.options.minimizeTotalOverlappingArea || false;\r\n    this.options.debug=this.options.debug || true;\r\n    this.options.allowBothSidesOfLine=this.options.allowBothSidesOfLine || true;\r\n    candidateGenerator.options.lineDiscreteStepPx = this.options.lineDiscreteStepPx || candidateGenerator.options.lineDiscreteStepPx; //pixels\r\n  },\r\n\r\n  /**\r\n  find optimal label placement based on simulated annealing approach, relies on paper https://www.eecs.harvard.edu/shieber/Biblio/Papers/jc.label.pdf\r\n  @param {Array} all_items: an arr with labels and their available line segments to place\r\n  @param {Object} options: TODO [simulatedAnnealing] add options description\r\n  @param {Object} callback: a function to gather results and use them to render\r\n  @param {Object} context: a parent conext of the function  above (arguments.callee - but deprecated)\r\n  */\r\n  perform:function(all_items,options,callback,context) {\r\n        if(all_items.length<1){callback([])} //do nothing if no segments\r\n        else{\r\n          var t0 = performance.now();\r\n          this.processOptions(options);\r\n          //init\r\n          var curset=this.getInitialRandomState(all_items), //current label postions\r\n           curvalues = this.evaluateCurSet(curset), //current overlaping matrix (conflict graph)\r\n           t=this.options.t0, stepcount=0, doexit=curvalues[curvalues.length-1] === 0,//if no overlaping at init state, do nothing and return curretn state\r\n           iterations=0, This=this;\r\n\r\n          var doReturn = function(){\r\n              This.dodebug('overlapping labels count = '+curvalues.pop()+', total labels count = '+curset.length+', iterations = '+iterations);\r\n              This.dodebug('time to annealing = '+(performance.now()-t0));\r\n              This.markOveralppedLabels(curset,curvalues);\r\n              callback.call(context,curset);\r\n            }\r\n          }\r\n\r\n          //step\r\n          while(true){\r\n            //while(t>options.tmin && stepcount<options.maxsteps && !doexit\r\n            if(t<=this.options.tmin || stepcount>=this.options.maxsteps){\r\n              doReturn();\r\n              return;\r\n            }\r\n            stepcount++;\r\n            var improvements_count=0, no_improve_count=0;\r\n            for(var i=0;i<this.options.constant_temp_repositionings*curset.length;i++){ //while constant temperature, do some replacments\r\n              var oldvalues = curvalues.slice(0), //clone curvalues in order to return to ld ones\r\n                  oldset = curset.slice(0),\r\n                  overlapped_indexes = this.getOverlappingLabelsIndexes(curvalues,curset);\r\n              this.applyNewPositionsForLabelsInArray(overlapped_indexes,curset,all_items);\r\n              this.evaluateAfterSeveralChanged(curvalues,curset,overlapped_indexes);\r\n              iterations++;\r\n              if(curvalues[curvalues.length-1] === 0){ //no overlaps already\r\n                This.dodebug('strict solution');\r\n                doReturn();\r\n                return;\r\n              }\r\n              if(iterations>this.options.maxtotaliterations){ //not to hang too long\r\n                doReturn();\r\n                return;\r\n              }\r\n              var delta = (oldvalues[oldvalues.length-1]-curvalues[curvalues.length-1]);\r\n              if(delta<0){//ie, new labeling is worse!\r\n                var P=1 - Math.exp(delta/t);\r\n                if(P>Math.random()){ //undo label reposition with probability of P\r\n                  curvalues = oldvalues;\r\n                  curset=oldset;\r\n                  no_improve_count++;\r\n                }else { //approve new repositioning\r\n                  improvements_count++;\r\n                  no_improve_count=0;\r\n                }\r\n              }else{\r\n                 improvements_count++;\r\n                 no_improve_count=0;\r\n               }\r\n              if(no_improve_count>=this.options.max_noimprove_count*curset.length){ //it is already optimal\r\n                This.dodebug('stable state, finish on it');\r\n                doReturn();\r\n                return;\r\n              }\r\n              if(improvements_count>=this.options.max_improvments_count*curset.length){\r\n                break; //of for\r\n              }\r\n            }\r\n            //decrease t\r\n            t*=this.options.decrease_value;\r\n          };\r\n      }\r\n  }\r\n\r\n\r\nmodule.exports = simulatedAnnealing;\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/simulatedAnnealing.js\n ** module id = 9\n ** module chunks = 0\n **/","var geomEssentials = require('./geomEssentials.js');\r\nvar itemFactory = require('./LabelItem.js');\r\n\r\nvar candidateGenerator = {\r\n  options:{\r\n    lineDiscreteStepPx:3\r\n  },\r\n\r\n  obtainCandidateForPoint(point){\r\n    //TODO[obtainCandidateForPoint]\r\n  },\r\n\r\n  obtainCandidateForPoly(polygon){\r\n    //TODO[obtainCandidateForPoly]\r\n  },\r\n\r\n  /**\r\n  Get a poly (simple with no text along path)for random offset on the polyline\r\n  @param {Object} item: item from prepareCurSegments's allsegs\r\n  @returns {Array} : a poly bounding text, placed on corresponding point for offset on poluline and rotated to match segment's skew\r\n  */\r\n  obtainCandidateForPolyLineByRandomStartOffset:function(item){\r\n    var random_offset = item.totalLength*Math.random();\r\n    var candidate = itemFactory.candidatePosition(random_offset,item);\r\n    return candidate;\r\n  },\r\n\r\n  /**\r\n  computes label candidate object to place on map\r\n  @param {Number} i: an index in all_items array to obtain label candidate for i-item\r\n  @returns {candidatePosition} : generated candidate\r\n  */\r\n  computeLabelCandidate:function(i,all_items) {\r\n    var candidate;\r\n    switch (all_items[i].layer_type()) {\r\n      case 0:\r\n        break;\r\n      case 1:{\r\n          candidate=this.obtainCandidateForPolyLineByRandomStartOffset(all_items[i]);\r\n          break;\r\n        }\r\n      case 2:\r\n        break;\r\n    }\r\n    return candidate;\r\n  },\r\n}\r\n\r\nmodule.exports = candidateGenerator;\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/CandidateGenerator.js\n ** module id = 10\n ** module chunks = 0\n **/","/*\r\nmodlue to create labelItems convenient for labelling and calculation\r\n*/\r\n\r\nvar geomEssentials = require('./geomEssentials.js');\r\n\r\nmodule.exports = {\r\n  /**\r\n  a factory function for label items\r\n  @param {TextNode} txNode: SVG TextNode\r\n  @param {L.Point} txSize: size of bounding box for txNode\r\n  @param {L.Layer} layer: a feature (Marker, Polyline, Path) to aquire data\r\n  */\r\n  labelItem:function(txNode,txSize,layer,hostArray){\r\n    var basic_item= {\r\n      data:[],\r\n      txNode:txNode,\r\n      txSize:txSize,\r\n      layer:layer,\r\n      host:hostArray,\r\n      index:function(){\r\n        return this.host.lastIndexOf(this);\r\n      },\r\n      readData:function(){return false}, //a method stub\r\n      layer_type:function(){\r\n        //TOFIX for polygon\r\n        if(!this._layer_type)this._layer_type = (this.layer._parts.length>0)?1:0;\r\n        return this._layer_type;\r\n      }\r\n    };\r\n\r\n    if(basic_item.layer_type()==0){\r\n      return;\r\n      basic_item.readData = function(){\r\n        if(basic_item.layer.getLatLngs())\r\n        basic_item.data=basic_item.layer._map.latLngToLayerPoint(basic_item.layer.getLatLngs()[0]); //so we adding only L.Point obj\r\n      }\r\n    }else{\r\n      //this give possibility to read all parts to separate items\r\n      basic_item.readData=function(partIndex){ //to read consequently\r\n        if(!partIndex){var partIndex=0;};\r\n        this.data = this.layer._parts[partIndex];\r\n        this.partIndex=partIndex; //store this to have ability to compute totalOffset, for example\r\n        var nextPart=++partIndex;\r\n        if(nextPart<this.layer._parts.length)return nextPart;else return false;\r\n      }\r\n    }\r\n\r\n    if(basic_item.layer_type()==1){\r\n      if(basic_item.layer._parts.length==0)return;\r\n      basic_item.computed_lengths=[];\r\n      basic_item.totalLength=0;\r\n\r\n      basic_item.segCount = function(){return this.data.length -1};\r\n\r\n      /**\r\n      Get a segment from polyline part by it's offset\r\n      @param {Number} offset: na offset for the polyline\r\n      @returns {Array} : index of start point of segment and dist which is offset from start of the line to the end of found segment\r\n      */\r\n      basic_item.getSegmentIdxAndDistByOffset=function(offset){\r\n        return geomEssentials.getSegmentIdxAndDistByOffset(offset,this.data,this.computed_lengths);\r\n      }\r\n\r\n      /**      \r\n      get a random element from segments array of the item, assuming it is sorted lengths ascending order\r\n      probability is higher for longer segment\r\n      */\r\n      basic_item.getIndexBasedOnTotalLengthRandom=function(){\r\n        return geomEssentials.getIndexBasedOnTotalLengthRandom(this.data,this.computed_lengths,this.totalLength);\r\n      }\r\n    }\r\n    return basic_item;\r\n  },\r\n\r\n  candidatePosition:function(offset_or_origin,item){\r\n    return {\r\n      _item:item,\r\n      offset_or_origin:offset_or_origin,\r\n      _poly:false,\r\n      all_items_index:function(){\r\n        return this._item.index();\r\n      },\r\n\r\n      /**\r\n      Used for calculationg overlaps for text along path (textPath SVG).\r\n      @param {Number} start_offset: global offset for this polyline (item), same as used in rendering\r\n      @param {LabelItem} item:\r\n      @returns {Array} : a poly bounding curved text\r\n      */\r\n      _computePolyForLine:function(start_offset,item){\r\n        var final_offset = start_offset + item.txSize.x;\r\n        var end_offset=(final_offset<item.totalLength)?final_offset:item.totalLength;\r\n        return geomEssentials.computeLineBoundaryPolygon(start_offset,end_offset,item);\r\n      },\r\n\r\n      /**\r\n      common function switch for computing poly for different layer_types\r\n      */\r\n      _computePoly:function(){\r\n        switch(item.layer_type()){\r\n          case 0:break;\r\n          case 1:{\r\n              this._poly = this._computePolyForLine(this.offset_or_origin,this._item);\r\n            }\r\n          case 2:break;\r\n        }\r\n      },\r\n\r\n      poly:function(){\r\n        if(!this._poly)this._computePoly();\r\n        return this._poly;\r\n      }\r\n    }\r\n  },\r\n\r\n}\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/LabelItem.js\n ** module id = 11\n ** module chunks = 0\n **/","/**\r\nModule to extract sufficient info to label data on the map\r\n*/\r\n\r\n\"use strict\";\r\n\r\nvar DOMEssentials = require(\"./DOMEssentials.js\");\r\nvar geomEssentials = require(\"./geomEssentials.js\");\r\nvar itemFactory = require('./LabelItem.js');\r\n\r\nvar dataReader = {\r\n  /**\r\n  creates an array of features's segments for each feature  of layers2label's layers on screen along with SVG text corresponding to\r\n  @returns [Array] returns an array with values : {t:{content_node:SVG textnode},parts:feature parts,layertype}, then, in next funcs we add apoly param to t object, ir, its bounding polygon, layertype = 0 marker, 1 polyline, 2 polygon\r\n  */\r\n  readDataToLabel:function(){\r\n    var pt  =[];\r\n    if(this._map){\r\n      for(var i in this._map.autoLabeler._layers2label)\r\n      if(this._map.getZoom()>this._map.autoLabeler._layers2label[i]._al_options.zoomToStartLabel)\r\n      {\r\n        var lg=this._map.autoLabeler._layers2label[i],\r\n            map_to_add = this._map;\r\n        lg.eachLayer(function(layer){\r\n          if(layer.feature)\r\n          if(layer.feature.properties[lg._al_options.propertyName]){\r\n            var node = DOMEssentials.createSVGTextNode(layer.feature.properties[lg._al_options.propertyName],lg._al_options.labelStyle),\r\n                size = DOMEssentials.getBoundingBox(map_to_add,node); //compute ortho aligned bbox for this text, only once, common for all cases\r\n            var firstItem = itemFactory.labelItem(node,size,layer,pt)\r\n            if(firstItem){\r\n              var nextPartIndex=firstItem.readData();\r\n              pt.push(firstItem);\r\n              while(nextPartIndex){\r\n                var item = itemFactory.labelItem(node,size,layer,pt); //create node template\r\n                nextPartIndex=item.readData(nextPartIndex);\r\n                pt.push(item);\r\n              }\r\n            }\r\n          }\r\n        });\r\n      }\r\n    }\r\n    return pt;\r\n  },\r\n\r\n  /**\r\n  extracts good segments from available polyline parts and converts to use in next procedures of pos estimation\r\n  @param {Array} all_items:\r\n  @param {Set} options: options are:  {integer} maxlabelcount: if more labels in all_items, then do nothing\r\n  */\r\n  prepareCurSegments:function(all_items,options){\r\n    options = options || {};\r\n    options.maxlabelcount=options.maxlabelcount || 100;\r\n    if(all_items.length>options.maxlabelcount || all_items.length==0){\r\n      this._map.autoLabeler._dodebug('too much OR no labels to compute('+all_items.length+')');\r\n      return false;\r\n    }\r\n    for(var i=0;i<all_items.length;i++){\r\n      var item = all_items[i];\r\n      if(item.layer_type()==0){//if point -> do nothing.\r\n        continue;\r\n      }\r\n      //else compute for lines and polygons, now it is only fo lines\r\n      if(item.layer_type()==1){\r\n        this._applyLineFeatureData(item); //in case where two or move separate polylines generated for original polyline while rendering (imagine big W cutted by screen iwndow)\r\n      }\r\n    }\r\n    return true;\r\n  },\r\n\r\n  /**\r\n  Calculates total length for this polyline on screen, and lengths of each segments with their angles\r\n  @param {labelItem} item: an item to get above data to\r\n  */\r\n  _applyLineFeatureData:function(item){ //calculate some data once to increase performance\r\n      item.totalLength=0;\r\n      item.computed_lengths = geomEssentials.computeSegmentsLengths(item.data);\r\n      for(var k=0;k<item.computed_lengths.length;k++){\r\n        item.totalLength+=item.computed_lengths[k];\r\n      }\r\n  }\r\n}\r\n\r\nmodule.exports = dataReader;\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/DataReader.js\n ** module id = 12\n ** module chunks = 0\n **/"],"sourceRoot":""}