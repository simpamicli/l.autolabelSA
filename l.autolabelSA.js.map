{"version":3,"sources":["webpack:///webpack/bootstrap 5428da31e746fca37f3f","webpack:///./src/MapPart.js","webpack:///./src/DOMEssentials.js","webpack:///./src/geomEssentials.js","webpack:///./src/simulatedAnnealing.js","webpack:///./src/DataReader.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;ACtCA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;;AAGL;AACA;AACA;AACA,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,uEAAsE,iBAAiB,kBAAkB,EAAE;AAC3G;AACA,yDAAwD;AACxD;AACA,MAAK;;AAEL;AACA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAkB;AAClB;AACA;AACA;AACA;AACA,aAAY,OAAO;AACnB;AACA;AACA;AACA;AACA,6DAA4D;AAC5D,mDAAkD;AAClD,+DAA8D;AAC9D,2EAA0E;AAC1E;AACA,uEAAsE;AACtE,kGAAiG;AACjG,8EAA6E;AAC7E,0FAAyF;AACzF,MAAK;;;AAGL;AACA;AACA;AACA;AACA,oCAAmC;AACnC,kDAAiD;AACjD,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAqC,sBAAsB;AAC3D,oCAAmC,sBAAsB;AACzD;AACA,MAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAkD,qBAAqB;AACvE;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,kCAAiC;AACjC;AACA;AACA;AACA,uDAAsD,iBAAiB;AACvE;AACA;AACA;AACA;AACA,8CAA6C;AAC7C,QAAO;AACP;AACA;AACA,MAAK;;AAEL;AACA;AACA,aAAY,MAAM;AAClB,eAAc;AACd;AACA;AACA;AACA;AACA;AACA,mBAAkB,cAAc;AAChC;AACA;AACA;AACA,+CAA8C,kBAAkB,eAAe;AAC/E;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,gDAA+C;AAC/C,mBAAkB,qBAAqB,KAAK;AAC5C;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,mDAAkD;AAClD,0BAAyB;AACzB,mBAAkB,kBAAkB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAA+B;AAC/B;AACA;AACA;AACA;AACA,sCAAqC;AACrC;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAC;;;;;;;ACrOD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAU,cAAc;AACxB,aAAY;AACZ;AACA;AACA;AACA;AACA,2CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,WAAU,OAAO;AACjB,aAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA,yCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;AC/CA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAgD,SAAS;AACzD;AACA,sCAAqC,cAAc;AACnD;AACA,qBAAoB,UAAU;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,WAAU,MAAM;AAChB,WAAU,MAAM;AAChB,aAAY,MAAM;AAClB;AACA;AACA;AACA;AACA,iBAAgB,cAAc;AAC9B,4BAA2B;AAC3B;AACA;AACA,IAAG;;AAEH;AACA;AACA,WAAU,MAAM;AAChB,WAAU,MAAM;AAChB,aAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB,cAAc;AAC9B,4BAA2B;AAC3B;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,WAAU,MAAM;AAChB,WAAU,MAAM;AAChB,aAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,WAAU,MAAM;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA0C;AAC1C,kBAAiB,mBAAmB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA,WAAU,MAAM;AAChB,WAAU,MAAM;AAChB,WAAU,MAAM;AAChB,aAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA,iBAAgB,cAAc;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;ACpMA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAAyB,qBAAqB,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,6DAA4D;AAC5D;AACA;AACA,mFAAkF;AAClF;AACA,kEAAiE;AACjE,aAAY;AACZ,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA,WAAU,OAAO;AACjB,aAAY,OAAO,mBAAmB,2BAA2B;AACjE;AACA;AACA;AACA,0BAAyB;AACzB;AACA,0DAAyD;AACzD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,+FAA8F;AAC9F;AACA;AACA,cAAa;AACb;AACA,IAAG;;AAEH;AACA;AACA,WAAU,OAAO;AACjB,WAAU,MAAM;AAChB,aAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,WAAU,MAAM,yBAAyB,OAAO;AAChD,aAAY,MAAM;AAClB;AACA;AACA;AACA;AACA,iBAAgB,iBAAiB;AACjC;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,WAAU,OAAO;AACjB,WAAU,MAAM;AAChB,WAAU,MAAM;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,YAAW;AACX,YAAW;AACX,aAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAiC,cAAc;AAC/C,IAAG;;AAEH;AACA;AACA,WAAU,MAAM;AAChB;AACA;AACA;AACA;AACA,iBAAgB,4BAA4B;AAC5C;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,WAAU,MAAM;AAChB,aAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA,iBAAgB,gBAAgB;AAChC,mBAAkB,gBAAgB;AAClC,iBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,WAAU,MAAM;AAChB,WAAU,MAAM;AAChB,WAAU,OAAO;AACjB,aAAY,MAAM;AAClB;AACA;AACA;AACA,mBAAkB;AAClB,iBAAgB,gBAAgB;AAChC,mBAAkB,gBAAgB,KAAK,QAAQ;AAC/C,0DAAyD;AACzD,uHAAsH;AACtH;AACA;AACA;AACA;AACA;AACA;AACA,qBAAoB;AACpB;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA,sEAAqE;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;;AAEA,IAAG;;AAEH;AACA;AACA,WAAU,MAAM;AAChB,WAAU,OAAO;AACjB,WAAU,OAAO;AACjB,WAAU,OAAO;AACjB;AACA;AACA;AACA,8BAA6B,aAAa;AAC1C;AACA;AACA;AACA,0DAAyD;AACzD,uDAAsD;AACtD;AACA;AACA,0DAAyD;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAwB,qDAAqD;AAC7E,kDAAiD;AACjD,mFAAkF;AAClF;AACA,6EAA4E;AAC5E,+EAA8E;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA0B;AAC1B;AACA,qCAAoC;AACpC;AACA;AACA;AACA,kBAAiB,MAAM;AACvB;AACA;AACA;AACA,gBAAe;AACf;AACA;AACA;AACA,+EAA8E;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;ACnTA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,oDAAmD,GAAG,0BAA0B,+BAA+B;AAC/G;AACA;AACA;AACA;AACA;AACA,4FAA2F;AAC3F,mBAAkB,iCAAiC;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAqE;AACrE;AACA;AACA,2EAA0E;AAC1E,2CAA0C;AAC1C,+DAA8D;AAC9D;AACA;AACA;AACA;AACA,mDAAkD;AAClD;AACA;AACA;AACA,gFAA+E;AAC/E;;AAEA;AACA,4BAA2B,GAAG,4BAA4B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,WAAU,MAAM;AAChB,WAAU,IAAI,wBAAwB,MAAM,6GAA6G,QAAQ;AACjK;AACA;AACA;AACA;AACA;AACA,mDAAkD;AAClD;AACA;AACA;AACA;AACA,iBAAgB,sBAAsB;AACtC;AACA,6BAA4B;AAC5B,uBAAsB,iDAAiD;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA0B;AAC1B,mCAAkC;AAClC;AACA,qBAAoB,oBAAoB,KAAK;AAC7C;AACA,uBAAsB,iBAAiB;AACvC;AACA;AACA;AACA,yCAAwC;AACxC,gCAA+B;AAC/B,gEAA+D;AAC/D;AACA;AACA;;AAEA,0BAAyB;AACzB,0DAAyD;AACzD;AACA;AACA;AACA,IAAG;AACH;;AAEA","file":"l.autolabelSA.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"./\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 5428da31e746fca37f3f\n **/","(function () {\r\n  \"use strict\";\r\n\r\n   //TODO [general] test with diffenrent files\r\n   //TODO [general] add point and polygon labeling\r\n   //TODO [general] add text along path support\r\n\r\n  var DOMEssentials = require('./DOMEssentials.js');\r\n  var geomEssentials = require('./geomEssentials.js');\r\n  var simulatedAnnealing = require('./simulatedAnnealing.js');\r\n  var dataReader = require('./DataReader.js');\r\n\r\n\r\n  var __onRemove = L.LayerGroup.prototype.onRemove;\r\n  //to include in LabelGroup\r\n  /** @namespace AutoLabelingSupport*/\r\n  var AutoLabelingSupport = {\r\n      /**\r\n      handle removing layer from the map\r\n      @memberof AutoLabelingSupport#\r\n      */\r\n      onRemove: function (map) {\r\n      this.disableAutoLabel();\r\n        __onRemove.call(this, map);\r\n    },\r\n\r\n\r\n    /**\r\n     enable autolabeling for this layerGroup, additionally set the current_map variable if it is undefined and hooks label painting on moveend /zoomend events\r\n     it adds this layerGroup to the _layers2label array, so _doAutoLabel function will know about this layerGroup\r\n     @param {Object} options: labelStyle - css string to describe labels look, for now one for all layers in group, propertyName - a property from layer.feature.properties which we label on map\r\n     @memberof AutoLabelingSupport#\r\n    */\r\n    enableAutoLabel:function(options){\r\n      if(!this._map)return;\r\n      if(!this._map._layers2label)return;\r\n      this._al_options = options || {};\r\n      this._al_options.labelStyle = options.labelStyle || \"fill: lime; stroke: #000000;  font-size: 20px;\"; //TODO [enableAutoLabel] add ability to set unique style for each feature\r\n      this._al_options.propertyName = options.propertyName || \"name\";\r\n      this._al_options.priority = options.priority || 0; //highest\r\n      this._map._layers2label.push(this);\r\n    },\r\n\r\n    /**\r\n    Obtain autlabelling state for this layerGroup\r\n    @memberof AutoLabelingSupport#\r\n    @returns {Boolean}\r\n    */\r\n    autoLabelEnabled:function(){\r\n      if(!this._map._layers2label)return false;\r\n      return this._map._layers2label.indexOf(this)!=-1;\r\n    },\r\n\r\n    /**\r\n    disable autolabelling\r\n    @memberof AutoLabelingSupport#\r\n    */\r\n    disableAutoLabel:function(){\r\n      if(!this._map._layers2label){\r\n        delete this._al_options;\r\n        return;\r\n      }\r\n      var ind=this._map._layers2label.indexOf(this);\r\n      if(ind>=0){\r\n        this._map._layers2label.splice(ind,1);\r\n        delete this._al_options;\r\n      }\r\n    }\r\n  }\r\n\r\n  //to include in Map\r\n  /** @namespace MapAutoLabelSupport*/\r\n  var MapAutoLabelSupport = {\r\n    _nodes:[], //an array for storing SVG node to draw while autolabelling\r\n    _layers2label:[], //an array to know which layergroups are to label\r\n    _al_options:{}, //autolabel options for this map\r\n    //_al_timerID:-1, //variable to store current timer ID of simulated annealing timer - used for terminating annealing job\r\n    _autoLabel:false, //to detrmine if autolabelling is set for this map\r\n    /**\r\n    set global options for auto-labelling\r\n    @param {OBject} opts: see code\r\n    @memberof MapAutoLabelSupport#\r\n    */\r\n    setAutoLabelOptions: function (opts) {\r\n      this._al_options = opts || {};\r\n      this._al_options.showBBoxes = opts.showBBoxes ||false; //display bounding boxes around texts\r\n      this._al_options.debug = opts.debug || true; //show debug info in hte cons\r\n      this._al_options.labelsDelay = opts.labelsDelay || 1000; //a time after update event of renderer when labelling should start, if zero - errors while zooming\r\n      this._al_options.checkLabelsInside = opts.checkLabelsInside || true; //re-clip all segments to entirely fit map window without padding,\r\n                                                                           //disabling increases performance, but some labels maybe invisible due to padding of renderer\r\n      this._al_options.zoomToStartLabel = opts.zoomToStartLabel || 13; //if map zoom lev is below this, do not show labels\r\n      this._al_options.minimizeTotalOverlappingArea = opts.minimizeTotalOverlappingArea || false; //if true, minimize not the count of overlapping labels, but instead their total overlapping area\r\n      this._al_options.deleteIfNoSolution = opts.deleteIfNoSolution || false; //TODO [setAutoLabelOptions] if no solution can be achieivd, delete some of the labels, which are overlapping, based on their layer al_options.priority or random if equal\r\n      this._al_options.doNotShowIfSegIsTooSmall = opts.doNotShowIfSegIsTooSmall || false; //TODO [setAutoLabelOptions] if segment length is less then textlength of text, do not show this text\r\n    },\r\n\r\n\r\n    /**\r\n    toggles autolabeling\r\n    @memberof MapAutoLabelSupport#\r\n    */\r\n    toggleAutoLabelling:function(){ //this not tested yet\r\n      if(this._autoLabel)this.disableAutoLabel();else this.enableAutoLabel();\r\n    },\r\n    /**\r\n    enable autolabeling for this map\r\n    @memberof MapAutoLabelSupport#\r\n    */\r\n    enableAutoLabel:function(){\r\n      if(!this.options.renderer){\r\n        this._dodebug('renderer is invalid');\r\n        return;\r\n      }\r\n      this.setAutoLabelOptions(this._al_options);\r\n      this.options.renderer.on(\"update\",this._apply_doAutoLabel);\r\n      this.on(\"zoomstart\",function(){this._zoomstarttrig=1});\r\n      this.on(\"zoomend\",function(){this._zoomstarttrig=0});\r\n      this._autoLabel = true;\r\n    },\r\n\r\n    //to check if zoomstart event is fired to prevent autolabeling BEFORE zoomend\r\n    _zoomstarttrig:0,\r\n\r\n    //id of timeout after which AutoLabeling should be done each time - used to stop timer in case of changed map state BEFORE autolabelling was performed\r\n    _ctimerID:-1,\r\n\r\n    /**\r\n    disable autolabeling for this map\r\n    @memberof MapAutoLabelSupport#\r\n    */\r\n    disableAutoLabel:function(){\r\n      this.options.renderer.on(\"update\",this._apply_doAutoLabel);\r\n      this._autoLabel=false;\r\n    },\r\n\r\n    /*\r\n    beacuse we using update event of renderer, here we switching to map context and handling two-time update event of SVG renderer\r\n    */\r\n    _apply_doAutoLabel:function(){\r\n      if(this._map._ctimerID!=-1)clearTimeout(this._map._ctimerID);\r\n      if(this._map._zoomstarttrig==0){\r\n        var _this=this._map;\r\n        this._map._ctimerID=setTimeout(function(){_this._doAutoLabel()},this._al_options.labelsDelay);\r\n      }\r\n      this._map._clearNodes();\r\n    },\r\n\r\n    _dodebug:function(message){\r\n      if(this._al_options.debug)console.log(message);\r\n    },\r\n\r\n    /**\r\n    this function obtains visible polyline segments from screen and computes optimal positions and draws labels on map\r\n    */\r\n    _doAutoLabel:function() {\r\n      if(!this._autoLabel)return; //nothing to do here\r\n      if(this.getZoom()>this._al_options.zoomToStartLabel){\r\n        dataReader._map=this;\r\n        var pt  =dataReader.readDataToLabel() //array for storing paths and values\r\n        var allsegs=dataReader.prepareCurSegments(pt,{maxlabelcount:50});\r\n        if(allsegs.length==0){\r\n          this._clearNodes();\r\n          return;\r\n        }\r\n        simulatedAnnealing.perform(allsegs,{},this._renderNodes,this);\r\n      }else{\r\n        this._clearNodes();\r\n      }\r\n    },\r\n\r\n    /**\r\n    for test purposes now, creates a polygon node useing poly Array of points\r\n    @param {Array} poly\r\n    @returns {SVGPolygon}\r\n    @memberof MapAutoLabelSupport#\r\n    */\r\n    _createPolygonNode:function(poly){\r\n      var node = L.SVG.create('polygon');\r\n      var points='';\r\n      for(var i=0;i<poly.length;i++){\r\n        points+=poly[i][0]+','+poly[i][1]+' ';\r\n      }\r\n      node.setAttribute('points', points.trim());\r\n      node.setAttribute('style','fill: yellow; fill-opacity:0.1; stroke: black;');\r\n      return node;\r\n    },\r\n\r\n    /**\r\n    clears label on the screen\r\n    @memberof MapAutoLabelSupport#\r\n    */\r\n    _clearNodes:function() {\r\n    var svg = this.options.renderer._container;  //to work with SVG\r\n      for(var i=0;i<this._nodes.length;i++){//clear _nodes on screen\r\n        svg.removeChild(this._nodes[i]);\r\n      }\r\n      this._nodes=[];\r\n    },\r\n\r\n    /**\r\n    renders computed labelset on the screen via svg\r\n    @memberof MapAutoLabelSupport#\r\n    */\r\n    _renderNodes:function(labelset){\r\n      var svg =  this.options.renderer._container;  //to work with SVG\r\n      this._clearNodes(); //clearscreen\r\n      for(var m=0;m<labelset.length;m++){\r\n        var node = labelset[m].t.content_node;\r\n        var x = labelset[m].pos.x;\r\n        var y = labelset[m].pos.y;\r\n        node.setAttribute('x', x);\r\n        node.setAttribute('y', y);\r\n        var transform ='rotate('+ Math.floor(labelset[m].a)+','+Math.floor(x)+','+Math.floor(y)+')';\r\n        transform = transform.replace(/ /g, '\\u00A0');\r\n        node.setAttribute('transform',transform);\r\n        svg.appendChild(node);\r\n        this._nodes.push(node);//add this labl to _nodes array, so we can erase it from the screen later\r\n        if(this._al_options.showBBoxes){\r\n          //here for testing purposes\r\n          var polynode = this._createPolygonNode(labelset[m].poly);\r\n          svg.appendChild(polynode);\r\n          this._nodes.push(polynode); //add this polygon to _nodes array, so we can erase it from the screen later\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  L.LayerGroup.include(AutoLabelingSupport);\r\n  L.Map.include(MapAutoLabelSupport);\r\n})();\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/MapPart.js\n ** module id = 0\n ** module chunks = 0\n **/","//a class to compute pixel dimensions of texts\r\n/** @namespace DOMEssentials*/\r\n'use strict';\r\nvar geomEssentials = require(\"./geomEssentials.js\");\r\n\r\nvar DOMEssentials = {\r\n  /**\r\n  converts TextRectangle object to clockwise array of 2d-arrays, representing rectangular poly\r\n  @param {TextRectangle} rect: a bbox for text\r\n  @returns {Array}\r\n  @memberof DOMEssentials#\r\n  */\r\n  convertClientRectToArrayOfArrays:function(rect) {\r\n    var res=[];\r\n    var height_correction=rect.height*0.2; //beacuse getBoundingClientRect give a bit false height info\r\n    res.push([0,0]);\r\n    res.push([0,-rect.height]);\r\n    res.push([rect.width,-rect.height]);\r\n    res.push([rect.width,0]);\r\n    res=geomEssentials.movePolyByAdding(res,[0,height_correction]);\r\n    return res;\r\n  },\r\n\r\n  /**\r\n  returns a bounding box for horizontal text with style as in t.content_node\r\n  @param {Object} t: consist of content_node (SVG text) and this function is adding a new property called 'poly' contatining bbox in format [four points of bbox]\r\n  @returns {Array} poly: a bbox for t.content_node\r\n  @memberof DOMEssentials#\r\n  */\r\n  getBoundingBox:function(map,node){\r\n    var svg = map.options.renderer._container;\r\n    svg.appendChild(node);\r\n    var rect = node.getBoundingClientRect();\r\n    var ortho_poly = this.convertClientRectToArrayOfArrays(rect);\r\n    svg.removeChild(node);\r\n    return ortho_poly;\r\n  },\r\n\r\n  createSVGTextNode:function(text,textstyle){\r\n    text = text.replace(/ /g, '\\u00A0');  // Non breakable spaces\r\n    var node =L.SVG.create('text');\r\n    node.setAttribute('style',textstyle);\r\n    node.textContent = text;\r\n    return node;\r\n  }\r\n}\r\n\r\nmodule.exports = DOMEssentials;\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/DOMEssentials.js\n ** module id = 1\n ** module chunks = 0\n **/","//a class to perfrom geometric stuff\r\n/** @namespace geomEssentials*/\r\n'use strict';\r\nvar geomEssentials = {\r\n\r\n  /**\r\n  code from leaflet src, without some lines\r\n  we assume here, that clipPoints was already invoked\r\n  */\r\n  clipClippedPoints: function (layer_parts,bounds) {\r\n    var parts = [], i, j, k=0,len, len2, segment,points;\r\n    for (i = 0, k = 0, len = layer_parts.length; i < len; i++) {\r\n\t\t\tpoints = layer_parts[i];\r\n  \t\tfor (j = 0, len2 = points.length; j < len2 - 1; j++) {\r\n  \t\t\tsegment = L.LineUtil.clipSegment(points[j], points[j + 1], bounds, j, true);\r\n  \t\t\tif (!segment) { continue; }\r\n  \t\t\tparts[k] = parts[k] || [];\r\n  \t\t\tparts[k].push(segment[0]);\r\n  \t\t\t// if segment goes out of screen, or it's the last one, it's the end of the line part\r\n  \t\t\tif ((segment[1] !== points[j + 1]) || (j === len2 - 2)) {\r\n  \t\t\t\tparts[k].push(segment[1]);\r\n  \t\t\t\tk++;\r\n  \t\t\t}\r\n  \t\t}\r\n    }\r\n    return parts;\r\n\t},\r\n\r\n  roundPoint:function(p){\r\n    var res= L.point(Math.round(p.x),Math.round(p.y));\r\n    return res;\r\n  },\r\n\r\n  /**\r\n  scales bounds by multiplying it's size with scalefactor, and keeping center\r\n  */\r\n  scaleBounds:function(bounds,scalefactor){\r\n    var origin = bounds.getCenter();\r\n    var newHalfSize = bounds.getSize().multiplyBy(scalefactor/2);\r\n    var newTopLeft = origin.subtract(newHalfSize);\r\n    var newBotRight = origin.add(newHalfSize);\r\n    return L.bounds(this.roundPoint(newTopLeft),this.roundPoint(newBotRight));\r\n  },\r\n\r\n  /**\r\n  the name is the description\r\n  */\r\n  getBoundsWithoutPadding(themap,scaleafter){\r\n    var bounds =themap.options.renderer._bounds;\r\n    //to get zero padding we should scale bounds by 1 / (1 + current_padding), and then we want to scale by scaleafter\r\n    //for example, default padding is 0.1, which means 110% of map container pixel bounds to render, so zise of basic ixels bounds is multiplied by 1.1getPixelBounds()\r\n    var current_padding = themap.options.renderer.padding || 0.1;\r\n    var scale_to_apply = scaleafter/(1+current_padding);\r\n    return this.scaleBounds(bounds,scaleafter);\r\n    //return bounds;\r\n  },\r\n  /**\r\n  moves a poly by adding pt2add point to all its vertices\r\n  @param {Array} poly: a poly to movePoly\r\n  @param {Array} pt2add: a point to add to all vertices\r\n  @returns {Array}: moved poly\r\n  @memberof geomEssentials#\r\n  */\r\n  movePolyByAdding:function(poly,pt2add) {\r\n    var res=poly.slice(0);\r\n    for(var i=0;i<poly.length;i++){\r\n      res[i][0]+=pt2add[0]; res[i][1]+=pt2add[1];\r\n    }\r\n    return res;\r\n  },\r\n\r\n  /**\r\n  moves a poly by translating all its vertices to moveto\r\n  @param {Array} poly: a poly to movePoly\r\n  @param {Array} moveto: where translate all vertices\r\n  @returns {Array}: moved poly\r\n  @memberof geomEssentials#\r\n  */\r\n  movePolyByMovingTo:function(poly,moveto){\r\n    var res=poly.slice(0);\r\n    moveto[0] = moveto[0]-poly[0][0];\r\n    moveto[1] = moveto[1]-poly[0][1];\r\n    for(var i=1;i<poly.length;i++){\r\n      res[i][0]+=moveto[0]; res[i][1]+=moveto[1];\r\n    }\r\n    return res;\r\n  },\r\n  /**\r\n  code from L.GeometryUtil plugin\r\n  @memberof geomEssentials#\r\n  */\r\n  computeAngle: function(a, b) {\r\n      return (Math.atan2(b.y - a.y, b.x - a.x) * 180 / Math.PI);\r\n  },\r\n\r\n  /**\r\n  code from L.GeometryUtil plugin\r\n  @memberof geomEssentials#\r\n  */\r\n  interpolateOnPointSegment: function (pA, pB, ratio) {\r\n      return L.point(\r\n          (pA.x * (1 - ratio)) + (ratio * pB.x),\r\n          (pA.y * (1 - ratio)) + (ratio * pB.y)\r\n      );\r\n  },\r\n\r\n  /**\r\n  function from https://rosettacode.org/wiki/Sutherland-Hodgman_polygon_clipping#JavaScript\r\n  @param {Array} subjectPolygon: first poly\r\n  @param {Array} clipPolygon: second poly\r\n  @returns {Array} : result poly\r\n  @memberof geomEssentials#\r\n  */\r\n  clipPoly:function(subjectPolygon, clipPolygon) {\r\n    var cp1, cp2, s, e;\r\n    var inside = function (p) {\r\n        return (cp2[0]-cp1[0])*(p[1]-cp1[1]) > (cp2[1]-cp1[1])*(p[0]-cp1[0]);\r\n    };\r\n    var intersection = function () {\r\n        var dc = [ cp1[0] - cp2[0], cp1[1] - cp2[1] ],\r\n            dp = [ s[0] - e[0], s[1] - e[1] ],\r\n            n1 = cp1[0] * cp2[1] - cp1[1] * cp2[0],\r\n            n2 = s[0] * e[1] - s[1] * e[0],\r\n            n3 = 1.0 / (dc[0] * dp[1] - dc[1] * dp[0]);\r\n        return [(n1*dp[0] - n2*dc[0]) * n3, (n1*dp[1] - n2*dc[1]) * n3];\r\n    };\r\n    var outputList = subjectPolygon;\r\n    cp1 = clipPolygon[clipPolygon.length-1];\r\n    for (var j in clipPolygon) {\r\n        var cp2 = clipPolygon[j];\r\n        var inputList = outputList;\r\n        outputList = [];\r\n        s = inputList[inputList.length - 1]; //last on the input list\r\n        for (var i in inputList) {\r\n            var e = inputList[i];\r\n            if (inside(e)) {\r\n                if (!inside(s)) {\r\n                    outputList.push(intersection());\r\n                }\r\n                outputList.push(e);\r\n            }\r\n            else if (inside(s)) {\r\n                outputList.push(intersection());\r\n            }\r\n            s = e;\r\n        }\r\n        cp1 = cp2;\r\n    }\r\n    return outputList\r\n  },\r\n\r\n  /**\r\n  code from http://www.codeproject.com/Articles/13467/A-JavaScript-Implementation-of-the-Surveyor-s-Form\r\n  @param {Array} poly: a poly to determine area of\r\n  @memberof geomEssentials#\r\n  */\r\n  polyArea:function(poly) {\r\n    // Calculate the area of a polygon\r\n    // using the data stored\r\n    // in the arrays x and y\r\n    var area = 0.0;\r\n    if(poly){\r\n      var poly=poly.slice(0);\r\n      if(poly.length>2)poly.push(poly[0]); //close the poly\r\n      for( k = 0; k < poly.length-1; k++ ) {\r\n          var xDiff = poly[k+1][0] - poly[k][0];\r\n          var yDiff = poly[k+1][1] - poly[k][1];\r\n          area += + poly[k][0] * yDiff - poly[k][1] * xDiff;\r\n      }\r\n      area = 0.5 * area;\r\n    }\r\n    return area;\r\n  },\r\n\r\n  /**\r\n  rotates given polygon to a given angle around basepoint\r\n  code partialy from web, don't remember from...\r\n  @param {Array} poly: a polygon to rotate\r\n  @param {Array} basepoint: base point\r\n  @param {float} angle: an angle in degrees\r\n  @returns {Array}: rotated poly\r\n  @memberof geomEssentials#\r\n  */\r\n  rotatePoly:function(poly, basepoint,angle){\r\n    var res=[];\r\n    var angleRad = angle*Math.PI/180;\r\n    for(var i=0;i<poly.length;i++){\r\n      var pPoint = poly[i],\r\n      x_rotated = Math.cos(angleRad)*(pPoint[0]-basepoint[0]) - Math.sin(angleRad)*(pPoint[1]-basepoint[1]) + basepoint[0],\r\n      y_rotated = Math.sin(angleRad)*(pPoint[0]-basepoint[0]) + Math.cos(angleRad)*(pPoint[1]-basepoint[1]) + basepoint[1];\r\n      res.push([x_rotated,y_rotated]);\r\n    }\r\n    return res;\r\n  }\r\n}\r\n\r\nmodule.exports = geomEssentials;\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/geomEssentials.js\n ** module id = 2\n ** module chunks = 0\n **/","'use strict';\r\n\r\nvar geomEssentials = require(\"./geomEssentials.js\");\r\n\r\n//TODO [simulatedAnnealing] maybe do as factory function - to perform independently for different map instances\r\nvar simulatedAnnealing = {\r\n\r\n  obtainCandidateForPolyLine:function(seg_w_len,labelLength){\r\n    if(!seg_w_len){\r\n      return;\r\n    }\r\n    var seg = seg_w_len.seg, seglen = seg_w_len.seglen;\r\n    var segStartPt = seg[0],segEndPt=seg[1];\r\n    if(segStartPt.x>segEndPt.x){\r\n      var tmp=segStartPt; segStartPt=segEndPt; segEndPt=tmp; //be sure that text is always left-to-right\r\n    }\r\n    var p2add;\r\n    //now we need not let label exceed segment length. If seg is too small, the ratio shoud be zero\r\n    //so, calculate ratio as following:\r\n    if(labelLength>=seglen){\r\n      p2add = segStartPt;\r\n    }else{\r\n      var ratio = Math.random();\r\n      var allowed_max_ratio = (seglen - labelLength)/seglen;//is less than 1\r\n      //so\r\n      ratio*=allowed_max_ratio;\r\n      p2add = geomEssentials.interpolateOnPointSegment(segStartPt,segEndPt,ratio); //get actual insertion point for label\r\n    }\r\n    var angle = geomEssentials.computeAngle(segStartPt,segEndPt); //get its rotation around lower-left corner of BBox\r\n    return {p2add:p2add,angle:angle};\r\n  },\r\n\r\n  obtainCandidateForPoint(point){\r\n    //TODO[obtainCandidateForPoint]\r\n  },\r\n\r\n  obtainCandidateForPoly(ring){\r\n    //TODO[obtainCandidateForPoly]\r\n  },\r\n  /**\r\n  computes label candidate object to place on map\r\n  TODO [computeLabelCandidate] place label on both sides of segment\r\n  TODO [computeLabelCandidate] check label not to exceed side of the screen, maybe slide along segment\r\n  TODO [computeLabelCandidate] add polygon support: if two or more independent areas of one poly on screen, label both\r\n  @param {Number} i: an index in allsegs array to obtain label for candidate and segments array wuth segments to choose\r\n  @returns {Object} : an object with {t,poly,pos,a,allsegs_index} elements, such as t - text to label,poly - bounding rect of label, pos - pos to place label, a - angle to rotate label,allsegs_index - index in segments array\r\n  @memberof MapAutoLabelSupport#\r\n  */\r\n  computeLabelCandidate:function(i,allsegs) {\r\n    var t = allsegs[i].t; //label part\r\n    var segs = allsegs[i].segs;\r\n    var idx = Math.floor((Math.random() * segs.length) ); //choose the segment index from parts visible on screeen\r\n    var poly,point_and_angle;\r\n    poly = allsegs[i].t.poly;\r\n\r\n    switch (allsegs[i].layertype) {\r\n      case 0:\r\n        break;\r\n      case 1:\r\n        point_and_angle=this.obtainCandidateForPolyLine(segs[idx],t.poly[2][0]);\r\n        break;\r\n      case 2:\r\n        break;\r\n    }\r\n\r\n    if(point_and_angle.angle)poly=geomEssentials.rotatePoly(poly,[0,0],point_and_angle.angle); //rotate if we need this\r\n    poly=geomEssentials.movePolyByAdding(poly,[point_and_angle.p2add.x,point_and_angle.p2add.y]);\r\n    //TODO [computeLabelCandidate] check, if any of poly points outside the screen, if so, slide it along the segment to achieve no point such\r\n    var res={t:t,poly:poly,pos:point_and_angle.p2add,a:point_and_angle.angle,allsegs_index:i};\r\n    return res;\r\n  },\r\n\r\n  /**\r\n  clones element of curset\r\n  @param {Number} index:\r\n  @param {Array} curset:\r\n  @returns {Object}:\r\n  @memberof MapAutoLabelSupport#\r\n  */\r\n  copyCandidate:function(index,curset) {\r\n    var cancopy = curset[index];\r\n    cancopy.poly = curset[index].poly.slice(0);\r\n    return cancopy;\r\n  },\r\n\r\n  /**\r\n  computes the random set of positions for text placement with angles and text values\r\n  @param {Array} allsegs: an array with {t,segs} elements, according to t -text of the polyline, segs - its accepted segments to label on. Result array is generated from items of this array\r\n  @returns {Array} : an array with elements such as return values of computeLabelCandidate function\r\n  @memberof MapAutoLabelSupport#\r\n  */\r\n  getInitialRandomState:function(allsegs){\r\n    var res=[];\r\n    for(var i=0;i<allsegs.length;i++){\r\n      var candidate = this.computeLabelCandidate(i,allsegs);\r\n      res.push(candidate);\r\n    }\r\n    return res;\r\n  },\r\n\r\n  /**\r\n  swaps position for a random label with another from this label's positions pool\r\n  @param {Number} index : index of label in allsegs to select new random position from availavle choices.\r\n  @param {Array} curset: currently selected label postions\r\n  @param {Array} allsegs: all available postions\r\n  @memberof MapAutoLabelSupport#\r\n  */\r\n  swapCandidateInLabelSet:function(idx,curset,allsegs){\r\n    var label_index = curset[idx].allsegs_index;\r\n    var new_candidate = this.computeLabelCandidate(label_index,allsegs);\r\n    curset[idx]=new_candidate;\r\n  },\r\n\r\n  /**\r\n  check if two labels overlab, if no returns false, if yes returns ???area OR polygon??? of averlap\r\n  @param {} poly1:a first polygon to check overlap with second\r\n  @param {} poly2:a second polygon to check overlap with first\r\n  @returns {float}: an area of overlapping, zero if no overlapping\r\n  @memberof MapAutoLabelSupport#\r\n  */\r\n  checkOverLappingArea:function(poly1,poly2,calculateAreaNotOnlyFactOfOverlapping) {\r\n    var clipped = geomEssentials.clipPoly(poly1,poly2);\r\n    if(calculateAreaNotOnlyFactOfOverlapping){\r\n      var area =geomEssentials.polyArea(clipped);\r\n      return area;\r\n    };\r\n    if(clipped.length>0)return 1;else return 0; //for performance, skip area calculation\r\n  },\r\n\r\n  /**\r\n  may be a custom function, must add result as last value of input array\r\n  @param {Array} overlapping_values: input array of areas\r\n  @memberof MapAutoLabelSupport#\r\n  */\r\n  assignCostFunctionValuesToLastEl:function(overlapping_values){\r\n    var res=0;\r\n    for(var i=0;i<overlapping_values.length;i++)if(i<overlapping_values.length){\r\n      res+=overlapping_values[i];\r\n    }\r\n    overlapping_values.push(res);\r\n  },\r\n\r\n  /**\r\n  summarizing ovelapping of all layers. We store for each label it's total overlapping area with others, the sum values for all labels\r\n  @param {Array}:curset:\r\n  @returns {Array}: values of areas, last is sum\r\n  @memberof MapAutoLabelSupport#\r\n  */\r\n  evaluateCurSet:function(curset){\r\n    var res=0;\r\n    var overlap_values=[];\r\n    for(var i=0;i<curset.length;i++){\r\n      for(var j=0;j<curset.length;j++){\r\n        if(i>j){ //to exclude variants like compare (1,3) and then (3,1)\r\n        var curlabel_value=this.checkOverLappingArea(curset[i].poly,curset[j].poly,this.options.minimizeTotalOverlappingArea);\r\n        //for each pair(i,j) push it's value into overlap_values array\r\n        //we know that we iterate through only lower triangle of matrix (i,j), so we can reconstruct i and j from overlap_values index and vice versa\r\n        //we do it to improve speed when recomputing ovelaps in each annealing iteration in order not to compute all overlaps (with high performance cost)\r\n        //istead we recompute areas only for changed label\r\n        overlap_values.push(curlabel_value);\r\n        }\r\n      }\r\n    }\r\n    this.assignCostFunctionValuesToLastEl(overlap_values);\r\n    return overlap_values;\r\n  },\r\n\r\n  /**\r\n  calculates total overlapping area with knowlesge of previous value and what label was moved\r\n  @param {Array} curvalue: array of float computed at previous step or initital step, consist of elements of lower-triangluar matrix (i,j) of values of overlapping areas for (i,j) els of curset\r\n  @param {Array} curset: current set of label with positions\r\n  @param {Number} changedLabelIndex: an index of label which position we changed\r\n  @returns {Array} : curvalues, recalculated\r\n  @memberof MapAutoLabelSupport#\r\n  */\r\n  evaluateAfterOneChanged:function(curvalues,curset,changedLabelIndex) {\r\n    var counter=0; //index to iterate through curvalue array\r\n    for(var i=0;i<curset.length;i++){\r\n      for(var j=0;j<curset.length;j++){if(i>j){ //i,j like we used them in the evaluateCurSet function, so we get similar counter values\r\n        if(i===changedLabelIndex||j===changedLabelIndex){ //here we obtain all indexes of curvales array corresponding to changedLabelIndex\r\n          var area=this.checkOverLappingArea(curset[i].poly,curset[j].poly,this.options.minimizeTotalOverlappingArea); //and recalculate areas\r\n          curvalues[counter]=area;\r\n          }\r\n          counter++;\r\n        }\r\n      }\r\n    }\r\n    curvalues.pop(); //remove prev sum\r\n    this.assignCostFunctionValuesToLastEl(curvalues);\r\n    return curvalues;\r\n  },\r\n\r\n  dodebug:function(message){\r\n    if(this.options.debug)console.log(message);\r\n  },\r\n\r\n  processOptions:function(options){\r\n    this.options=options || {};\r\n    this.options.t0 = this.options.t0 || 2.5;\r\n    this.options.decrease_value = this.options.decrease_value || 0.9; //decrease by ten percent each decrease step\r\n    this.options.tmin = this.options.tmin || 0.0;\r\n    this.options.constant_temp_repositionings = this.options.constant_temp_repositionings || 10;\r\n    this.options.max_improvments_count = this.options.max_improvments_count || 10;\r\n    this.options.max_noimprove_count = this.options.max_noimprove_count || 50;\r\n    this.options.maxsteps = this.options.maxsteps || 100;\r\n    this.options.maxtotaliterations = this.options.maxtotaliterations || 100000;\r\n    this.options.minimizeTotalOverlappingArea=this.options.minimizeTotalOverlappingArea || false;\r\n    this.options.debug=this.options.debug || true;\r\n    this.options.allowBothSidesOfLine=this.options.allowBothSidesOfLine || true;\r\n  },\r\n\r\n  stopCalc:function(timerID,callback){\r\n\r\n  },\r\n\r\n  /**\r\n  find optimal label placement based on simulated annealing approach, relies on paper https://www.eecs.harvard.edu/shieber/Biblio/Papers/jc.label.pdf\r\n  @param {Array} allsegs: an arr with labels and their available line segments to place\r\n  @param {Object} options: TODO [simulatedAnnealing] add options description\r\n  @param {Object} callback: a function to gather results and use them to render\r\n  @param {Object} context: a parent conext of the function  above (arguments.callee - but deprecated)\r\n  @memberof MapAutoLabelSupport#\r\n  */\r\n  perform:function(allsegs,options,callback,context) {\r\n        if(allsegs.length<1){callback([])}else{\r\n          var t0 = performance.now();\r\n          this.processOptions(options);\r\n          //init\r\n          var curset=this.getInitialRandomState(allsegs); //current label postions\r\n          var curvalues = this.evaluateCurSet(curset); //current overlaping matrix\r\n          var t=options.t0;\r\n          var stepcount=0;\r\n          var doexit=curvalues[curvalues.length-1] === 0;//if no overlaping at init state, do nothing and return curretn state\r\n          var iterations=0;\r\n          var This=this;\r\n          var oldCenter = context.getCenter(), oldZoom = context.getZoom();\r\n          var doReturn = function(dorender){\r\n            This.dodebug('-----');\r\n            if(dorender){\r\n              This.dodebug('overlapping labels count = '+curvalues.pop()+', total labels count = '+curset.length+', iterations = '+iterations);\r\n              var t1 = performance.now();\r\n              This.dodebug('time to annealing = '+(t1-t0));\r\n              callback.call(context,curset);\r\n            }else{\r\n              This.dodebug('Map state has been changed. Terminated.');\r\n            }\r\n          }\r\n\r\n          //step\r\n          while(true){\r\n            var dorender=true;\r\n             //let know map which timer we are using\r\n            //while constant temperature, do some replacments:\r\n            //  while(t>options.tmin && stepcount<options.maxsteps && !doexit\r\n            if(t<=options.tmin || stepcount>=options.maxsteps)return;\r\n            stepcount++;\r\n            var improvements_count=0;\r\n            var no_improve_count=0;\r\n            for(var i=0;i<options.constant_temp_repositionings*curset.length;i++){\r\n              var oldvalues = curvalues.slice(0); //clone curvalues in order to return to ld ones\r\n              var random_label_ind = Math.floor((Math.random() * curset.length) ); //randomly choose one label\r\n              var old_pos = This.copyCandidate(random_label_ind,curset);\r\n              This.swapCandidateInLabelSet(random_label_ind,curset,allsegs); //change label position\r\n              This.evaluateAfterOneChanged(curvalues,curset,random_label_ind); //calc new sum\r\n              iterations++;\r\n              if(curvalues[curvalues.length-1] === 0){\r\n                This.dodebug('strict solution');\r\n                doReturn(dorender);\r\n                return;\r\n              }\r\n              var delta = (oldvalues[oldvalues.length-1]-curvalues[curvalues.length-1]);\r\n              if(delta<0){//ie, new labeling is worse!\r\n                var P=1 - Math.exp(delta/t);\r\n                if(P>Math.random()){ //undo label reposition with probability of P\r\n                  curvalues = oldvalues;\r\n                  curset[random_label_ind]=old_pos;\r\n                  no_improve_count++;\r\n                }else { //approve new repositioning\r\n                  improvements_count++;\r\n                  no_improve_count=0;\r\n                }\r\n              }else{\r\n                 improvements_count++;\r\n                 no_improve_count=0;\r\n               }\r\n              if(no_improve_count>=options.max_noimprove_count*curset.length){ //it is already optimal\r\n                This.dodebug('stable state, finish on it');\r\n                doReturn(dorender);\r\n                return;\r\n              }\r\n              if(improvements_count>=options.max_improvments_count*curset.length){\r\n                //immediately exit cycle and decrease current t\r\n                doReturn(dorender);\r\n                return;\r\n              }\r\n            }\r\n            //decrease t\r\n            t*=options.decrease_value;\r\n            if(iterations>5000){\r\n              doReturn(dorender);\r\n              return;\r\n            }\r\n          };\r\n      }\r\n  }\r\n}\r\n\r\nmodule.exports = simulatedAnnealing;\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/simulatedAnnealing.js\n ** module id = 3\n ** module chunks = 0\n **/","/**\r\nModule to extract sufficient info to label data on the map\r\n*/\r\nvar DOMEssentials = require(\"./DOMEssentials.js\");\r\nvar geomEssentials = require(\"./geomEssentials.js\");\r\n\r\nvar dataReader = {\r\n  /**\r\n  creates an array of features's segments for each feature  of layers2label's layers on screen along with SVG text corresponding to\r\n  @returns [Array] returns an array with values : {t:{content_node:SVG textnode},parts:feature parts,layertype}, then, in next funcs we add apoly param to t object, ir, its bounding polygon, layertype = 0 marker, 1 polyline, 2 polygon\r\n  @memberof MapAutoLabelSupport#\r\n  */\r\n  readDataToLabel:function(){\r\n    var pt  =[];\r\n    if(this._map){\r\n      var bounds_to_contain_labels = geomEssentials.getBoundsWithoutPadding(this._map,0.9); // if needed\r\n      for(var i=0;i<this._map._layers2label.length;i++){\r\n        var lg=this._map._layers2label[i];\r\n        var ll2 = this._map._layers2label;\r\n        var map_to_add = this._map;\r\n        lg.eachLayer(function(layer){\r\n          if(layer.feature)\r\n          if(layer.feature.properties[lg._al_options.propertyName]){\r\n            var node =DOMEssentials.createSVGTextNode(layer.feature.properties[lg._al_options.propertyName],lg._al_options.labelStyle);\r\n            var poly = DOMEssentials.getBoundingBox(map_to_add,node); //compute ortho aligned bbox for this text, only once, common for all cases\r\n            var layer_type = 0;\r\n            var centerOrParts=[];\r\n            if(layer instanceof L.Polyline || layer instanceof L.Polygon){ //polyline case\r\n                if(layer._parts.length>0){ //so, line is visible on screen and has property to label over it\r\n                  layer_type = layer instanceof L.Polygon?2:1; //0 goes to marker or circlemarker\r\n                  //TEMPORARY TOFIX\r\n                  if(layer_type==1 && this._map._al_options.checkLabelsInside){\r\n                      centerOrParts = geomEssentials.clipClippedPoints(layer._parts,bounds_to_contain_labels);\r\n                  }\r\n                  else centerOrParts=layer._parts; //for polygon\r\n                }\r\n              }\r\n            else if (layer instanceof L.CircleMarker || L.Marker){\r\n              centerOrParts = this._map.latLngToLayerPoint(layer.getLatLngs()); //so we adding only L.Point obj\r\n            }\r\n\r\n            if(centerOrParts.length>0){\r\n              var toAdd = {t:{content_node:node,poly:poly},parts:centerOrParts, layertype: layer_type};\r\n              pt.push(toAdd);\r\n            }\r\n            }\r\n          }\r\n        );\r\n      }\r\n    }\r\n    return pt;\r\n  },\r\n\r\n  /**\r\n  extracts good segments from available polyline parts and converts to use in next procedures of pos estimation\r\n  @param {Array} ptcollection: each item is conatiner with t:label to draw for this polyline, parts - parts of this pline visible on screen in pixel coords\r\n  @param {Set} options: options are: {float} minSegLen: if segment length less than this, it is skipped except it is the only one for current polyline, {integer} maxlabelcount: if more labels in ptcollection, then do nothing\r\n  @memberof MapAutoLabelSupport#\r\n  */\r\n  prepareCurSegments(ptcollection,options){\r\n    options = options || {};\r\n    options.maxlabelcount=options.maxlabelcount || 100;\r\n    if(ptcollection.length>options.maxlabelcount){ //FIXME [prepareCurSegments] not aproper way to do things, to overcome two time rendering while zooming\r\n      this._map.dodebug('too much labels to compute('+ptcollection.length+'>'+options.maxlabelcount+')');\r\n      return [];\r\n    }\r\n    var allsegs=[];\r\n    for(var i=0;i<ptcollection.length;i++){\r\n      var item = ptcollection[i];\r\n      if(item.layertype==0){//if point -> do nothing.\r\n        allsegs.push({t:item.t,origin:t.parts,layertype:item.layertype});\r\n        continue;\r\n      }\r\n      //else compute for lines and polygons\r\n      //TODO[prepareCurSegments] add valid parsing for polygon case\r\n      //TODO[prepareCurSegments]IMPORTANT clip _parts angain to about 0.9 size of screen bbox\r\n      //now it is only fo lines\r\n      if(item.layertype==1){\r\n        var cursetItem=[]; //set of valid segments for this item\r\n        var too_small_segments=[]; //set of segment which length is less the label's lebgth of corresponding feature\r\n        var labelLength = item.t.poly[2][0];\r\n        for(var j=0;j<item.parts.length;j++){ //here we aquire segments to label\r\n          var curpart = item.parts[j];\r\n          for(var k=1;k<curpart.length;k++){\r\n            var a = curpart[k-1];\r\n            var b = curpart[k];\r\n            var ab = [a,b];\r\n            var ablen = a.distanceTo(b); //compute segment length only once\r\n            var what_to_push ={seg:ab,seglen:ablen};\r\n            if(ablen>labelLength)cursetItem.push(what_to_push);else too_small_segments.push(what_to_push);\r\n          }\r\n        }\r\n      }\r\n\r\n      var to_all_segs = {t:item.t,layertype:item.layertype};\r\n      if(cursetItem.length>0)to_all_segs.segs=cursetItem;else to_all_segs.segs=too_small_segments;\r\n      allsegs.push(to_all_segs);\r\n    }\r\n    return allsegs;\r\n  },\r\n}\r\n\r\nmodule.exports = dataReader;\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/DataReader.js\n ** module id = 4\n ** module chunks = 0\n **/"],"sourceRoot":""}